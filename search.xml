<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Socket通信</title>
      <link href="/2022/07/06/socket-tong-xin/"/>
      <url>/2022/07/06/socket-tong-xin/</url>
      
        <content type="html"><![CDATA[<h3 id="一、数据通信过程"><a href="#一、数据通信过程" class="headerlink" title="一、数据通信过程"></a>一、数据通信过程</h3><p><strong>一个数据包经由应用程序产生，进入到协议栈中进行各种报文头的包装，然后操作系统调用网卡驱动程序指挥硬件，把数据发送到对端主机</strong>。整个过程的大体的图示如下。</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220706142933670.png" alt="image-20220706142933670"></p><p>协议栈其实是位于操作系统中的一些协议的堆叠，这些协议包括 TCP、UDP、ARP、ICMP、IP等。</p><pre><code>通常某个协议的设计都是为了解决某些问题，比如TCP 的设计就负责安全可靠的传输数据，UDP 设计就是报文小，传输效率高，ARP 的设计是能够通过 IP 地址查询物理（Mac）地址，ICMP 的设计目的是返回错误报文给主机，IP 设计的目的是为了实现大规模主机的互联互通。    </code></pre><p><strong>一般处于协议上层的是TCP、UDP协议，IP协议处于下层，这个从TCP&#x2F;IP四层协议当也可以看得到，IP协议是不可靠的，需要为上层的TCP协议提供通信支持，TCP协议是可靠的，因为有三次握手四次挥手。</strong></p><p>应用程序比如浏览器、电子邮件、文件传输服务器等产生的数据，会通过传输层协议进行传输，而应用程序是不会和传输层直接建立联系的，而是有一个能够连接应用层和传输层之间的套件，这个套件就是 <code>Socket</code>。</p><p>应用程序的下面就是操作系统内部，操作系统内部包括协议栈，协议栈是一系列协议的堆叠。操作系统下面就是网卡驱动程序，网卡驱动程序负责控制网卡硬件，驱动程序驱动网卡硬件完成收发工作.</p><h3 id="二、通过netstat-命令来展示套接字"><a href="#二、通过netstat-命令来展示套接字" class="headerlink" title="二、通过netstat 命令来展示套接字"></a>二、通过netstat 命令来展示套接字</h3><pre><code> netstat -ano  # netstat 用于显示套接字内容 , -ano 是可选选项 # a 不仅显示正在通信的套接字，还显示包括尚未开始通信等状态的所有套接字 # n 显示 IP 地址和端口号 # o 显示套接字的程序 PID</code></pre><p><img src="https://pic3.zhimg.com/v2-a5b445147b1f4a683500901d35704662_r.jpg" alt="preview"></p><p>图中的每一行都相当于一个套接字，每一列也被称为一个元组，所以一个套接字就是五元组（协议、本地地址、外部地址、状态、PID）。有的时候也被叫做四元组，四元组不包括协议。</p><p>比如图中的第一行，它的协议就是 TCP，本地地址和远程地址都是 0.0.0.0，这表示通信还没有开始，IP 地址暂时还未确定，而本地端口已知是 135，但是远程端口还未知，此时的状态是 <code>LISTENING</code>，LISTENING 表示应用程序已经打开，正在等待与远程主机建立连接最后一个元组是 PID，即进程标识符，PID 就像我们的身份证号码，能够精确定位唯一的进程。</p><h3 id="三、OSI七层协议模型-open-system-interconnection"><a href="#三、OSI七层协议模型-open-system-interconnection" class="headerlink" title="三、OSI七层协议模型 (open system interconnection)"></a>三、OSI七层协议模型 (open system interconnection)</h3><pre><code>应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等表示层：处理数据格式，数据加密等会话层：建立、维护和管理会话传输层：TCP，UDP网络层：IP，ICMP，OSPF，EIGRP，IGMP数据链路层：SLIP，CSLIP，PPP，MTU物理层：比特流传输</code></pre><p>每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220706135944058.png" alt="image-20220706135944058"></p><p>通过上面的图形，由于底一层的需要向高一层的提供服务，我们大致的理解<strong>应用程序需要传输层的tcp和网络层的ip协议提供服务</strong>，可以说，TPC&#x2F;IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。</p><h3 id="四、Socket"><a href="#四、Socket" class="headerlink" title="四、Socket"></a>四、Socket</h3><p><strong>Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口，Socket是对TCP&#x2F;IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP&#x2F;IP协议。</strong></p><h4 id="3-1-Socket创建"><a href="#3-1-Socket创建" class="headerlink" title="3.1 Socket创建"></a>3.1 Socket创建</h4><p>Socket 是和应用程序一起创建的。</p><pre><code>1、应用程序中有一个 socket 组件，在应用程序启动时，会调用 socket 申请创建套接字，协议栈会根据应用程序的申请创建套接字：2、首先分配一个套接字所需的内存空间，这一步相当于是为控制信息准备一个容器，但只有容器并没有实际作用，所以你还需要向容器中放入控制信息；3、如果你不申请创建套接字所需要的内存空间，你创建的控制信息也没有地方存放，所以分配内存空间，放入控制信息缺一不可。至此套接字的创建就已经完成了。4、套接字创建完成后，会返回一个套接字描述符给应用程序，这个描述符相当于是区分不同套接字的号码牌。根据这个描述符，应用程序在委托协议栈收发数据时就需要提供这个描述符。</code></pre><h4 id="3-2-套接字连接"><a href="#3-2-套接字连接" class="headerlink" title="3.2 套接字连接"></a>3.2 套接字连接</h4><p>套接字创建完成后，最终还是为数据收发服务的，在数据收发之前，还需要进行一步 <code>connect</code>，也就是建立连接的过程。应用程序通过 TCP&#x2F;IP 协议标准从一个主机通过网络介质传输到另一个主机的过程。</p><pre><code>1、套接字刚刚创建完成后，还没有数据，也不知道通信对象。在这种状态下，即使你让客户端应用程序委托协议栈发送数据，它也不知道发送到哪里。    2、所以浏览器需要根据网址来查询服务器的 IP 地址，做这项工作的协议是 DNS，查询到目标主机后，再把目标主机的 IP 告诉协议栈，至此，客户端这边就准备好了    3、在服务器上，与客户端一样也需要创建套接字，但是同样的它也不知道通信对象是谁，所以我们需要让客户端向服务器告知客户端的必要信息：IP 地址和端口号。    4、通信双方收到数据之后，还需要一块位置来存放，这个位置就是缓冲区，它是内存的一部分，有了缓冲区，就能够进行数据的收发操作了。</code></pre><p>具体实现</p><p>客户端应用程序需要调用 <code>Socket</code> 库中的 connect 方法，提供 socket 描述符和服务器 IP 地址、端口号。</p><p>这些信息会传递给协议栈中的 TCP 模块，TCP 模块会对请求报文进行封装，再传递给 IP 模块，进行 IP 报文头的封装，然后传递给物理层，进行帧头封装，之后通过网络介质传递给服务器，服务器上会对帧头、IP 模块、TCP 模块的报文头进行解析，从而找到对应的套接字，套接字收到请求后，会写入相应的信息，并且把状态改为正在连接。请求过程完成后，服务器的 TCP 模块会返回响应，这个过程和客户端是一样的。</p><h3 id="四、TCP-x2F-IP、Socket、Http的区别"><a href="#四、TCP-x2F-IP、Socket、Http的区别" class="headerlink" title="四、TCP&#x2F;IP、Socket、Http的区别"></a>四、TCP&#x2F;IP、Socket、Http的区别</h3><p>http是要基于TCP连接基础上的，简单的说，TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。客户端和应用服务器建立TCP连接之后，就需要用http协议来传送数据了，HTTP协议简单来说，还是请求，确认，连接。 总体就是C发送一个HTTP请求给S，S收到了这个http请求，然后返回给Chttp响应，然后C的中间件或者说浏览器把这些数据渲染成为了网页，展示在用户面前。</p><pre><code>1.socket是通信的基石，是TCP/IP的基本操作单元（最小单位），可以理解为TCP/IP的封装，调用接口,(所有的程序都是默认调用吗？)    2.应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务(所有应用层都一样？)    3.HTTP等应用层协议，格式的统一（像串口协议一样，格式和速度）    4.Http是基于TCP协议的，tcp计算机通信传数据，但是无法解析数据，解析需要http协议</code></pre><p>http是网络上层协议。底层还是socket短连接是发送数据时进行联接。发送完关闭(http基于短连接的tcp协议)；可以认为不论应用层协议使用的是什么，都是通过调用Socket(对传输层的封装)去进行数据传输的。</p><p>具体应用层使用什么协议，需要按照实际需求去进行操作，比如短连接则可以通过http请求实现；长链接可以使用调用Socket去实现。</p><pre><code>    长连接：通信双方长期的保持一个连接状态不断开，一旦建立连接后，就不断开，除非发生异常，比较消耗IO资源。    短连接：通信双方不是保持一个长期的连接状态，比如Http协议，当客户端发起http请求，服务器处理http请求，当服务器处理完成后，返回客户端数据后就断开链接。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Mina </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="/2022/07/03/docker-xue-xi-bi-ji/"/>
      <url>/2022/07/03/docker-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>Docker是基于go开发的</p><h3 id="一、为什么使用docker"><a href="#一、为什么使用docker" class="headerlink" title="一、为什么使用docker"></a>一、为什么使用docker</h3><p>带着环境安装到Docker上，解决环境问题；解决了集群问题</p><p>镜像：将代码，Redis、、、等环境打包成一个镜像，在其他地方可以直接运行，无需在重新安装软件、代码；将正确的环境打包成镜像，直接运行，理念是一次打包处处运行，”一次封装，处处运行”</p><p>只需要一次配置好环境，换到其他的机子上就可以一键运行，大大简化了操作</p><p>四个集装箱（部署四个软件），各自独立，放到一个镜像当中，运行镜像即可</p><h3 id="二、Docker三要素：仓库、镜像、容器"><a href="#二、Docker三要素：仓库、镜像、容器" class="headerlink" title="二、Docker三要素：仓库、镜像、容器"></a>二、Docker三要素：仓库、镜像、容器</h3><p>容器：集装箱就是一个容器，每一个容器当中安装我们要需要的软件，Docker就是鲸鱼，背上有几个集装箱就有几个容器</p><p>虚拟机：模拟的是整套操作系统（模拟的操作系统、软硬件—虚拟硬件，然后在硬件上虚拟软件操作系统），但是启动时间时分钟级别的，Docker启动时秒级别的；</p><p>Docker模拟的是操作系统，直接运行在宿主机上的（没有进行硬件虚拟），没有虚拟自己的内核，用的是宿主机的，所以启动快；容器之间是相互隔离的，每个容器由自己的文件系统，容器之间进程不会相互影响，能区分计算资源</p><p>运行环境的打包封装，这饿环境的一个整体就是镜像，DockerHub上就是存镜像的，</p><p>从仓库拉一个应用到本地就是镜像（Image）,某一个镜像的实例就是一个集装箱容器，各自独立的容器就是一个一个的环境(Redis、Ngnix)</p><h4 id="1、镜像"><a href="#1、镜像" class="headerlink" title="1、镜像"></a>1、镜像</h4><p>镜像(Image)：Docker镜像就是一个只读的模版，镜像可以用来创建Docker容器，一个镜像可以创建很多容器—类</p><h4 id="2、容器"><a href="#2、容器" class="headerlink" title="2、容器"></a>2、容器</h4><p>容器(Container)：镜像的实例—对象，Docker利用容器运行一个或一组应用，容器是用镜像创建的运行实例，可以对容器进行启动、开始、停止、删除；每个容器都是相互隔离的、保证安全的平台</p><p>可以吧容器看成是一个简易版本的Linux环境(包括root用户权限、进程空间、用户空间、网络空间等)和运行在其中的程序</p><p>容器的定义和镜像几乎一摸一样，也是一堆层的统一视角，唯一的区别是，容器的最上面那一层是可读可写的</p><p>容器是一个运行时环境，可以看成是鲸鱼上一个个的集装箱。</p><h4 id="3、仓库"><a href="#3、仓库" class="headerlink" title="3、仓库"></a>3、仓库</h4><p>仓库(Repository)：仓库是存放镜像文件的场所,仓库和仓库注册服务器是有区别的，仓库注册服务器上面存放着多个仓库，每个仓库又包含多个镜像，每个镜像又不同的标签(tag)</p><p>仓库分为公共仓库(public)和私有仓库(private)2种，最大的公共仓库是Docker Hub(<a href="https://hub.docker.com)---在国外,特别慢,存放了数量庞大的镜像供用户下载,国内的公共开源镜像又阿里云、网易云等/">https://hub.docker.com)---在国外，特别慢，存放了数量庞大的镜像供用户下载，国内的公共开源镜像又阿里云、网易云等</a></p><p>Docker本身是一个容器运行载体，或者称之为管理引擎，我们把应用程序和配置文件打包成包，形成一个可交付的运行环境，这个打包好的运行环境就似乎是一个镜像，只有通过镜像才可以生成Docker容器</p><p>镜像可以看成是容器的模版，Docker根据Image文件生成容器的实例，同一个镜像文件，可以生成多个同时运行的容器实例。</p><p>镜像文件生成的容器实例，本身也是一个文件，称为镜像文件</p><p>一个容器运行一种服务，当我们需要的时候，就可以通过Docker客户端创建一个对应的运行实例，也就是我们的容器</p><p>至于仓库，也就是存放镜像的地方，我们可以吧镜像发布到仓库中，需要的时候从仓库中拉下来救可以啦</p><p>平台架构图如下所示：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220618162307428.png" alt="image-20220618162307428"></p><h3 id="三、指令"><a href="#三、指令" class="headerlink" title="三、指令"></a>三、指令</h3><p>1、docker相关–帮助启动类命令</p><pre class=" language-java"><code class="language-java"># 启动$ systemctl start docker  # 停止$ systemctl stop docker  # 重启$ systemctl restart docker  # 查看状态$ systemctl status docker  # 开机自启$ systemctl enable docker  # docker信息$ docker info  # 帮助$ docker <span class="token operator">--</span>help  # 具体帮助$ docker  具体指令 <span class="token operator">--</span>help</code></pre><p>2、镜像</p><pre class=" language-jav"><code class="language-jav"># 查看所有镜像$ docker images# 查看远程镜像$ docker search 镜像名# 下载镜像$ docker pull 镜像名# 查看 镜像/容器/数据卷所占用的内存空间$ docker system df# 删除镜像$ docker rmi 镜像名# 强制删除镜像$ docker rmi -f 镜像名</code></pre><p>虚悬镜像：仓库名和tag都是空的镜像，一般是由于构建镜像的时候出问题导致的，这种镜像删除就好了</p><p>3、容器</p><pre class=" language-java"><code class="language-java"># 运行ubunto<span class="token operator">:</span>latest镜像，并开启交互式模式启动一个容器，在容器内部执行<span class="token operator">/</span>bin<span class="token operator">/</span>sh指令，推出使用exec；$ docker run <span class="token operator">-</span>it ubunto <span class="token operator">/</span>bin<span class="token operator">/</span>sh# 给容器起名字$ docker run <span class="token operator">-</span>it <span class="token operator">--</span>name<span class="token operator">=</span><span class="token string">"myubunto"</span> ubunto <span class="token operator">/</span>bin<span class="token operator">/</span>sh# 后台方式启动容器$ docker run <span class="token operator">-</span>d <span class="token operator">--</span>name<span class="token operator">=</span><span class="token string">"myubunto"</span> ubunto # 列出所有正在运行的容器$ docker ps# 列出所有正在运行<span class="token operator">/</span>历史运行的容器包括挂了的容器）$ docker ps <span class="token operator">-</span>a# 列出最近创建的容器（包括挂了的容器）$ docker ps <span class="token operator">-</span>l# 列出最近创建的<span class="token number">3</span>个容器（包括挂了的容器）$ docker ps <span class="token operator">-</span>n <span class="token number">3</span>    # 退出容器<span class="token operator">--</span>容器关闭$ exec# 退出容器<span class="token operator">--</span>容器不关闭$ ctrl<span class="token operator">+</span>p<span class="token operator">+</span>q  # 启动已经停止运行的容器$ docker start 容器ID<span class="token operator">/</span>名字  # 重启容器$ docker restart 容器ID<span class="token operator">/</span>名字    # 关闭容器$ docker stop 容器ID<span class="token operator">/</span>名字   # 强制停止容器$ docker kill 容器ID<span class="token operator">/</span>名字     # 删除已停止的容器$ docker rm 容器ID<span class="token operator">/</span>名字       # 查看容器运行日志$ docker logs 容器ID  # 查看容器内部运行的进程$ docker top 容器ID  # 查看容器内部情况$ docker inspect 容器ID  </code></pre><p>exec和attach的区别</p><pre class=" language-java"><code class="language-java"># 使用exit退出不会关闭容器<span class="token punctuation">(</span>一般进入容器当中查看信息<span class="token punctuation">)</span>docker exec <span class="token operator">-</span>it 容器ID  <span class="token operator">/</span>bin<span class="token operator">/</span>sh # 使用exit退出会关闭容器docker attach 容器ID </code></pre><p>从镜像的角度看，可以把容器看成是简易版本的Linux环境，</p><pre><code># 将容器内的内容拷贝到宿主机上$ docker cp 容器ID：容器内路径  宿主机路径# 将容器拷贝到宿主机上,归档成一个tar包$ docker export 容器ID  &gt;  文件名.tareg: docker export efewtwe1231  &gt;  ubunto.tar# 根据tar包的内容创建一个新的系统并导入成镜像(即新建一个镜像)$ cat  文件名.tar | docker import - 镜像用户/镜像名：版本号eg: cat  ubunto.tar | docker import - techen/ubanto：3.7</code></pre><h3 id="四、Docker仓库"><a href="#四、Docker仓库" class="headerlink" title="四、Docker仓库"></a>四、Docker仓库</h3><p>镜像是只读的，容器是可写的，一般在容器当中新增功能，然后使用commit指令生成新的镜像</p><pre class=" language-java"><code class="language-java"># 提交镜像<span class="token operator">:</span>提交之后成为了一个新的镜像$ docker commit  # 提交镜像<span class="token operator">:</span>提交之后成为了一个新的镜像$ docker commit <span class="token operator">-</span>m<span class="token operator">=</span><span class="token string">"提交的描述信息"</span> <span class="token operator">-</span>a<span class="token operator">=</span><span class="token string">"作者"</span> 容器ID  要创建的目标镜像名：版本eg：docker commit <span class="token operator">-</span>m<span class="token operator">=</span><span class="token string">"add vim "</span> <span class="token operator">-</span>a<span class="token operator">=</span><span class="token string">"techen"</span> efrfsfd12  techen<span class="token operator">/</span>myubunto<span class="token operator">:</span><span class="token number">3.23</span>  </code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619145133791.png" alt="image-20220619145133791"></p><p>1、将本地镜像提交到阿里云镜像当中</p><p>登陆阿里云—&gt; 管理控制台—〉 容器镜像服务 —&gt;实例列表 —&gt; 个人实例 —&gt; 命名空间建命名、镜像仓库建立仓库</p><pre class=" language-java"><code class="language-java"><span class="token number">1</span><span class="token punctuation">.</span> 登录阿里云Docker Registry$ docker login <span class="token operator">--</span>username<span class="token operator">=</span>乾程吴彦祖 registry<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。（bzq18107155240）您可以在访问凭证页面修改凭证密码。<span class="token number">2</span><span class="token punctuation">.</span> 从Registry中拉取镜像$ docker pull registry<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com<span class="token operator">/</span>techen<span class="token operator">/</span>superzqbo<span class="token operator">:</span><span class="token punctuation">[</span>镜像版本号<span class="token punctuation">]</span><span class="token number">3</span><span class="token punctuation">.</span> 将镜像推送到Registry$ docker login <span class="token operator">--</span>username<span class="token operator">=</span>乾程吴彦祖 registry<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com$ docker tag <span class="token punctuation">[</span>ImageId<span class="token punctuation">]</span> registry<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com<span class="token operator">/</span>techen<span class="token operator">/</span>superzqbo<span class="token operator">:</span><span class="token punctuation">[</span>镜像版本号<span class="token punctuation">]</span>$ docker push registry<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com<span class="token operator">/</span>techen<span class="token operator">/</span>superzqbo<span class="token operator">:</span><span class="token punctuation">[</span>镜像版本号<span class="token punctuation">]</span>请根据实际镜像信息替换示例中的<span class="token punctuation">[</span>ImageId<span class="token punctuation">]</span>和<span class="token punctuation">[</span>镜像版本号<span class="token punctuation">]</span>参数。<span class="token number">4</span><span class="token punctuation">.</span> 选择合适的镜像仓库地址从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。如果您使用的机器位于VPC网络，请使用 registry<span class="token operator">-</span>vpc<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com 作为Registry的域名登录。<span class="token number">5</span><span class="token punctuation">.</span> 示例使用<span class="token string">"docker tag"</span>命令重命名镜像，并将它通过专有网络地址推送至Registry。$ docker imagesREPOSITORY                                                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZEregistry<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com<span class="token operator">/</span>acs<span class="token operator">/</span>agent                                    <span class="token number">0.7</span><span class="token operator">-</span>dfb6816         37bb9c63c8b2        <span class="token number">7</span> days ago          <span class="token number">37.89</span> MB$ docker tag 37bb9c63c8b2 registry<span class="token operator">-</span>vpc<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com<span class="token operator">/</span>acs<span class="token operator">/</span>agent<span class="token operator">:</span><span class="token number">0.7</span><span class="token operator">-</span>dfb6816使用 <span class="token string">"docker push"</span> 命令将该镜像推送至远程。$ docker push registry<span class="token operator">-</span>vpc<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com<span class="token operator">/</span>acs<span class="token operator">/</span>agent<span class="token operator">:</span><span class="token number">0.7</span><span class="token operator">-</span>dfb6816</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619152906932.png" alt="image-20220619152906932"></p><p>2、将本地镜像推送到私服</p><p>在本地新建一个私有仓库供内部使用，Docker Registry是官方提供的工具，用于构建本地私有镜像仓库</p><pre class=" language-java"><code class="language-java"># 拉取Docker Registry工具$ docker pull registry  # 查看拉取Docker Registry工具是否成功$ docker images  # 运行私有库Registry，相当于本地有一个Docker Hub<span class="token punctuation">;</span>默认情况下会被容器会被创建在<span class="token operator">/</span>var<span class="token operator">/</span>lib<span class="token operator">/</span>registry下$ docker run <span class="token operator">-</span>d <span class="token operator">-</span>p <span class="token number">5000</span><span class="token operator">:</span><span class="token number">5000</span> <span class="token operator">-</span>v <span class="token operator">/</span>home<span class="token operator">/</span>techen<span class="token operator">/</span>docker_registry<span class="token operator">/</span><span class="token operator">:</span>tmp<span class="token operator">/</span>registry <span class="token operator">--</span>privileged<span class="token operator">=</span><span class="token boolean">true</span> registry    # 验证私服库上有什么镜像（相当于发送了一个Get请求）$ curl <span class="token operator">-</span>XGET http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>ip<span class="token operator">:</span>port<span class="token operator">/</span>v2<span class="token operator">/</span>_catalog# 将新镜像改造成符合私服镜像的tag$ docker tag 镜像：Tag  IP：port<span class="token operator">/</span>Repository<span class="token operator">:</span>Tag  # 推送$ docker push ip<span class="token operator">:</span>port<span class="token operator">/</span>镜像<span class="token operator">:</span>版本  # 拉取$ docker pull ip<span class="token operator">:</span>port<span class="token operator">/</span>镜像<span class="token operator">:</span>版本</code></pre><p>Docker默认不支持http方式推送镜像，要做如下处理</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619160634368.png" alt="image-20220619160634368"></p><h3 id="五、数据卷"><a href="#五、数据卷" class="headerlink" title="五、数据卷"></a>五、数据卷</h3><p>Docker挂载主机目录访问出现：cannot open directory.:Permission denied</p><p>解决办法；在挂载后面加上 –privileged &#x3D; true 参数即可</p><p>原理：Linux内部默认关掉了容器目录挂载的权限</p><p>数据卷主要的作用是映射(数据互相访问)，完成容器内数据的持久化</p><pre class=" language-java"><code class="language-java"># 运行一个带有数据卷的容器（如果目录不存在，会自动创建）$ docker run <span class="token operator">-</span>it <span class="token operator">--</span>priviledged<span class="token operator">=</span><span class="token boolean">true</span> <span class="token operator">-</span>v 宿主机目录<span class="token operator">:</span><span class="token operator">/</span>容器目录  <span class="token operator">--</span>name<span class="token operator">=</span>容器起名  镜像名    # 运行一个带有数据卷的容器（如果目录不存在，会自动创建）<span class="token punctuation">,</span>容器可读可写<span class="token punctuation">(</span>默认<span class="token punctuation">)</span>$ docker run <span class="token operator">-</span>it <span class="token operator">--</span>priviledged<span class="token operator">=</span><span class="token boolean">true</span> <span class="token operator">-</span>v 宿主机目录<span class="token operator">:</span><span class="token operator">/</span>容器目录<span class="token operator">:</span>rv  <span class="token operator">--</span>name<span class="token operator">=</span>容器起名  镜像名  # 运行一个带有数据卷的容器（如果目录不存在，会自动创建）<span class="token punctuation">,</span>容器可读不可写<span class="token punctuation">(</span>容器内不能创建目录、编写文件<span class="token punctuation">)</span>$ docker run <span class="token operator">-</span>it <span class="token operator">--</span>priviledged<span class="token operator">=</span><span class="token boolean">true</span> <span class="token operator">-</span>v 宿主机目录<span class="token operator">:</span><span class="token operator">/</span>容器目录<span class="token operator">:</span>ro  <span class="token operator">--</span>name<span class="token operator">=</span>容器起名  镜像名</code></pre><pre class=" language-java"><code class="language-java"># 查看挂载信息<span class="token punctuation">(</span>Mounts里面会有挂载信息<span class="token punctuation">)</span>$ docker inspect 容器id</code></pre><p>数据卷的继承和共享</p><pre class=" language-java"><code class="language-java"># 实现容器u1和u2之间的数据共享$ docker run <span class="token operator">-</span>it <span class="token operator">--</span>priviledged<span class="token operator">=</span><span class="token boolean">true</span> <span class="token operator">--</span>volumes<span class="token operator">-</span>from 父类<span class="token punctuation">(</span>容器名<span class="token operator">-</span>u1<span class="token punctuation">)</span>   <span class="token operator">--</span>name<span class="token operator">=</span>u2  镜像名</code></pre><h3 id="六、DockerFile"><a href="#六、DockerFile" class="headerlink" title="六、DockerFile"></a>六、DockerFile</h3><p>1、DockerFile概念</p><p>DockerFile是用来构建<strong>Docker镜像</strong>的文本文件，是由一条条构建镜像所需的指令和参数构成的<strong>脚本</strong></p><p>DockerFile相当于是一个镜像文件，是可以正常打包运行的</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619170534907.png" alt="image-20220619170534907"></p><p>2、DockerFile构建过程</p><p>DockerFile内容基础知识</p><pre class=" language-java"><code class="language-java"><span class="token number">1</span>、每条保留字指令都必须为大写字母且后面要跟随至少一个参数<span class="token number">2</span>、指令按照从上到下的顺序执行<span class="token number">3</span>、#表示注解<span class="token number">4</span>、每条指令都会创建一个新的镜像层，并对镜像层进行镜像提交</code></pre><p>3、Docker执行DockerFile的大致流程</p><pre class=" language-java"><code class="language-java"><span class="token number">1</span>、Docker从基础镜像运行一个容器<span class="token number">2</span>、执行一条指令并对容器做出修改<span class="token number">3</span>、执行类似docker commit的操作提交一个新的镜像层<span class="token number">4</span>、docker基于刚刚提交的镜像运行一个新的容器<span class="token number">5</span>、执行DockerFile当中的下一条指令，直到所有的指令都执行完毕</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619172050676.png" alt="image-20220619172050676"></p><p>4、DockerFile保留字介绍</p><pre class=" language-java"><code class="language-java">FROM<span class="token operator">:</span>基础镜像，当前的新镜像是基于哪个镜像MAINTAINER：镜像维护者的姓名和邮箱RUN：容器构建是需要执行的指令，即build时就会执行DockerFile当中run里面的指令，一般有<span class="token number">2</span>种格式shell、exec格式<span class="token punctuation">(</span>docker build时执行<span class="token punctuation">)</span>EXPOSE：当前容器对外暴漏的端口WORKDIR：指定在创建容器后，终端默认登陆进来的目录，一个落脚点USER：指令该镜像已什么样的用户去执行，默认rootENV：设置环境变量，设置后后面可以使用     eg<span class="token operator">:</span> ENV MY_PATH <span class="token operator">/</span>usr<span class="token operator">/</span>mytest         WORKDIR $MY_PATHADD<span class="token operator">:</span>将宿主机目录下的文件拷贝进镜像，且会自动处理URL和解压tar压缩包<span class="token punctuation">(</span>copy<span class="token operator">+</span>解压<span class="token punctuation">)</span>COPY：类似ADD，将文件拷贝到镜像VOLUME：数据卷CMD：指定容器启动后要做的操作，DockerFile当中可以有多个CMD指令，但是只有最后一个会生效，CMD会被docker run之后的参数替换掉     CMD是在docker run的时候运行     RUN是在docker build的时候运行ENTRYPOINT<span class="token operator">:</span>也是用来指定一个<span class="token operator">*</span><span class="token operator">*</span>容器启动时要执行的指令<span class="token operator">*</span><span class="token operator">*</span>，类似于CMD，但是ENTRYPOINT不会被docker run之后的参数替换掉，而且这些命令行参数会被当中参数传递给ENTRYPOINT指定的程序     ENTRYPOINT<span class="token punctuation">[</span><span class="token string">"exec"</span><span class="token punctuation">,</span><span class="token string">"parm1"</span><span class="token punctuation">,</span><span class="token string">"parm2"</span><span class="token punctuation">]</span>     ENTRYPOINT、CMD可以一起使用，一般变参会使用CMD，这里的CMD相当于给ENTRYPOINT传递参数     eg<span class="token operator">:</span>                    FROM nginx          ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"nginx"</span><span class="token punctuation">,</span><span class="token string">"-c"</span><span class="token punctuation">]</span> # 定参          CMD <span class="token punctuation">[</span><span class="token string">"/etc/ngnix/nginx.conf"</span><span class="token punctuation">]</span>   #变参     <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>》 nginx <span class="token operator">-</span>c <span class="token operator">/</span>etc<span class="token operator">/</span>ngnix<span class="token operator">/</span>nginx<span class="token punctuation">.</span>conf  </code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619175320535.png" alt="image-20220619175320535"></p><p>5、构建DockerFile文件</p><p>1、编写</p><pre class=" language-java"><code class="language-java">FROM java<span class="token operator">:</span><span class="token number">8</span>   # java8作为基础镜像ENV PROJECT_HOME <span class="token operator">/</span>home<span class="token operator">/</span>project  #设置环境变量，设置后后面可以使用ENV FILE_NAME placeholderENV EXPOSE_PORT <span class="token number">8080</span>ENV ACTIVE_ENV devENV JAVA_OPTS <span class="token string">""</span>RUN ln <span class="token operator">-</span>sf <span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>zoneinfo<span class="token operator">/</span>Asia<span class="token operator">/</span>Shanghai <span class="token operator">/</span>etc<span class="token operator">/</span>localtimeRUN echo <span class="token string">'Asia/Shanghai'</span> <span class="token operator">></span><span class="token operator">/</span>etc<span class="token operator">/</span>timezoneRUN apk add <span class="token operator">--</span>update ttf<span class="token operator">-</span>dejavu fontconfig <span class="token operator">&amp;&amp;</span> rm <span class="token operator">-</span>rf <span class="token operator">/</span>var<span class="token operator">/</span>cache<span class="token operator">/</span>apk<span class="token operator">/</span><span class="token operator">*</span>RUN set <span class="token operator">-</span>x <span class="token operator">&amp;&amp;</span> \    mkdir <span class="token operator">-</span>p <span class="token operator">/</span>root<span class="token operator">/</span>logs<span class="token operator">/</span>$FILE_NAME <span class="token operator">&amp;&amp;</span> \    mkdir <span class="token operator">-</span>p $PROJECT_HOMEWORKDIR $PROJECT_HOMEENTRYPOINT <span class="token punctuation">[</span> <span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar $PROJECT_HOME/$FILE_NAME.jar --spring.profiles.active=$ACTIVE_ENV"</span> <span class="token punctuation">]</span>EXPOSE $EXPOSE_PORT</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619181857597.png" alt="image-20220619181857597"></p><p>2、构建</p><pre class=" language-java"><code class="language-java"># 在dockerfile文件下执行下面的指令（注意tag后面有个空格和点）$ docker build <span class="token operator">-</span>t 新镜像的名字：TAG <span class="token punctuation">.</span></code></pre><p>3、运行</p><pre class=" language-java"><code class="language-java">docker run 镜像名  # 测试服务接口是否可用  $ curl  <span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6001</span><span class="token operator">/</span>order<span class="token operator">/</span>test</code></pre><h3 id="七、Docker网络"><a href="#七、Docker网络" class="headerlink" title="七、Docker网络"></a>七、Docker网络</h3><p>docker安装之后会默认创建三个网络</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621003150868.png" alt="image-20220621003150868"></p><pre class=" language-java"><code class="language-java"># 创建网络$ docker network create net1  # 删除网络$ docker network rm net1  # 查看网络源数据$ docker network inspect net1</code></pre><p>1、容器之间的互联通信以及端口映射</p><p>2、容器Ip发生变化时，可以通过服务名直接调用</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621003304909.png" alt="image-20220621003304909"></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619205257295.png" alt="image-20220619205257295"></p><p>Docker容器内部的IP时有可能变化的，所以一般相互通信的服务要设置在同一个网段下面，新建一个网络，它的驱动模式是bridge。</p><h3 id="八、Docker-compose"><a href="#八、Docker-compose" class="headerlink" title="八、Docker-compose"></a>八、Docker-compose</h3><p>用来做容器管理的，相当于一次启动所有容器</p><pre class=" language-java"><code class="language-java">Docker<span class="token operator">-</span>compose使用的流程<span class="token number">1</span>、编写DockerFile文件，定义各个微服务并构建成镜像<span class="token number">2</span>、使用Docker<span class="token operator">-</span>componse定义完整的业务单元<span class="token number">3</span>、使用docker<span class="token operator">-</span>compose up启动</code></pre><p>常用指令</p><pre class=" language-java"><code class="language-java"># 查看帮助$ docker<span class="token operator">-</span>compose <span class="token operator">-</span>h   # 启动服务$ docker<span class="token operator">-</span>compose up   # 后台启动服务$ docker<span class="token operator">-</span>compose up <span class="token operator">-</span>d  # 停止并删除所有容器、网络、卷、镜像$ docker<span class="token operator">-</span>compose down  # 进入容器内部$ docker<span class="token operator">-</span>compose exec yml里面服务的ID <span class="token operator">/</span>bin<span class="token operator">/</span>bash  # 展示所有当前docker<span class="token operator">-</span>compose编排过且运行的容器$ docker<span class="token operator">-</span>compose ps # 展示所有当前docker<span class="token operator">-</span>compose编排过的容器的进程$ docker<span class="token operator">-</span>compose top  # 查看容器的输出日志$ docker<span class="token operator">-</span>compose logs yml里面服务的ID # 检查配置<span class="token punctuation">(</span>检查语法<span class="token punctuation">)</span>$ docker<span class="token operator">-</span>compose config # 检查配置，有问题才输出$ docker<span class="token operator">-</span>compose config <span class="token operator">-</span>q  # 重启$ docker<span class="token operator">-</span>compose restart  # 关闭$ docker<span class="token operator">-</span>compose stop  # 开启$ docker<span class="token operator">-</span>compose start</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark使用手册</title>
      <link href="/2022/05/11/wireshark-shi-yong-shou-ce/"/>
      <url>/2022/05/11/wireshark-shi-yong-shou-ce/</url>
      
        <content type="html"><![CDATA[<p>这个抓包工具介绍,具体袭击我如下所示</p><p>这是概览，期间能遇到各种报错，只需复制报错信息到网上查找即可。</p><p>1.注册git账号（zhangsan），创建以账号名加.github.io为名的仓库（zhangsan.github.io即为博客地址，输入浏览器即可浏览）</p><p>2.在windows中安装gitbash，安装Nodejs，Nodejs要设置环境变量</p><p>3.下载hexo，将git仓库的ssh地址写入配置文件</p><p>4.windows中生成git的rsa密钥，将id_rsa.pub添加都git账号的ssh key中，一个系统中可以支持多个git密钥的生成，都生成在~&#x2F;.ssh&#x2F;目录下，命名不同即可</p><p>5.hexo常用命令</p><p>hexo new “titename” (生成文章，默认在source&#x2F;_post&#x2F;下，内容以markdown编辑)</p><p>hexo clean(清理旧的生成)</p><p>hexo generation（重新生成页面）</p><p>hexo deploy（部署到git上，部署前，如果</p>]]></content>
      
      
      <categories>
          
          <category> 网络工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makrdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建个人博客</title>
      <link href="/2022/05/06/ru-he-da-jian-ge-ren-bo-ke/"/>
      <url>/2022/05/06/ru-he-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<p>Welcome come to my blog</p><p>这是概览，期间能遇到各种报错，只需复制报错信息到网上查找即可。</p><p>1.注册git账号（zhangsan），创建以账号名加.github.io为名的仓库（zhangsan.github.io即为博客地址，输入浏览器即可浏览）</p><p>2.在windows中安装gitbash，安装Nodejs，Nodejs要设置环境变量</p><p>3.下载hexo，将git仓库的ssh地址写入配置文件</p><p>4.windows中生成git的rsa密钥，将id_rsa.pub添加都git账号的ssh key中，一个系统中可以支持多个git密钥的生成，都生成在~&#x2F;.ssh&#x2F;目录下，命名不同即可</p><p>5.hexo常用命令</p><p>hexo new “titename” (生成文章，默认在source&#x2F;_post&#x2F;下，内容以markdown编辑)</p><p>hexo clean(清理旧的生成)</p><p>hexo generation（重新生成页面）</p><p>hexo deploy（部署到git上，部署前，如果</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/05/hello-world/"/>
      <url>/2022/05/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
