<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>反射</title>
      <link href="/2022/10/04/fan-she/"/>
      <url>/2022/10/04/fan-she/</url>
      
        <content type="html"><![CDATA[<h2 id="一、反射">一、反射</h2><h3 id="1-1-创建运行时类的对象">1.1 创建运行时类的对象</h3><pre class="language-java" data-language="java"><code class="language-java">Class&lt;Person&gt; clazz &#x3D; Person.class;Person obj &#x3D; clazz.newInstance();System.out.print(obj);注意：    要想clazz.newInstance()运行成功，需要满足以下的需求    1、运行时类必须提供无参构造器    2、无参构造器的访问权限必须是public    </code></pre><blockquote><p>在javaBean当中，一般要求提供一个public的无参构造器</p><p>原因：</p><p>​1、便于通过反射，创建运行时类的对象</p><p>​2、便于子类集成父类时，通过super()调用父类构造器</p></blockquote><h3 id="1-2-获取运行时类的完整结构">1.2 获取运行时类的完整结构</h3><p>我们可以通过反射，回去运行时类中所有的属性、方法、构造器、父类、接口、包、泛型、注解等</p><pre class="language-java" data-language="java"><code class="language-java">public void test2()&#123;Class clazz &#x3D; Person.class;&#x2F;&#x2F; 获取属性结构:当前运行类及父类的的所有public访问权限的属性Field[] fields &#x3D; clazz.getFields();for (Field field : fields) &#123;System.out.println(field);&#125;&#x2F;&#x2F; 获得当前运行类当中申明的所有属性(不包含父类的)Field[] declaredFields &#x3D; clazz.getDeclaredFields();for (Field declaredField : declaredFields) &#123;System.out.println(declaredField);&#125;&#125;public void test3()&#123;Class clazz &#x3D; Person.class;&#x2F;&#x2F; 当前运行类包名Package pack &#x3D; clazz.getPackage();System.out.println(pack);&#125;public void test4()&#123;Class clazz &#x3D; Person.class;&#x2F;&#x2F; 当前运行类注解Annotation []  annotations &#x3D; clazz.getAnnotations();for (Annotation annotation : annotations) &#123;System.out.println(annotation);&#125;&#125;</code></pre><h3 id="1-3-调用运行时类的指定结构">1.3 调用运行时类的指定结构</h3><pre class="language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 属性public void test5()&#123;Class clazz &#x3D; Person.class;&#x2F;&#x2F; 创建运行时类对象Person p &#x3D; (Person) clazz.newInstance();&#x2F;&#x2F; 获取运行时类当中指定变量名的属性Field name &#x3D;clazz.getDeclaredField(&quot;name&quot;);&#x2F;&#x2F; 保证当前属性是可以访问的name.setAccessible(true);&#x2F;&#x2F; 设置、获取指定对象的此属性值name.set(p,&quot;Tom&quot;);System.out.println(name.get(p));&#125;&#x2F;&#x2F; 方法public void test6()&#123;Class clazz &#x3D; Person.class;&#x2F;&#x2F; 创建运行时类对象Person p &#x3D; (Person) clazz.newInstance();&#x2F;&#x2F; 获取运行时类当中指定的某个方法：参数1--方法名,参数2--入参Method method &#x3D;clazz.getDeclaredMethod(&quot;name&quot;,String.class);&#x2F;&#x2F; 保证当前方法是可以访问的method.setAccessible(true);&#x2F;&#x2F; 调用方法: 返回值就是方法的返回值Object object&#x3D; method.invoke(p,&quot;CHN&quot;);System.out.println(object);&#125;&#x2F;&#x2F; 构造器public void test8()&#123;Class clazz &#x3D; Person.class;&#x2F;&#x2F; 获取运行时类当中有参构造器Constructor constructor &#x3D;clazz.getDeclaredConstructor(String.class);&#x2F;&#x2F; 保证当前构造器是可以访问的constructor.setAccessible(true);&#x2F;&#x2F; 调用次构造器创建运行时类对象Person person &#x3D; constructor.newInstance(&quot;Toms&quot;);System.out.println(person);&#125;</code></pre><h2 id="二、代理">二、代理</h2><p>使用一个代理将对象包装起来，之后人后对原始对象的访问都要经过代理，代理决定是否以及何时去请求原始对象，代理分为动态代理和静态代理</p><p>静态代理：代理类和目标类在编译期间就确定了，同时，没一个代理类只能为一个接口服务，这样会需要很多的代理</p><p>动态里：使用一个代理完成所有的代理功能、在程序执行过程中，使用jdk的<strong>反射</strong>机制，创建代理类对象， 并动态的指定要代理目标类。</p><h3 id="2-1-静态代理">2.1 静态代理</h3><blockquote><ol><li>创建一个接口</li><li>创建厂家类，实现1步骤的接口</li><li>创建代理，也需要实现1步骤中的接口。</li><li>创建客户端类，调用代理</li></ol></blockquote><pre class="language-java" data-language="java"><code class="language-java">public interface Human &#123;    int eat(int count);&#125;&#x2F;&#x2F;目标类：public class AppleFactory implements Human &#123;    @Override    public int eat(int count) &#123;        System.out.println(&quot;目标类中的方法调用 , AppleFactory 中的eat &quot;);        return count;    &#125;&#125;public class JD implements Human &#123;    &#x2F;&#x2F;声明 被代理类    private Human factory &#x3D; new AppleFactory();    @Override    public int eat(int count) &#123;        &#x2F;&#x2F;调用被代理类        int count &#x3D; factory.eat(count);        &#x2F;&#x2F;代理增加。        count +&#x3D; 40;&#x2F;&#x2F;增强功能，代理类在完成目标类方法调用后，增强了功能。        System.out.println(&quot;吃了！&quot;);        return count;    &#125;&#125;public class Customer &#123;    public static void main(String[] args) &#123;        JD j &#x3D; new JD();        int count &#x3D; j.eat(1);        System.out.println(count);    &#125;&#125;</code></pre><h3 id="2-2-动态代理">2.2 动态代理</h3><pre class="language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; 接口  &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;** * @ClassName Human * @description: 动态代理:接口 *&#x2F;public interface Human &#123;    String getBelief();    void eat(String food);&#125;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; 被代理类  &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;** * @ClassName SuperMan * @description: 被代理类 *&#x2F;public class SuperMan implements Human&#123;    @Override    public String getBelief() &#123;        return &quot;I believe I can fly&quot;;    &#125;    @Override    public void eat(String food) &#123;        System.out.println(&quot;I love eat &quot;+ food);    &#125;&#125;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; 动态代理类  &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;** * @ClassName ProxyTest * @description: 代理类 *               问题一：如何根据加载到内存当中的代理类，动态的创建一个代理类及其对象(动态创建代理类及对象) *               问题二：当通过代理类的对象调用方法时，如何动态的去调用被代理类的同名方法(动态创建被代理类方法) * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-10-04 18:00:49 *&#x2F;public class ProxyFactory &#123;    &#x2F;**     * obj:被代理类对象(需要知道被代理类是啥,才可以创建代理类)     * @return：返回一个代理类对象     *&#x2F;    public static Object getProxyInstance(Object obj)&#123;        MyInvocationHandler handler &#x3D; new MyInvocationHandler();        &#x2F;&#x2F; 被代理对象赋值        handler.bind(obj);        &#x2F;**         * 根据被代理类对象动态的创建代理类         * 参数1：被代理类由什么类加载器加载         * 参数2：被代理类实现了什么接口(代理类和被代理类必须实现相同的接口)         * 参数3：动态调用方法实现         *&#x2F;        return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(),handler);    &#125;&#125;public class MyInvocationHandler implements InvocationHandler &#123;    &#x2F;&#x2F; 被代理类    private Object obj;    public void bind(Object obj)&#123;        this.obj &#x3D; obj;    &#125;    &#x2F;&#x2F; 当我们通过代理类的对象，调用该方法时，就会自动调用如下的invoke方法    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        &#x2F;**         * 方法调用         * method：被代理对象方法         * obj:被代理对象         * args：被代理方法入参         *&#x2F;        Object returnValue &#x3D; method.invoke(obj,args);        return returnValue;    &#125;&#125;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; 测试  &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;** * @ClassName ProxyTest * @description: 测试 *&#x2F;public class ProxyTest &#123;    public static void main(String[] args) &#123;        SuperMan superMan &#x3D; new SuperMan();        &#x2F;&#x2F; 代理类对象        Human human &#x3D; (Human) ProxyFactory.getProxyInstance(superMan);        &#x2F;&#x2F; 自动调用被代理类当中同名的方法---invoke        human.getBelief();        human.eat(&quot;apple&quot;);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记(三)-Docker-componse使用</title>
      <link href="/2022/10/04/docker-xue-xi-bi-ji-san/"/>
      <url>/2022/10/04/docker-xue-xi-bi-ji-san/</url>
      
        <content type="html"><![CDATA[<h2 id="一-安装配置">一. 安装配置</h2><h3 id="1-1安装配置》CentOS7">1.1安装配置》CentOS7</h3><p>清除旧版本</p><pre class="language-none"><code class="language-none">$ sudo yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine</code></pre><pre class="language-none"><code class="language-none">######设置仓库$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2$$ sudo yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo$######设置yum源是国内的$ yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo######安装docker$ sudo yum install docker-ce docker-ce-cli containerd.io######检查版本$ docker version$ sudo systemctl start docker$$ sudo docker run hello-world# 开机启动$ systemctl enable docker</code></pre><ul><li>修改镜像（指修改国外源的意思，而不是 Docker 里的镜像 ）</li></ul><pre class="language-none"><code class="language-none">$ vi &#x2F;etc&#x2F;docker&#x2F;daemon.json</code></pre><pre class="language-none"><code class="language-none">&#123;    &quot;registry-mirrors&quot;: [        &quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;    ],    &quot;insecure-registries&quot;:[        &quot;http:&#x2F;&#x2F;docker私服地址&quot;    ]&#125;</code></pre><pre class="language-none"><code class="language-none">$ sudo systemctl restart docker#验证是否修改成功$ sudo docker info## ......Registry Mirrors: https:&#x2F;&#x2F;registry.docker-cn.com&#x2F;## ......</code></pre><h3 id="1-2-删除》CentOS7">1.2 删除》CentOS7</h3><pre class="language-none"><code class="language-none">yum -y remove containerd.io.x86_64;yum -y remove docker-ce.x86_64;yum -y remove docker-ce-cli.x86_64;rm -rf &#x2F;usr&#x2F;bin&#x2F;docker&#x2F;;rm -rf &#x2F;etc&#x2F;docker&#x2F;;rm -rf &#x2F;var&#x2F;lib&#x2F;docker&#x2F;;</code></pre><h2 id="二-常用命令">二. 常用命令</h2><h3 id="2-1-命令》镜像相关">2.1 命令》镜像相关</h3><pre class="language-none"><code class="language-none"># 查看镜像$ docker images# 查看镜像详细信息$ docker inspect showdoc# 删除镜像$ docker rmi showdoc</code></pre><h3 id="2-2-命令》容器相关">2.2 命令》容器相关</h3><pre class="language-none"><code class="language-none"># 创建容器$ docker create nginx:1.12# 创建容器并命名$ docker create --name nginx nginx:1.12# 启动容器$ docker start nginx# 运行容器（创建+启动），-d作用为后台运行$ docker run --name nginx -d nginx:1.12# 查看运行中的容器$ docker ps# 查看所有容器$ docker ps -a# 停止容器$ docker stop nginx# 删除容器$ docker rm nginx# 进入容器执行命令，其中 -i ( --interactive ) 表示保持我们的输入流，只有使用它才能保证控制台程序能够正确识别我们的命令。而 -t ( --tty ) 表示启用一个伪终端，形成我们与 bash 的交互，如果没有它，我们无法看到 bash 内部的执行结果。$ docker exec -it nginx bash$ exit &#x2F;&#x2F;退出# 衔接到容器（容器中的主程序转为“前台”运行），我们可以通过 Ctrl + C 来向程序发送停止信号，让程序停止 ( 从而容器也会随之停止 )，用处不大$ docker attach nginx# 从容器向宿主机拷贝文件$ sudo docker cp 3a55922b214b:&#x2F;etc&#x2F;mysql&#x2F;mysql.cnf &#x2F;home&#x2F;elink&#x2F;# 查看容器日志$ docker logs -f -t --tail 100 nginx:1.12$ docker logs --tail 100 tml-hes$ docker logs epark-samba# 查询内存及CPU占用率$ docker stats</code></pre><h3 id="2-3-命令》docker-compose">2.3 命令》docker-compose</h3><pre class="language-none"><code class="language-none"># 启动项目 -d：后台运行$ sudo docker-compose up -d# 删除项目$ sudo docker-compose down</code></pre><h2 id="三-nexus私服">三. nexus私服</h2><h3 id="3-1-nexus私服》配置nexus">3.1 nexus私服》配置nexus</h3><ol><li>登录nexus，默认账户密码：admin admin123</li><li>界面上部齿轮形状的图标 》》 左侧Repositories 》》 Create repository 》》 docker(hosted)</li></ol><ul><li>hosted: 本地存储，即同 docker 官方仓库一样提供本地私服功能</li><li>proxy: 提供代理其他仓库的类型，如 docker 中央仓库</li><li>group: 组类型，实质作用是组合多个仓库为一个地址</li></ul><ol start="3"><li>填写私服名称 》》 勾选Create an HTTP connect…，配置端口号：5000 》》 勾选Enable Docker V1 Api 》》 Create Repository</li></ol><h3 id="3-2-nexus私服》配置docker">3.2 nexus私服》配置docker</h3><pre class="language-none"><code class="language-none">$ vi &#x2F;etc&#x2F;docker&#x2F;daemon.json# 填入&#123; &quot;insecure-registries&quot;:[&quot;http:&#x2F;&#x2F;docker私服地址&quot;] &#125;$ sudo systemctl restart docker# 验证是否修改成功$ sudo docker info$ sudo docker login -u admin -p admin123 docker私服地址# 推送镜像$ sudo docker tag mysql docker私服地址&#x2F;mysql$ sudo docker push docker私服地址&#x2F;mysql:5.7# 拉取镜像$ sudo docker pull docker私服地址&#x2F;nginx:1.16.0# 搜索镜像$ sudo docker search docker私服地址&#x2F;nginx</code></pre><h2 id="四-docker-compose">四. docker-compose</h2><h3 id="4-1-docker-compose》安装">4.1 docker-compose》安装</h3><pre class="language-none"><code class="language-none"> sudo curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.29.2&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-composesudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-composesudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose &#x2F;usr&#x2F;bin&#x2F;docker-composesudo docker-compose version</code></pre><p>docker-compose.yml应该和自己的应用在同一个目录下</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20211123114514127.png" alt="image-20211123114514127"></p><h3 id="4-2-docker-compose》文件介绍">4.2 docker-compose》文件介绍</h3><pre class="language-java" data-language="java"><code class="language-java">version: &quot;3.7&quot;   # docker-compose的版本号# 配置网络,网络之间是相互隔离的networks:  water-gas-pre:    name: water-gas-pre    driver: bridge# 配置服务services:  # 配置pg数据库,如果没有会自动创建  postgres:    image: postgres:10    container_name: water-gas-postgres10-pre  # 容器名,自己起    restart: always # 开机自启    ports:      - 5433:5432   # 宿主机端口:容器端口，注意如果同一个容器当中调用容器端口即可，多个项目注意宿主机端口不能一样    volumes:       # 数据卷：宿主机上的data目录(&#x2F;home&#x2F;techen&#x2F;water-gas-pre&#x2F;postgresql&#x2F;data),映射到容器内部的data(&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data)目录      - &#x2F;home&#x2F;techen&#x2F;water-gas-pre&#x2F;postgresql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data    environment:      - POSTGRES_PASSWORD&#x3D;QAZqaz01      - TZ&#x3D;Asia&#x2F;Shanghai    networks:      water-gas-pre:        aliases:          - water-gas-postgres10-pre  mongo:    image: mongo:4.4.6    container_name: water-gas-mongo-pre    restart: always    ports:      - 27019:27017    volumes:      - &#x2F;home&#x2F;techen&#x2F;water-gas-pre&#x2F;mongodb&#x2F;data:&#x2F;data&#x2F;db      - &#x2F;home&#x2F;techen&#x2F;water-gas-pre&#x2F;mongodb&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mongodb    environment:      - MONGO_INITDB_ROOT_USERNAME&#x3D;root      - MONGO_INITDB_ROOT_PASSWORD&#x3D;QAZqaz01      - TZ&#x3D;Asia&#x2F;Shanghai    command: [&quot;--logpath&quot;, &quot;&#x2F;var&#x2F;log&#x2F;mongodb&#x2F;mongodb.log&quot;]      networks:      water-gas-pre:        aliases:          - water-gas-mongo-pre  redis:    image: redis:5.0.10    container_name: water-gas-redis5-pre    restart: always    ports:      - 6380:6379    volumes:      - &#x2F;home&#x2F;techen&#x2F;water-gas-pre&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf      - &#x2F;home&#x2F;techen&#x2F;water-gas-pre&#x2F;redis&#x2F;data:&#x2F;data    environment:      - TZ&#x3D;Asia&#x2F;Shanghai    command: [&quot;redis-server&quot;, &quot;&#x2F;etc&#x2F;redis&#x2F;redis.conf&quot;]    networks:      water-gas-pre:        aliases:          - water-gas-redis5-pre  rabbitmq:    image: rabbitmq:3.8.3-management    container_name: water-gas-rabbitmq-pre    restart: always    ports:      - 15675:15672      - 5675:5672    environment:      RABBITMQ_DEFAULT_USER: admin      RABBITMQ_DEFAULT_PASS: QAZqaz01      RABBITMQ_LOGS:    volumes:      - &#x2F;home&#x2F;techen&#x2F;water-gas-pre&#x2F;rabbitmq&#x2F;data:&#x2F;var&#x2F;lib&#x2F;rabbitmq      # 启动前宿主机赋予&#x2F;home&#x2F;techen&#x2F;water-gas&#x2F;rabbitmq&#x2F;logs访问权限      - &#x2F;home&#x2F;techen&#x2F;water-gas-pre&#x2F;rabbitmq&#x2F;logs:&#x2F;var&#x2F;log&#x2F;rabbitmq    networks:      water-gas-pre:        aliases:          - water-gas-rabbitmq-pre  ami-water-gas:    image: java-app    container_name: ami-water-gas-pre    restart: always    ports:      - 8013:8012    depends_on:      - postgres      - redis    volumes:      - &#x2F;home&#x2F;techen&#x2F;water-gas-pre&#x2F;ami-water-gas&#x2F;ami-water-gas.jar:&#x2F;home&#x2F;project&#x2F;ami-water-gas.jar:ro      - &#x2F;home&#x2F;techen&#x2F;water-gas-pre&#x2F;ami-water-gas&#x2F;logs:&#x2F;root&#x2F;logs&#x2F;ami-water-gas    entrypoint: &quot;java -jar &#x2F;home&#x2F;project&#x2F;ami-water-gas.jar FC11DAEDFB52BB1A336674CB61850974 --spring.profiles.active&#x3D;pre&quot;    environment:      - FILE_NAME&#x3D;ami-water-gas      - EXPOSE_PORT&#x3D;8012      - ACTIVE_ENV&#x3D;pre    networks:      water-gas-pre:        aliases:          - ami-water-gas-pre  tml-hes:    image: java-app    container_name: tml-hes-pre  # 容器名称    restart: always    ports:      - 9098:9099    depends_on:      - redis    volumes:    # 宿主机的tml-hes.jar挂载到容器上去，使容器当中也有tml-hes.jar包      - &#x2F;home&#x2F;techen&#x2F;water-gas-pre&#x2F;tml-hes&#x2F;tml-hes.jar:&#x2F;home&#x2F;project&#x2F;tml-hes.jar:ro      # 实现宿主机和容器之间的目录共享,使容器当中的日志目录映射到宿主机上面(注意输出日志文件路径是&#x2F;root&#x2F;logs&#x2F;tml-hes)      - &#x2F;home&#x2F;techen&#x2F;water-gas-pre&#x2F;tml-hes&#x2F;logs:&#x2F;root&#x2F;logs&#x2F;tml-hes    entrypoint: &quot;java -jar &#x2F;home&#x2F;project&#x2F;tml-hes.jar --spring.profiles.active&#x3D;pre&quot;    environment:      - FILE_NAME&#x3D;tml-hes      - EXPOSE_PORT&#x3D;9099      - ACTIVE_ENV&#x3D;pre    networks:      water-gas-pre:        aliases:          - tml-hes-pre  nb-hes:    image: java-app    container_name: nb-hes-pre    restart: always    ports:      - 9092:9091    volumes:      - &#x2F;home&#x2F;techen&#x2F;water-gas-pre&#x2F;nb-hes&#x2F;nb-hes.jar:&#x2F;home&#x2F;project&#x2F;nb-hes.jar:ro      - &#x2F;home&#x2F;techen&#x2F;water-gas-pre&#x2F;nb-hes&#x2F;logs:&#x2F;root&#x2F;logs&#x2F;nb-hes    entrypoint: &quot;java -jar &#x2F;home&#x2F;project&#x2F;nb-hes.jar --spring.profiles.active&#x3D;pre&quot;    environment:      - FILE_NAME&#x3D;nb-hes      - EXPOSE_PORT&#x3D;9091      - ACTIVE_ENV&#x3D;pre    networks:      water-gas-pre:        aliases:          - nb-hes-pre</code></pre><p>4.3 基本概念</p><pre class="language-java" data-language="java"><code class="language-java">1、数据卷数据卷的主要作用是数据共享，最常见的用法是将宿主机的某个目录或者文件挂载到容器当中,从而实现宿主机和容器之间的数据共享    2、ACTIVE_ENV激活环境是哪个</code></pre><h4 id="docker-compose》启动顺序解决方案wait-for-sh">docker-compose》<a href="http://xn--wait-for-iz6m52f46fx44biqt9fi6s5kn11b.sh">启动顺序解决方案wait-for.sh</a></h4><ul><li>服务启动先后顺序支持脚本</li><li>git地址：<a href="https://github.com/Eficode/wait-for">https://github.com/Eficode/wait-for</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记(二)</title>
      <link href="/2022/10/04/docker-xue-xi-bi-ji-er/"/>
      <url>/2022/10/04/docker-xue-xi-bi-ji-er/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言">一、前言</h2><p>为了实现环境隔离，想到的办法：虚拟化硬件、操作系统软件、Linux容器</p><p>容器的实现原理：</p><pre class="language-java" data-language="java"><code class="language-java">namespace：**限制容器的查看与访问范畴**，Docker会创建多个命名空间供特定容器使用。Docker会创建多个命名空间供特定容器使用(NET、PID、、、)。-----控制容器内部访问外界控制组：一组进程的资源使用量（包括CPU、内存、磁盘I&#x2F;O以及网络等）进行隔离、排序与计数。这意味着cgroup能够确保Docker容器只使用其必需的资源——并在必要情况下设置其所能使用的资源上限。另外，cgroups还能够确保单一容器不至于占用太多资源并导致整体系统陷入瘫痪。-------------控制进程资源使用</code></pre><h2 id="二、Linux容器">二、Linux容器</h2><p>之前使用的是虚拟机，但是由于虚拟机具有启动慢、占用资源多等问题，Linux开发了另一套影响至今的虚拟化技术----LInux容器技术，</p><p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离，可以看成是在正常的进程之外套了一层保护套，对于容器里面的进程来说，他接触到的资源都是虚拟的，从而实现和底层系统的隔离。</p><p>由于容器是进程级别的，相比虚拟机有很多优势；启动快、体积少、耗费资源少</p><h2 id="三、Docker">三、Docker</h2><p>Docker是一个开源的应用容器引擎，是Linux容器的一种封装，并提供了简单易用了容器接口</p><p>Docker将应用程序与程序的依赖打包到一个文件当中，运行这个文件就会生成一个虚拟容器，程序在虚拟容器当中运行就好像在真实的物理机上运行一样，解决了环境问题。</p><h3 id="3-1-docker安装">3.1 docker安装</h3><p>安装完成后，运行下面的命令，验证是否安装成功。</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ docker version# 或者$ docker info</code></pre><h3 id="3-2-docker-启动">3.2 docker 启动</h3><p>Docker 是服务器----客户端架构。命令行运行<code>docker</code>命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（<a href="https://docs.docker.com/config/daemon/systemd/">官方文档</a>）。</p><blockquote><pre class="language-bash" data-language="bash"><code class="language-bash"># service 命令的用法$ sudo service docker start# systemctl 命令的用法$ sudo systemctl start docker</code></pre></blockquote><h3 id="3-3-docker容器">3.3 docker容器</h3><pre class="language-java" data-language="java"><code class="language-java">#查看所有容器docker ps #查看已运行的容器docker ps -a#获得容器信息docker container ls -a  #停止容器   docker container stop &lt;container ID&gt;#删除容器docker container rm  &lt;container ID&gt;    # 容器运行日志docker logs --tail 100 tml-hesdocker logs --since 2021-11-09T08:30:00 --until 2021-11-10T20:05:00 tml-hes</code></pre><h3 id="3-4-docker-镜像">3.4 docker 镜像</h3><p>Docker把应用程序及其依赖打包到一个image文件当中，只有通过这个文件才可以生成Docker容器。同一个Image文件可以生成多个容器，image文件是一个二进制文件，一台机器上的image文件在另一台机器上也可以使用。</p><pre class="language-java" data-language="java"><code class="language-java">#列出本机所有的镜像docker imagesdocker image ls#删除镜像docker image rm ImagesID          、docker rmi -f f78$ 从仓库抓取镜像docker image pull hello-world# 注意，docker container run命令具有自动抓取 image 文件的功能，如果本地不存在,则抓取，并创建容器运行docker container run hello-world    $ 查看镜像详情docker inspect redis:3.2</code></pre><p>有些容器在运行完毕后，容器自动终止；有些则不会，对于那些不会自动终止的容器，必须使用<a href="https://docs.docker.com/engine/reference/commandline/container_kill/"><code>docker container kill</code></a> 命令手动终止。</p><blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">$ docker container kill [containID]</code></pre></blockquote><h3 id="3-5-dockerFile文件">3.5 dockerFile文件</h3><p>dockerfile文件时一个文本文件，用来配置image文件；docker根据该文件生成image文件</p><h4 id="3-5-1-编写dockerfile文件">3.5.1 编写dockerfile文件</h4><p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/.dockerignore">内容</a>。</p><blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">.gitnode_modulesnpm-debug.log</code></pre></blockquote><p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p><p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/Dockerfile">内容</a>。</p><blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">FROM node:8.4COPY . &#x2F;appWORKDIR &#x2F;appRUN npm install --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.orgEXPOSE 3000</code></pre></blockquote><p>上面代码一共五行，含义如下。</p><blockquote><ul><li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li><li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li><li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li><li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li><li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li></ul></blockquote><h4 id="3-5-2-创建image文件">3.5.2 创建image文件</h4><p>有了DockerFile文件，则可以通过命令直接生成image文件</p><pre class="language-java" data-language="java"><code class="language-java">$ docker image build -t koa-demo .# 或者$ docker image build -t koa-demo:0.0.1 .</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20221004164808428.png" alt="image-20221004164808428"></p><h4 id="3-5-3-生成容器">3.5.3 生成容器</h4><p><code>docker container run</code>命令会从 image 文件生成容器。</p><blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">$ docker container run -p 8000:3000 -it koa-demo &#x2F;bin&#x2F;bash# 或者$ docker container run -p 8000:3000 -it koa-demo:0.0.1 &#x2F;bin&#x2F;bash# 查出容器的 ID$ docker container ls --all# 删除指定的容器文件$ docker container rm [containerID]</code></pre></blockquote><p>上面命令的各个参数含义如下：</p><blockquote><ul><li><code>-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li><li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul></blockquote><p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p><h4 id="3-5-3-4-发布-image-文件">3.5.3.4 发布 image 文件</h4><p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p><p>首先，去 <a href="https://hub.docker.com/">hub.docker.com</a> 或 <a href="https://cloud.docker.com/">cloud.docker.com</a> 注册一个账户。然后，用下面的命令登录。</p><blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">$ docker login</code></pre></blockquote><p>接着，为本地的 image 标注用户名和版本。</p><blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">$ docker image tag [imageName] [username]&#x2F;[repository]:[tag]# 实例$ docker image tag koa-demos:0.0.1 ruanyf&#x2F;koa-demos:0.0.1</code></pre></blockquote><p>也可以不标注用户名，重新构建一下 image 文件。</p><blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">$ docker image build -t [username]&#x2F;[repository]:[tag] .</code></pre></blockquote><p>最后，发布 image 文件。</p><blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">$ docker image push [username]&#x2F;[repository]:[tag]</code></pre></blockquote><p>发布成功以后，登录 <a href="http://hub.docker.com">hub.docker.com</a>，就可以看到已经发布的 image 文件。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学Spring</title>
      <link href="/2022/09/12/chong-xue-spring/"/>
      <url>/2022/09/12/chong-xue-spring/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Spring介绍">一、Spring介绍</h2><p>​<strong>Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架</strong>，由<a href="http://baike.baidu.com/view/2192255.htm">Rod Johnson</a> 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 <a href="http://baike.baidu.com/view/1507.htm">J2EE</a> 应用程序开发提供集成的框架。Spring使用基本的<a href="http://baike.baidu.com/view/28155.htm">JavaBean</a>来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于<a href="http://baike.baidu.com/view/899.htm">服务器</a>端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。</p><p>​**Spring的核心是<a href="http://baike.baidu.com/view/1486379.htm">控制反转</a>（<a href="http://baike.baidu.com/view/146665.htm">IoC</a>）和面向切面（<a href="http://baike.baidu.com/view/73626.htm">AOP</a>）。**简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) <a href="http://baike.baidu.com/subview/1318763/16205192.htm">轻量级</a>开源框架。</p><h3 id="1-1-控制反转（IOC-DI）">1.1 控制反转（IOC/DI）</h3><p>控制反转（Inversion of Control），就是应用本身不负责对象的创建和维护，<strong>对象和依赖对象创建完全交给Spring的容器去管理和维护，这个权利反转给容器</strong>。</p><p>项目中分层开发，学Spring之前bean都是我们自己创建；我们自己创建DaoImpl();带来了很大的耦合性，项目不好维护，测试成本也高</p><p><strong>依赖注入(DI)</strong> ：<strong>IOC的别名</strong> ,</p><p>控制被反转之后，<strong>获得依赖对象的过程由自身管理变为了由IOC容器主动注入</strong>。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现IOC的方法：注入。<strong>所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</strong></p><h3 id="1-2-面向切面编程（AOP）">1.2  面向切面编程（AOP）</h3><p>那么AOP也是一种编程思想,作用是在不改变原始设计的基础上为其进行功能增强。</p><h3 id="1-3-Spring的其他功能">1.3 Spring的其他功能</h3><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220911172328464.png" alt="image-20220911172328464" style="zoom:50%;" /><blockquote><p><strong>Core Container（核心容器）:</strong></p><ul><li>Beans：负责Bean工厂中Bean的装配，所谓Bean工厂即是创建对象的工厂，Bean的装配也就是对象的创建工作；</li><li>Core：这个模块即是负责IOC（控制反转）最基本的实现；</li><li>Context：Spring的IOC容器，因大量调用Spring Core中的函数，整合了Spring的大部分功能。Bean创建好对象后，由Context负责建立Bean与Bean之间的关系并维护。所以也可以把Context看成是Bean关系的集合；</li><li>SpEl：即Spring Expression Language（Spring表达式语言）；</li></ul><p><strong>Data Access/Integration（数据访问/集成）:</strong></p><ul><li>JDBC：对JDBC的简单封装；</li><li>ORM：支持数据集成框架的封装（如Mybatis，Hibernate）；</li><li>OXM：即Object XML Mapper，它的作用是在Java对象和XML文档之间来回转换；</li><li>JMS：生产者和消费者的消息功能的实现；</li><li>Transations：事务管理，不多BB；</li></ul><p><strong>Web：</strong></p><ul><li>WebSocket：提供Socket通信，web端的的推送功能；</li><li>Servlet：Spring MVC框架的实现；</li><li>Web：包含web应用开发用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类，Struts集成类、文件上传的支持类、Filter类和大量辅助工具类；</li><li>Portlet：实现web模块功能的聚合（如网站首页（Port）下面可能会有不同的子窗口（Portlet））；</li></ul><p><strong>AOP：</strong></p><ul><li>面向切面；</li></ul><p><strong>Aspects：</strong></p><ul><li>同样是面向切面的一个重要的组成部分，提供对AspectJ框架的整合；</li></ul><p><strong>Instrumentation（设备）：</strong></p><ul><li>相当于一个检测器，提供对JVM以及对Tomcat的检测；</li></ul><p><strong>Messaging（消息）：</strong></p><ul><li>Spring提供的对消息处理的功能；</li></ul><p><strong>Test（测试）：</strong></p><ul><li>我们在做单元测试时，Spring会帮我们初始化一些测试过程当中需要用到的资源对象</li></ul></blockquote><h2 id="二、环境搭建">二、环境搭建</h2><pre class="language-java" data-language="java"><code class="language-java">1、jar包引入2、创建spring的配置文件，默认名称叫ApplicationContext.xml  &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-3.2.xsd&quot;&gt;    &lt;&#x2F;beans&gt;     3、创建bean  public class UserDaoImpl implements UserDao &#123;    @Override    public void save() &#123;      System.out.println(&quot;user被保存了&quot;);    &#125;&#125;4、Spring配置  &lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.test.spring.dao.impl.UserDaoImpl&quot;&gt;  &lt;&#x2F;bean&gt;    5、创建Spring的容器  @Testpublic void test() &#123;&#x2F;&#x2F;初始化spring容器ApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(&quot;ApplicationContext.xml&quot;);&#x2F;&#x2F;获得beanUserDao userDao &#x3D; (UserDao) ctx.getBean(&quot;userDao&quot;);userDao.save();&#125;</code></pre><h2 id="三、Bean的创建方式">三、Bean的创建方式</h2><h3 id="3-1-使用构造器创建">3.1 使用构造器创建</h3><pre class="language-java" data-language="java"><code class="language-java">1、使用构造器方式创建bean，要求bean必须要有默认的构造器，这是工作中最常用的方式。    public class User &#123;      public User() &#123;      &#125;    &#125;2、配置bean  &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.test.spring.model.User&quot;&gt;&lt;&#x2F;bean&gt;</code></pre><h3 id="3-2-静态工厂方式创建">3.2 静态工厂方式创建</h3><pre class="language-java" data-language="java"><code class="language-java">1、提供静态工厂  public class FactoryBean &#123;    &#x2F;**     * 必须是静态方法     * @return     *&#x2F;    public static User createUser()&#123;      return new User();    &#125;  &#125;2、配置bean  &lt;!-- id：唯一标识class：静态工厂的类，factory-method:静态工厂的方法--&gt;&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.test.spring.factory.FactoryBean&quot; factory-method&#x3D;&quot;createUser&quot;&gt;&lt;&#x2F;bean&gt;</code></pre><h3 id="3-3-实例工厂方式创建">3.3 实例工厂方式创建</h3><pre class="language-java" data-language="java"><code class="language-java">1、实例工厂  public class FactoryBean1 &#123;    public User createUser()&#123;      return new User();    &#125;  &#125;2、配置bean  &lt;!-- 通过Spring来定义实例工厂 --&gt;&lt;bean id&#x3D;&quot;factoryBean&quot; class&#x3D;&quot;com.rl.spring.factory.FactoryBean1&quot;&gt;&lt;&#x2F;bean&gt;&lt;!-- 指定要创建的beanfactory-bean：指定实例工厂类，factory-method：工厂的创建bean的方法--&gt;&lt;bean id&#x3D;&quot;user&quot; factory-bean&#x3D;&quot;factoryBean&quot; factory-method&#x3D;&quot;createUser&quot;&gt;&lt;&#x2F;bean&gt;</code></pre><h2 id="四、延迟加载">四、延迟加载</h2><p>所有的bean默认情况下，非延迟加载的，是spring的容器创建的时候就把bean给创建出来了，我们getBean的时候直接从容器中去拿这个Bean就可以了。</p><p>是否延迟加载由lazy-init来控制，默认是false，如果变成true就在getBean的时候去创建user。</p><pre class="language-java" data-language="java"><code class="language-java">&lt;bean id&#x3D;&quot;lazyInitBean&quot; class&#x3D;&quot;com.javacode2018.lesson001.demo11.LazyInitBean&quot; lazy-init&#x3D;&quot;true&quot;&#x2F;&gt;</code></pre><h2 id="五、Bean的作用域">五、Bean的作用域</h2><p>默认情况下，bean都是单例的，是容器初始化的时候被创建的，就这么一份</p><p>Scope：singleton单例，prototype多例，默认使用singleton</p><p>如果是singleton我们可以设置非延迟加载（容器初始化时创建bean）和延迟加载（getBean的时候才创建）方式创建bean</p><p>如果是prototype我们没得选择只能是延迟加载方式创建（getBean的时候才创建）</p><h2 id="六、Bean的生命周期">六、Bean的生命周期</h2><p>Bean的生命周期和容器的生命周期一致，容器被创建bean就被创建，容器销毁bean就被销毁；创建是和销毁时，会调用指定的方法</p><pre class="language-java" data-language="java"><code class="language-java">1、方法  public class User &#123;    public User() &#123;    &#125;    public void init()&#123;  System.out.println(&quot;我出来了&quot;);  &#125;  public void destroy()&#123;  System.out.println(&quot;20年后又是一条好汉&quot;);  &#125;&#125;2、Bean配置  &lt;!-- init-method:bean被创建时调用，destroy-method:bean被销毁时调用 --&gt;&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.test.spring.model.User&quot; init-method&#x3D;&quot;init&quot; destroy-method&#x3D;&quot;destroy&quot;&gt;&lt;&#x2F;bean&gt;</code></pre><h2 id="七、依赖注入">七、依赖注入</h2><h3 id="7-1-属性注入-set注入">7.1 属性注入(set注入)</h3><h4 id="7-1-1-常量注入">7.1.1  常量注入</h4><pre class="language-java" data-language="java"><code class="language-java">&lt;!--  bean的常量注入--&gt;&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.test.spring.model.User&quot;&gt;    &lt;!-- property:class里面的属性,name：属性名--&gt;  &lt;property name&#x3D;&quot;userId&quot; value&#x3D;&quot;1&quot;&gt;&lt;&#x2F;property&gt;  &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;renliang&quot;&gt;&lt;&#x2F;property&gt;  &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;123&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;</code></pre><h4 id="7-1-2-集合注入">7.1.2 集合注入</h4><pre class="language-java" data-language="java"><code class="language-java">1、对象  @Data  public class CollectionInjection &#123;    private Set&lt;String&gt; set;    private List&lt;String&gt; list;    private Map&lt;String, String&gt; map;    private Properties prop;  &#125;2、注入  &lt;bean id&#x3D;&quot;ci&quot; class&#x3D;&quot;com.rl.spring.model.CollectionInjection&quot;&gt;&lt;property name&#x3D;&quot;set&quot;&gt;&lt;set&gt;&lt;value&gt;football&lt;&#x2F;value&gt;&lt;value&gt;basketball&lt;&#x2F;value&gt;&lt;&#x2F;set&gt;&lt;&#x2F;property&gt;&lt;property name&#x3D;&quot;list&quot;&gt;&lt;list&gt;&lt;value&gt;male&lt;&#x2F;value&gt;&lt;value&gt;female&lt;&#x2F;value&gt;&lt;&#x2F;list&gt;&lt;&#x2F;property&gt;&lt;property name&#x3D;&quot;map&quot;&gt;&lt;map&gt;&lt;entry key&#x3D;&quot;key1&quot; value&#x3D;&quot;value1&quot;&gt;&lt;&#x2F;entry&gt;&lt;entry key&#x3D;&quot;key2&quot; value&#x3D;&quot;value2&quot;&gt;&lt;&#x2F;entry&gt;&lt;&#x2F;map&gt;&lt;&#x2F;property&gt;&lt;property name&#x3D;&quot;prop&quot;&gt;&lt;props&gt;&lt;prop key&#x3D;&quot;name&quot;&gt;任亮&lt;&#x2F;prop&gt;&lt;prop key&#x3D;&quot;job&quot;&gt;讲师&lt;&#x2F;prop&gt;&lt;&#x2F;props&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;  </code></pre><h4 id="7-1-3-外部bean注入-对象">7.1.3 外部bean注入(对象)</h4><pre class="language-java" data-language="java"><code class="language-java">1、外部Bean注入：必须提供set方法    public class UserServiceImpl implements UserService &#123;      private UserDao userDao;      &#x2F;**       * 外部bean的方式注入，必须提供要注入的bean的set方法       * @param userDao       *&#x2F;      public void setUserDao(UserDao userDao) &#123;        this.userDao &#x3D; userDao;      &#125;      @Override      public void save() &#123;        userDao.save();      &#125;    &#125;2、配置    &lt;!-- 定义UserDao的bean --&gt;    &lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.test.spring.dao.impl.UserDaoImpl&quot;&gt;&lt;&#x2F;bean&gt;    &lt;!-- 定义Service的bean --&gt;    &lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.test.spring.service.impl.UserServiceImpl&quot;&gt;      &lt;!-- 通过属性方式注入        name:bean的属性名        ref：要注入的bean       --&gt;      &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDao&quot;&gt;&lt;&#x2F;property&gt;    &lt;&#x2F;bean&gt;</code></pre><h4 id="7-1-4-内部bean注入-对象">7.1.4 内部bean注入(对象)</h4><p>内部bean不能其他bean注入</p><pre class="language-java" data-language="java"><code class="language-java">1、外部Bean注入：必须提供set方法    public class UserServiceImpl implements UserService &#123;      private UserDao userDao;      &#x2F;**       * 外部bean的方式注入，必须提供要注入的bean的set方法       * @param userDao       *&#x2F;      public void setUserDao(UserDao userDao) &#123;        this.userDao &#x3D; userDao;      &#125;      @Override      public void save() &#123;        userDao.save();      &#125;    &#125;2、配置    &lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.rl.spring.service.impl.UserServiceImpl&quot;&gt;      &lt;property name&#x3D;&quot;userDao&quot;&gt;        &lt;bean class&#x3D;&quot;com.rl.spring.dao.impl.UserDaoImpl&quot;&gt;&lt;&#x2F;bean&gt;      &lt;&#x2F;property&gt;    &lt;&#x2F;bean&gt;</code></pre><h3 id="7-2-构造器注入">7.2 构造器注入</h3><h4 id="7-2-1-常量注入">7.2.1 常量注入</h4><pre class="language-java" data-language="java"><code class="language-java">&lt;!-- 构造器方式注入 --&gt;&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.test.spring.model.User&quot;&gt;&lt;!--         index:构造方法的参数的索引顺序        type:构造方法的参数的类型（不是必须 的）        value:值 --&gt;&lt;!-- &lt;constructor-arg index&#x3D;&quot;0&quot; type&#x3D;&quot;java.lang.Integer&quot; value&#x3D;&quot;2&quot;&#x2F;&gt;&lt;constructor-arg index&#x3D;&quot;1&quot; type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;renliang&quot;&#x2F;&gt;&lt;constructor-arg index&#x3D;&quot;2&quot; type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;666&quot;&#x2F;&gt; --&gt;&lt;constructor-arg index&#x3D;&quot;0&quot;  value&#x3D;&quot;2&quot;&#x2F;&gt;&lt;constructor-arg index&#x3D;&quot;1&quot;  value&#x3D;&quot;renliang&quot;&#x2F;&gt;&lt;constructor-arg index&#x3D;&quot;2&quot;  value&#x3D;&quot;666&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><h4 id="7-2-2-对象注入">7.2.2 对象注入</h4><pre class="language-java" data-language="java"><code class="language-java">public class UserServiceImpl implements UserService &#123;private UserDao userDao;public UserServiceImpl() &#123;&#125;public UserServiceImpl(UserDao userDao) &#123;super();this.userDao &#x3D; userDao;&#125;@Overridepublic void save() &#123;userDao.save();&#125;&#125;&lt;!-- 定义UserDao的bean --&gt;&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.test.spring.dao.impl.UserDaoImpl&quot;&gt;&lt;&#x2F;bean&gt;&lt;!-- 定义UserService的Bean --&gt;&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.test.spring.service.impl.UserServiceImpl&quot;&gt;&lt;!-- 通过构造器的方式指定注入的bean   type：指定UserDao接口，不要指定实现类   ref：就是要注入的bean --&gt;&lt;constructor-arg index&#x3D;&quot;0&quot; type&#x3D;&quot;com.test.spring.dao.UserDao&quot; ref&#x3D;&quot;userDao&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><h3 id="7-3-注解方式注入">7.3 注解方式注入</h3><p>引入jar包、引入约束文件、开启注解的驱动</p><pre class="language-java" data-language="java"><code class="language-java">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-3.2.xsd           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context-3.2.xsd&quot;&gt;&lt;!-- 开启注解的驱动 --&gt;&lt;context:annotation-config&#x2F;&gt;&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.rl.spring.dao.impl.UserDaoImpl&quot;&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.rl.spring.service.impl.UserServiceImpl&quot;&gt;&lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><h4 id="7-3-1-Resource注解">7.3.1 Resource注解</h4><blockquote><p>1、Resource时java的注解</p><p>2、既可以加在方法上也可以加在属性上</p><p>3、默认按照name进行匹配的，如果不写，默认是变量名，如果找不到会按照Type进行匹配，再找不到就会报错</p><p>4、加在方法上，会先按照(属性名、set后面小写名、入参名)进行匹配，未匹配则会按照type进行匹配；</p><p>5、一旦指定了name，就不会按照type进行匹配</p></blockquote><h4 id="7-3-2-Autowird注解">7.3.2 Autowird注解</h4><blockquote><p>1、Autowird是Spring提供的注解</p><p>2、既可以加在方法上也可以加在属性上</p><p>3、Autowird默认是按照Type进行匹配的，如果接口有多个实现的话，会先根据默认名进行匹配，匹配不上则报错；最好配合Qualifier显示的指定</p></blockquote><h2 id="八、Spring的扫描器">八、Spring的扫描器</h2><p>用来扫描管理Bean的</p><blockquote><p>实际项目如果很大就会出现大量配置，我们使用扫描器可以解决这个问题</p><p>扫描器扫描带有@Controller，@Service,  @Repository，@Component的类</p><p>@Controller：控制层的类</p><p>@Service：服务层的类</p><p>@Repository：数据层的类</p><p>@Component：无法分层的类上</p><p>以上注解标注的类的bean的id默认类名的首字符小写</p></blockquote><h2 id="九、Spring整合Junit">九、Spring整合Junit</h2><pre class="language-java" data-language="java"><code class="language-java">&#x2F;** * @RunWith:指定spring对junit提供的一个运行器 * @ContextConfiguration：指定spring配置文件位置 * @author renliang * *&#x2F;@RunWith(value&#x3D;SpringJUnit4ClassRunner.class)@ContextConfiguration(locations&#x3D;&#123;&quot;classpath:ApplicationContext.xml&quot;&#125;)public class TestSpring1 &#123;&#x2F;** * 在junit的bean中注入UserService      *  即UserService的实现类一定加入了4种注解之一，创建的对象赋值给了UserService *&#x2F;@AutowiredUserService userService;@Testpublic void test2() &#123;userService.save();&#125;&#125;</code></pre><h2 id="十、AOP">十、AOP</h2><h2 id="十一、JdbcTemplate">十一、JdbcTemplate</h2><pre class="language-java" data-language="java"><code class="language-java">1、引入jdbc的包  2、配置数据源  &lt;!-- 数据源配置 --&gt;&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;&lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;&#x2F;property&gt;&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring3.2_10&quot;&gt;&lt;&#x2F;property&gt;&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&gt;&lt;&#x2F;property&gt;&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&gt;&lt;&#x2F;property&gt;&lt;!-- 初始化的连接数 --&gt;&lt;property name&#x3D;&quot;initialSize&quot; value&#x3D;&quot;1&quot;&gt;&lt;&#x2F;property&gt;&lt;!-- 连接池的最大连接数--&gt;&lt;property name&#x3D;&quot;maxActive&quot; value&#x3D;&quot;5&quot;&gt;&lt;&#x2F;property&gt;&lt;!-- 最大的空闲的连接数 --&gt;&lt;property name&#x3D;&quot;maxIdle&quot; value&#x3D;&quot;2&quot;&gt;&lt;&#x2F;property&gt;&lt;!-- 最小的空闲连接数 --&gt;&lt;property name&#x3D;&quot;minIdle&quot; value&#x3D;&quot;1&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;    3、使用    public class UserDaoImpl implements UserDao &#123;      private DataSource dataSource;      private JdbcTemplate jt;      public void setDataSource(DataSource dataSource) &#123;        this.dataSource &#x3D; dataSource;        this.jt &#x3D; new JdbcTemplate(dataSource);      &#125;      @Override      public void saveUser(User user) &#123;        String sql &#x3D; &quot;insert into t_user values(null, ?, ?)&quot;;        jt.update(sql, new Object[]&#123;user.getUsername(), user.getPassword()&#125;);      &#125;      @Override      public void updateUser(User user) &#123;        String sql &#x3D; &quot;update t_user set username &#x3D; ?, password&#x3D;? where user_id &#x3D; ?&quot;;        jt.update(sql, new Object[]&#123;user.getUsername(), user.getPassword(), user.getUserId()&#125;);      &#125;      @Override      public User queryUserById(int userId) &#123;        String sql &#x3D; &quot;select * from t_user t where t.user_id &#x3D; ?&quot;;        User user &#x3D; jt.queryForObject(sql, new Object[]&#123;userId&#125;, new UserRowMapper());        return user;      &#125;      @Override      public List&lt;User&gt; queryUserAll() &#123;        String sql &#x3D; &quot;select * from t_user&quot;;        List&lt;User&gt; userList &#x3D; jt.query(sql, new UserRowMapper());        return userList;      &#125;&#125;  </code></pre><h2 id="十二、事务控制">十二、事务控制</h2><h3 id="12-1-什么是事物？">12.1 什么是事物？</h3><p>一荣俱荣，一损俱损，很多复杂的操作我们可以把它看成是一个整体，要么同时成功，要么同时失败。</p><blockquote><p>事务的四个特征ACID：</p><p>原子性（Atomic）：表示组成一个事务的多个数据库的操作的不可分割的单元，只有所有的操作成功才算成功，整个事务提交，其中任何一个操作失败了都是导致整个所有操作失败，事务会回滚。</p><p>一致性（Consistentcy）：事务操作成功后，数据库所处的状态和业务规则一致。如果A账户给B账户汇100，A账户减去100，B加上100，两个账户的总额是不变的。</p><p>隔离性（islation）：在多个数据库的操作相同的数据并发时，不同的事务有自己的数据空间，事务与事务之间不受干扰（不是绝对的）。干扰程度受数据库或者操作事务的隔离级别来决定，隔离级别越高，干扰就越低，数据的一致性越好，并发性就越差。</p><p>持久性（Druability）：一旦事务提交成功，数据就被持久化到数据库，不可以回滚。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电表DLMS协议升级流程分析</title>
      <link href="/2022/08/21/dian-biao-dlms-xie-yi-sheng-ji-liu-cheng-fen-xi/"/>
      <url>/2022/08/21/dian-biao-dlms-xie-yi-sheng-ji-liu-cheng-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>最近进行电表DLMS的升级，特记录下升级流程</p><p><strong>1、初始化</strong></p><p>------------------------------------------------------- 初始化 --------------------------------------------------</p><p>1、Set ImageBlockSize 设置传输块大小(没帧多少个字节)</p><pre class="language-java" data-language="java"><code class="language-java">c10141001200002c0000ff0200060000017c c501c100 </code></pre><p>2、image_transfer_initiate 清空上次升级的文件(设置文件名和总共需要下发文件的大小)</p><pre class="language-java" data-language="java"><code class="language-java">c30142001200002c0000ff01010202090854413235525657330600033d9c c701c20000</code></pre><p>3、image_transfer_status 查询状态，初始化是否成功Image transfer initiated</p><pre class="language-java" data-language="java"><code class="language-java">c00143001200002c0000ff0600 c40183001601</code></pre><p><strong>2、升级</strong></p><p>------------------------------------------------------- 升级 --------------------------------------------------</p><p>4、image_block_size 传输文件</p><pre class="language-java" data-language="java"><code class="language-java">c3 014200 12 00 00 2c 00 00 ff 010102 02    06 00 00 00 00 &#x2F;&#x2F; 第N块    09 82 01 7c 17da5fa01633cd9abc5b6cbf14aa1e337666ba667e0bacc1c0c7b1a19f325d61292b3a22c0d19a1 86fd601a6818fe47cc3809968328c7b83a09435b24e81bfd7575aba24e4a923b7ef072632eede30a 9a958f005f5f851bc7c373bd29a1944f4c50ae6cc1f226f0c1a726c36d32bb12eea0c37cbd711c88 3c0b60fd21bee18edef8b563d82bc0600f89a02b9a4088bc86f76cf2b83009d508d338dcc8eea37d 4d23fb00ffe4874aa2afcf884e881520c40a4e720a3394e1a25e66aefa88e49d524a217b67a622d6 57b949cf6b173a667c0450ff72b0cefb335045ad84739c1a400aef646bf59b21267b2400f3c1eb3f 9773c8d4819c3fc1db7ba9db332cb295c69972ad5d6de41838ae102a0a40fd87f43e303a413280a1 0c20c14e4c9612994250cecfa2d0d877a332607b156504cf8fd8805d8af083b4767f56c71bc7b36b 72e665d8d075c85857fa3d20edeb60693716a8f0c8f499c1c8e85fd745aebc7df02cff167351768e 44a245d5fe4468e4b1bda6441b8974c6abd356d62</code></pre><p>5、image_transferred_blocks_status 查询升级块状态</p><pre class="language-java" data-language="java"><code class="language-java">c00181001200002c0000ff0300 c40181000482022d000000000000000000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000000000000000000000000000000</code></pre><p>6、image_verify(data) 激活验证完整性</p><pre class="language-java" data-language="java"><code class="language-java">c30181001200002c0000ff03010f00 发00 c701c10000</code></pre><p>------------------------------------------------------- 激活 --------------------------------------------------</p><p>7、验证是否成功 image_transfer_status 校验已成功《可以进行激活了</p><pre class="language-java" data-language="java"><code class="language-java">c00181001200002c0000ff0600 c40181001603</code></pre><p>8、激活 image_activate</p><pre class="language-java" data-language="java"><code class="language-java">c30181001200002c0000ff04010f00 c701c10000</code></pre>]]></content>
      
      
      <categories>
          
          <category> 电表通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DLMS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 清空数据</title>
      <link href="/2022/08/21/redis-qing-kong-shu-ju/"/>
      <url>/2022/08/21/redis-qing-kong-shu-ju/</url>
      
        <content type="html"><![CDATA[<p>由于服务器上Redis端口未对外开放，所以清除缓存需要从服务器上清除；对于Windows服务器可以直接通过客户端图形化界面来进行清空缓存，但是Linux服务器则需要通过指令来清空，具体操作如下：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220821184616335.png" alt="image-20220821184616335"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连接PG数据库报错</title>
      <link href="/2022/08/21/lian-jie-pg-shu-ju-ku-bao-cuo/"/>
      <url>/2022/08/21/lian-jie-pg-shu-ju-ku-bao-cuo/</url>
      
        <content type="html"><![CDATA[<p><strong>连接PG数据库报错</strong></p><blockquote><p>org.postgresql.util.PSQLException: The authentication type 10 is not supported. Check that you have configured the pg_hba.conf file to include the client’s IP address or subnet, and that it is using an authentication scheme supported by the driver.</p></blockquote><p>***方法1:修改pg_hba.conf配置文件当中的ipv4如下 ***</p><pre class="language-java" data-language="java"><code class="language-java"># TYPE  DATABASE        USER            ADDRESS                 METHOD# &quot;local&quot; is for Unix domain socket connections onlylocal   all             all                                     trust# IPv4 local connections:#host   all             all             127.0.0.1&#x2F;32            trusthost    all             all             0.0.0.0&#x2F;0               trust# IP6 local connections:host    all             all             ::1&#x2F;128                 trust# Allow replication connections from localhost, by a user with the# replication privilege.local   replication     all                                     trusthost    replication     all             127.0.0.1&#x2F;32            trusthost    replication     all             ::1&#x2F;128                 trusthost all all all scram-sha-256</code></pre><p>*** 方法2:***</p><pre class="language-none"><code class="language-none">解决方法将pg_hba.conf由&quot;host all all all scram-sha-256&quot;改&quot;host all all all trust&quot;····</code></pre>]]></content>
      
      
      <categories>
          
          <category> PostgreSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装Mysql遇到的问题</title>
      <link href="/2022/08/21/docker-an-zhuang-mysql-yu-dao-de-wen-ti/"/>
      <url>/2022/08/21/docker-an-zhuang-mysql-yu-dao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>Docker安装Mysql遇到的问题</p><h3 id="1、查看mysql的日志，发现如下提示，步奏如下">1、查看mysql的日志，发现如下提示，步奏如下</h3><pre class="language-java" data-language="java"><code class="language-java">mysqld: [Warning] World-writable config file &#39;&#x2F;etc&#x2F;mysql&#x2F;my.cnf&#39; is ignored.  mysqld: Error on realpath() on &#39;&#x2F;var&#x2F;lib&#x2F;mysql-files&#39; (Error 2 - No such file or directory)2022-06-24T07:26:45.507436Z 0 [ERROR] [MY-010095] [Server] Failed to access directory for --secure-file-priv. Please make sure that directory exists and is accessible by MySQL Server. Supplied value : &#x2F;var&#x2F;lib&#x2F;mysql-files</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220624154649340.png" alt="image-20220624154649340"></p><h4 id="1-1-可能是mysql-files">1.1 可能是mysql-files</h4><pre class="language-JAVA" data-language="JAVA"><code class="language-JAVA">#造成这种情况可能是因为mysql-files文件夹不存在或权限错误，# 在宿主机挂载数据目录下touch &#x2F;var&#x2F;lib&#x2F;mysql-filesshell&gt; touch &#x2F;var&#x2F;lib&#x2F;mysql-files</code></pre><h4 id="1-2-linux下：">1.2 linux下：</h4><p>修改my.cnf 在[mysqld]内加入secure_file_priv=/var/lib/mysql</p><h4 id="1-3-赋予权限">1.3 赋予权限</h4><p>先赋予777权限，但是还是报错，遂修改权限未644</p><pre class="language-java" data-language="java"><code class="language-java">权限777，任何一个用户都可以改my.cnf，存在很大的安全隐患.修改my.cnf文件的权限为644 设置为用户可读写，其他用户不可写.chmod 644 &#x2F;etc&#x2F;my.cnf</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 设置服务所占内存</title>
      <link href="/2022/08/12/docker-she-zhi-fu-wu-suo-zhan-nei-cun/"/>
      <url>/2022/08/12/docker-she-zhi-fu-wu-suo-zhan-nei-cun/</url>
      
        <content type="html"><![CDATA[<p>今天在跑定时任务时，发现程序崩溃了，在服务器上查看之后发现是内存满了，其他的服务占用的内存太多，所以想要限制服务所占的内存，做了如下的操作：</p><p>所以在docker-componse当中指定服务所占的内存，这样在访问内存较大时，服务会变慢，以防止占用内存太多导致其他服务无法正常运行；注意这种方式的前提是其他服务很少用到，不会出现内存溢出情况。</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220821190023076.png" alt="image-20220821190023076"></p><p>注意加了deploy之后，启动时需要使用docker-compose --compatibility up指令来启动,否则会warn：use the ‘deploy’ key, which will be ignored. Compose does not support ‘deploy’ configuration - use <code>docker stack deploy</code> to deploy to a swarm.</p><pre class="language-java" data-language="java"><code class="language-java">docker-compose --compatibility up -d</code></pre><p>效果如下：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220812215811472.png" alt="image-20220812215811472"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 常用指令(一)</title>
      <link href="/2022/08/12/linux-chang-yong-zhi-ling-yi/"/>
      <url>/2022/08/12/linux-chang-yong-zhi-ling-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="1、查询内存情况">1、查询内存情况</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ free -h</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220730142019717.png" alt="image-20220730142019717"></p><h3 id="2、查询端口对应的进程">2、查询端口对应的进程</h3><pre class="language-bash" data-language="bash"><code class="language-bash">[root@ecs-1773-3 fes-stress-test]# lsof -i:6379COMMAND    PID USER   FD   TYPE DEVICE SIZE&#x2F;OFF NODE NAMEdocker-pr 2683 root    4u  IPv4  31525      0t0  TCP *:6379 (LISTEN)docker-pr 2691 root    4u  IPv6  33606      0t0  TCP *:6379 (LISTEN)[root@ecs-1773-3 fes-stress-test]# netstat -tunlp|grep 6379tcp        0      0 0.0.0.0:6379            0.0.0.0:*               LISTEN      2683&#x2F;docker-proxy   tcp6       0      0 :::6379                 :::*                    LISTEN      2691&#x2F;docker-proxy   </code></pre><h3 id="3、java项目部署jar指定JVM内存启动">3、java项目部署jar指定JVM内存启动</h3><p>项目启动报错： **java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread **</p><pre class="language-java" data-language="java"><code class="language-java">异常名称 : 内存溢出异常在启动tomcat的时候或者运行过程中抛出以下异常Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread &quot;http-bio-80-exec-31&quot;</code></pre><p><strong>解决办法：</strong></p><p>项目启动时，指定JVM内存</p><pre class="language-java" data-language="java"><code class="language-java">java -jar -Xms128M -Xmx256M -XX:PermSize&#x3D;128M -XX:MaxPermSize&#x3D;256M xxx.jarjava -jar -Xms1024M -Xmx1024M -XX:PermSize&#x3D;256M -XX:MaxNewSize&#x3D;256M -XX:MaxPermSize&#x3D;256M xxx.jar Xms : 堆内存初始大小Xmx : 堆内存最大值PermSize : 永久内存初始大小MaxPermSize ： 永久内存最大值</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程之CountDownLatch</title>
      <link href="/2022/07/30/java-bing-fa-bian-cheng-zhi-countdownlatch/"/>
      <url>/2022/07/30/java-bing-fa-bian-cheng-zhi-countdownlatch/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://blog.csdn.net/qq877728715/article/details/121857013">https://blog.csdn.net/qq877728715/article/details/121857013</a></p><h3 id="1、并发请求介绍">1、并发请求介绍</h3><p>java中模拟并发请求，只要多开几个线程，发起请求就好了。但是，这种请求，一般会存在启动的先后顺序了，算不得真正的同时并发！怎么样才能做到真正的同时并发呢？java中提供了闭锁 CountDownLatch、信号量Semaphore、同步屏障CyclicBarrier, 刚好就用来做这种事就最合适了</p><p>本文主要记录CountDownLatch</p><pre class="language-java" data-language="java"><code class="language-java">1. 开启n个线程，加一个闭锁，开启所有线程；2. 待所有线程都准备好后，按下开启按钮，就可以真正的发起并发请求了。</code></pre><h3 id="2、CountDownLatch执行逻辑">2、CountDownLatch执行逻辑</h3><p>CountDownLatch俗称：(同步计数器/闭锁)，可以使一个线程等待其他线程全部执行完毕后再执行。 类似join()的效果。</p><ul><li>场景：主要用来解决一个线程等待 N 个线程的场景。通常用来汇总各个线程执行后的结果</li><li>CountDownLatch内部通过一个计数器来控制等待线程数，该计数器的操作是原子操作，即同时只能有一个线程去更新该计数器。<ul><li>调用await()方法的线程会一直处于阻塞状态，直到其他线程调用countDown()使当前计数器的值变为 0，每次调用countDown()方法计数器的值减1。</li><li>当计数器值减至0时，所有因调用await()方法而处于等待状态的线程就会被唤醒然后继续往下执行。</li><li>这种现象只会出现一次，因为计数器不能被重置。</li></ul></li></ul><p>并发请求流程示意图：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220730163123424.png" alt="image-20220730163123424"></p><blockquote><p>设置了一道门，以保证所有线程可以同时生效。但是，这里的同时启动，也只是语言层面的东西，也并非绝对的同时并发。具体的调用还要依赖于CPU个数，线程数及操作系统的线程调度功能等，不过咱们也无需纠结于这些了，重点在于理解原理！</p><p>与 CountDownLatch 有类似功能的，还有工具栅栏 CyclicBarrier, 也是提供一个等待所有线程到达某一点后，再一起开始某个动作，效果一致，不过栅栏的目的确实比较纯粹，就是等待所有线程到达，而前面说的闭锁 CountDownLatch 虽然实现的也是所有线程到达后再开始，但是他的触发点其实是 最后那一个开关，所以侧重点是不一样的。</p></blockquote><h3 id="3、实例代码">3、实例代码</h3><p>示例代码：</p><blockquote><p>1、定义了一个开始门，一个结束门，开始门的线程数是1，结束门的线程数是1500，</p><p>2、开始门用来阻塞所有的线程，所有线程创建后，在开始门前阻塞;当countDown()==0时，阻塞线程后续的逻辑开始执行</p><p>3、结束门用来统计所有线程的执行时间；当开始门开始时开始计时，每执行一个线程countDown，当countDown()==0时，结束门的阻塞失效，程序开始向下执行，线程执行完成，统计执行时间</p></blockquote><pre class="language-java" data-language="java"><code class="language-java">package com.codesheep.terminaldemo.config;import com.codesheep.terminaldemo.service.TaskClient;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;&#x2F;** * @ClassName TerminalInfo * @description: * @author: codesheep * @Version 1.0.0 * @createTime: 2022-07-29 13:17:48 *&#x2F;@Componentpublic class TerminalInfo &#123;    private static final Logger logger &#x3D; LoggerFactory.getLogger(TerminalInfo.class);    private static int TERMINAL_COUNT &#x3D; 1500;    private static int COUNT &#x3D; 0;    &#x2F;&#x2F; 定义线程池    ExecutorService executorService &#x3D; Executors.newCachedThreadPool();    &#x2F;&#x2F;开始门    final CountDownLatch startGate &#x3D; new CountDownLatch(1);    &#x2F;&#x2F;结束门    final CountDownLatch endGate &#x3D; new CountDownLatch(TERMINAL_COUNT);        public void process1()&#123;        for (int i &#x3D; 0; i &lt; TERMINAL_COUNT; i++) &#123;            executorService.execute(() -&gt; &#123;                try &#123;                    &#x2F;&#x2F; 使线程在此等待，当开始门打开时，一起涌入门中                    startGate.await();                    try &#123;                        &#x2F;&#x2F; 执行业务逻辑:发起请求                        process2();                    &#125; finally &#123;                        &#x2F;&#x2F; 业务执行完毕:将结束门减1，减到0时，就可以开启结束门了                        endGate.countDown();                    &#125;                &#125; catch (InterruptedException ie) &#123;                    ie.printStackTrace();                &#125;            &#125;);        &#125;        long startTime &#x3D; System.nanoTime();        logger.info(startTime + &quot; [&quot; + Thread.currentThread() + &quot;] 所有线程都准备好了，准备并发运行...&quot;);        &#x2F;&#x2F; startGate为0,立马执行该startGate阻塞的线程(线程向后执行),因开始门只需一个开关，所以立马就开启开始门        startGate.countDown();        &#x2F;&#x2F; 阻塞线程不让向下执行(直到endGate为0,此处是所有线程执行完毕):等结束门开启(endGate为0,所有的任务执行完毕,统计执行时间)        try &#123;            endGate.await();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        &#x2F;&#x2F;返回并发执行耗时（纳秒）        long endTime &#x3D; System.nanoTime();        logger.info(endTime + &quot; [&quot; + Thread.currentThread() + &quot;] 所有的线程执行完成.&quot;+&quot;   耗时:&quot;+(endTime - startTime)+&quot; ns&quot;);    &#125;    private void process2() &#123;        TaskClient newTaskClient &#x3D; new TaskClient(&quot;1&quot;,&quot;119.167.1.112&quot;, 8888);        newTaskClient.connect();        COUNT++;        logger.info(&quot;٩(๑❛❛๑)۶ &#x3D;&#x3D;&#x3D;终端数&#x3D;&#x3D;&#x3D; &quot; + COUNT +&quot; &#x3D;&#x3D;&#x3D; &quot;+ LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> CountDownLatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux程序提示killed的原因</title>
      <link href="/2022/07/30/linux-cheng-xu-ti-shi-killed-de-yuan-yin/"/>
      <url>/2022/07/30/linux-cheng-xu-ti-shi-killed-de-yuan-yin/</url>
      
        <content type="html"><![CDATA[<p>运行程序时，Linux出现Killed,然后程序就被终止了</p><p>当系统资源不足时，Linux 内核也可以决定终止一个或多个进程。 一个非常常见的例子是<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020">内存</a>不足 (OOM) killer，会在系统的物理内存耗尽时触发。</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@ecs-1773-3 fes-stress-test]# sudo dmesg | tail -7[6229228.008634] [98387]     0 98387    18062      182      39        0             0 sftp-server[6229228.012426] [99129]     0 99129    39329      351      79        0             0 sshd[6229228.015908] [99132]     0 99132    18062      204      38        0             0 sftp-server[6229228.019624] [101710]     0 101710  2759959   382547    4202        0             0 java[6229228.023244] [106758]     0 106758      807        1       4        0             0 zabbix_server[6229228.027147] Out of memory: Kill process 101710 (java) score 187 or sacrifice child[6229228.031308] Killed process 101710 (java), UID 0, total-vm:11039836kB, anon-rss:1530188kB, file-rss:0kB, shmem-rss:0kB</code></pre><p>分析：</p><ul><li>Out of memory: Kill process 101710 (java) score 187 or sacrifice child，内存不够<ul><li>total_vm：总共使用的虚拟内存 Virtual memory use (in 4 kB pages)  11039836/1024(得到MB)/1024(得到GB)=10.56GB</li><li>rss：常驻内存使用Resident memory use (in 4 kB pages)，1530188/1024/1024=1.45GB</li></ul></li></ul><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220730135757686.png" alt="image-20220730135757686"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电表645协议升级流程分析</title>
      <link href="/2022/07/28/dian-biao-645-xie-yi-sheng-ji-liu-cheng-fen-xi/"/>
      <url>/2022/07/28/dian-biao-645-xie-yi-sheng-ji-liu-cheng-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>最近做了645电表的升级，记录一下基本流程</p><h4 id="1、升级初始帧">1、升级初始帧</h4><p>升级初始帧也是升级帧，只是结构和升级帧有点区别，结构如下</p><pre class="language-java" data-language="java"><code class="language-java">68 00 00 00 00 00 00 68 14 5D 34 33 33 D3 &#x2F;&#x2F; DI33 33 33 33 &#x2F;&#x2F; passwordAB 89 67 45 &#x2F;&#x2F; operation33 33 81 45 36 48 &#x2F;&#x2F; 00 00(2字节包号) 81(81-33&#x3D;4E,1字节长度,即后面数据的长度) 12 03(两字节总包数,312&#x3D;786,要发786帧) 15(1字节文件类型,暂用15)    &#x2F;&#x2F; 升级数据35 FC CD C3 38 13 21 23 D6 22 23 C3 39 34 A7 3C 23 45 89 07 57 55 45 88 06 45 8D 70 45 89 41 45 8C B3 C3 38 17 45 88 F1 45 89 07 57 54 45 88 06 45 89 36 45 8C B3 C3 38 17 45 88 F1 45 89 07 57 53 45 88 06 45 89 36 45 8C B3 17 3A 16 </code></pre><h4 id="2、升级帧">2、升级帧</h4><p>升级帧如下：</p><pre class="language-java" data-language="java"><code class="language-java">68 00 00 00 00 00 00 68 14 5A 34 33 33 D3 &#x2F;&#x2F; DI33 33 33 33 &#x2F;&#x2F; password AB 89 67 45 &#x2F;&#x2F; operation34 33 7E     &#x2F;&#x2F; 01 00(包序号) 7E(7E-33&#x3D;4B 1字节长度)         C3 38 15 23 D6 23 45 89 07 32 57 55 45 88 06 13 30 E7 38 3E 22 57 54 45 88 06 13 97 39 93 7A 20 E7 36 46 45 89 07 57 54 45 88 06 13 32 97 63 93 68 22 97 44 93 63 45 89 07 32 57 55 45 88 06 13 E7 4E 3E 22 57 54 45 88 06 13 97 77 16 </code></pre><h4 id="3、激活帧">3、激活帧</h4><pre class="language-java" data-language="java"><code class="language-java">68 11 11 11 11 11 11 68 14 13 35 33 33 D3 33 33 33 33 AB 89 67 45 33 32 32 32 32 32 32 &#x2F;&#x2F;目前数据是固定的D6 16 </code></pre>]]></content>
      
      
      <categories>
          
          <category> 电表通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 645协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB-数据备份还原</title>
      <link href="/2022/07/28/mongodb-shu-ju-bei-fen-huan-yuan/"/>
      <url>/2022/07/28/mongodb-shu-ju-bei-fen-huan-yuan/</url>
      
        <content type="html"><![CDATA[<h3 id="一、数据导入与导出">一、数据导入与导出</h3><h4 id="1-1-导出">1.1 导出</h4><pre class="language-java" data-language="java"><code class="language-java">mongoexport -d watergas -c messageInfo -o &#x2F;data&#x2F;db&#x2F;messageInfo111.json  參数说明:-d 指明使用的库, 本例中为” watergas”-c 指明要导出的集合, 本例中为”messageInfo ”-o 指明要导出的文件名称, 本例中为”&#x2F;data&#x2F;db&#x2F;messageInfo111.json”-h server地址  如果需要权限认证，则需要加入-u、-p、--authenticationDatabase等参数</code></pre><p>Linux下和window下使用方式一样</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20221023190709962.png" alt="Linux"></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20221023191113346.png" alt="windows"></p><h4 id="1-2-导入">1.2 导入</h4><pre class="language-java" data-language="java"><code class="language-java">mongoimport -d watergas -c upgradeTaskInfo --file &#x2F;data&#x2F;db&#x2F;upgradeTaskInfo.json參数说明:-d 指明使用的库, 本例中为” watergas”-c 指明要导出的集合, 本例中为”messageInfo ”--file 指明要导入的文件名称, 本例中为”&#x2F;data&#x2F;db&#x2F;upgradeTaskInfo.json”-h server地址</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20221023191216512.png" alt="image-20221023191216512"></p><h3 id="二、数据库备份与还原">二、数据库备份与还原</h3><h4 id="2-1-备份">2.1 备份</h4><pre class="language-java" data-language="java"><code class="language-java">mongodump -h dbhost -d dbname -o dbdirectory  參数说明:-h：MongDB所在server地址，比如：127.0.0.1，也能够指定port号：127.0.0.1:27017-d：须要备份的数据库实例，比如：watergas-o：备份的数据存放位置，比如：&#x2F;data&#x2F;db&#x2F;watergasddata。当然该文件夹须要提前建立，在备份完毕后，系统自己主动在watergasddata文件夹下建立一个watergas文件夹，这个文件夹里面存放该数据库实例的备份数据。</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20221023191745307.png" alt="image-20221023191745307"></p><h4 id="2-2-还原">2.2 还原</h4><pre class="language-java" data-language="java"><code class="language-java">mongorestore -h dbhost -d dbname –directoryperdb dbdirectory  參数说明:-h：MongoDB所在server地址-d：须要恢复的数据库实例，比如：test，这个名称也能够和备份时候的不一样，比方test2–directoryperdb：备份数据所在位置，比如：&#x2F;data&#x2F;db&#x2F;watergas&#x2F;watergas库还原到。将watergas库还原到watergas1下–drop：恢复的时候，先删除当前数据。然后恢复备份的数据。就是说，恢复后。备份后加入改动的数据都会被删除</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20221023192110935.png" alt="image-20221023192110935"></p><h3 id="3、权限认证相关">3、权限认证相关</h3><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220630093148047.png" alt="image-20220630093148047"></p><pre class="language-java" data-language="java"><code class="language-java">注意！！！！： 数据库迁移需要使用备份(mongodump)与恢复(mongorestore)语法，如果数据库没有开启权限验证，则直接使用命令即可；如果开启了验证登录，是无法直接备份和恢复数据库的，报如下错误：error reading database: command listCollections requires authentication解决方案添加：-u &lt;username&gt; -p&#x3D;&lt;password&gt;添加：--authenticationDatabase admin</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220630093340591.png" alt="image-20220630093340591"></p><p>Mongo的账户是存储在数据库表里面的，比如这里创建的leanote用户，是存储在了leanote表当中的；管理员账户一般是存在在admin当中的</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220702163108158.png" alt="image-20220702163108158"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网穿透工具nps-npc</title>
      <link href="/2022/07/20/nei-wang-chuan-tou-gong-ju-nps-npc/"/>
      <url>/2022/07/20/nei-wang-chuan-tou-gong-ju-nps-npc/</url>
      
        <content type="html"><![CDATA[<h2 id="1、基本概念">1、基本概念</h2><p>内网穿透:内网穿透就是客户端通过访问中转服务器间接性的去访问内网服务器中的东西</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20211120161858323.png" alt="image-20211120161858323"></p><pre class="language-java" data-language="java"><code class="language-java">nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持tcp、udp流量转发，可支持任何tcp、udp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析等等……），此外还支持内网http代理、内网socks5代理、p2p等，并带有功能强大的web管理端。</code></pre><p>**Github地址：**<a href="https://github.com/cnlh/nps">https://github.com/cnlh/nps</a></p><blockquote><ul><li>系统为Linux/Windows/Mac均可，本文服务端和客户端都是在Windows 下进行的</li><li>nps服务端：需要安装在一个有公网IP的服务器上，</li><li>npc客户端：安装在需要被访问的内网服务器或者个人电脑上。</li><li>注意nps和npc版本要保持一致</li></ul></blockquote><h2 id="2、NPS安装">2、NPS安装</h2><pre class="language-java" data-language="java"><code class="language-java"># 下载wget https:&#x2F;&#x2F;github.com&#x2F;cnlh&#x2F;nps&#x2F;releases&#x2F;download&#x2F;v0.23.2&#x2F;linux_amd64_server.tar.gz# 解压tar xzvf linux_amd64_server.tar.gz    # 解压后，首先改一下conf文件夹下的npx.conf文件(conf&#x2F;nps.conf)</code></pre><h3 id="2-1-基本信息">2.1  基本信息</h3><pre class="language-java" data-language="java"><code class="language-java">将 nps 运行到一个有公网 IP 的服务器上，关注配置文件中的 bridge_port 与 web_port。bridge_port 用来与 NPC 相连接，web_port 用来从浏览器访问，从而配置 NPS。sudo .&#x2F;nps 阻断模式运行，可以看到错误信息，如果有端口占用的问题，可以使用 lsof -i:port 的方式查询占用该端口的进程名，从而将该进程 kill 掉或者关掉。</code></pre><h3 id="2-2-配置">2.2  配置</h3><pre class="language-java" data-language="java"><code class="language-java">appname &#x3D; nps#Boot mode(dev|pro)runmode &#x3D; dev ##bridge,用来与 NPC 相连接# 底层通信协议，默认tcp，可选用kcpbridge_type&#x3D;tcp# 底层通信端口，默认8024，如已被占用请指定其他端口，若未开放，先开放端口bridge_port&#x3D;8024bridge_ip&#x3D;0.0.0.0 #web,用来从浏览器访问web_host&#x3D;116.62.49.243web_username&#x3D;adminweb_password&#x3D;666666web_port &#x3D; 8080web_ip&#x3D;0.0.0.0</code></pre><h3 id="2-3-安装、启动">2.3  安装、启动</h3><h4 id="2-3-1-服务端">2.3.1 服务端</h4><pre class="language-java" data-language="java"><code class="language-java"># 安装修改完配置文件之后，.&#x2F;nps install当前的配置文件和web静态文件拷贝到&#x2F;etc&#x2F;nps下，以后修改配置文件直接修改&#x2F;etc&#x2F;nps&#x2F;conf&#x2F;nps.conf    # 启动.&#x2F;nps start        # web 访问 web_host:web_port</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20211120165112869.png" alt="image-20211120165112869"></p><h4 id="2-3-1-客户端">2.3.1 客户端</h4><pre class="language-java" data-language="java"><code class="language-java">npc.exe -server&#x3D;116.62.49.243:8024 -vkey&#x3D;0z9ogzrb6h8hmgqa这里的ip是你服务器ip端口是你nps.conf中#bridge设置的桥接端口-vkey是你控制面板客户端生成的唯一认证密钥</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20211120170931250.png" alt="image-20211120170931250"></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20211120171044364.png" alt="image-20211120171044364"></p><h3 id="2-4-内网穿透设置">2.4  内网穿透设置</h3><pre class="language-java" data-language="java"><code class="language-java">1、服务端端口    服务器连接内网需要的端口，随便写一个，然后去开放安全组    2、目标：    内网要穿透的端口号</code></pre><p>点击“隧道之后”点击新增按钮，创建一个隧道，其中“服务端端口”为你穿透成功之后要访问的端口，“目标 (IP:端口)”为你要穿透的项目的启动端口，我这里项目的启动端口为9091，所以，“目标 (IP:端口)”写9091，服务端端口我写的是9099，如图</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20211120172936384.png" alt="image-20211120172936384"></p><p>此时，我们可以在公网通过访问服务端的ip+端口来访问我们本地的项目了</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20211120173933307.png" alt="image-20211120173933307"></p><p>这样就可以访问到我们本地项目的test接口了</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NPS-NPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库版本控制工具FlyWay</title>
      <link href="/2022/07/19/shu-ju-ku-ban-ben-kong-zhi-gong-ju-flyway/"/>
      <url>/2022/07/19/shu-ju-ku-ban-ben-kong-zhi-gong-ju-flyway/</url>
      
        <content type="html"><![CDATA[<h3 id="一、概念解释">一、概念解释</h3><blockquote><p>Flyway是一款开源的数据库迁移工具。可以相对简单的对数据库版本进行控制。</p><p>数据库版本文件：存放在版本文件目录下的sql脚本</p></blockquote><h3 id="二、工具使用">二、工具使用</h3><h4 id="2-1-Springboot整合FlyWay">2.1 Springboot整合FlyWay</h4><p>pom.xml文件引入依赖，将sql文件加入资源路径</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> flyway <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>dependency<span class="token operator">></span>   <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>flywaydb<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>   <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>flyway<span class="token operator">-</span>core<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span class="token operator">...</span><span class="token operator">&lt;</span>resource<span class="token operator">></span>    <span class="token operator">&lt;</span>directory<span class="token operator">></span>$<span class="token punctuation">&#123;</span>basedir<span class="token punctuation">&#125;</span><span class="token operator">/</span>src<span class="token operator">/</span>main<span class="token operator">/</span>resources<span class="token operator">&lt;</span><span class="token operator">/</span>directory<span class="token operator">></span>    <span class="token operator">&lt;</span>filtering<span class="token operator">></span><span class="token boolean">true</span><span class="token operator">&lt;</span><span class="token operator">/</span>filtering<span class="token operator">></span>    <span class="token operator">&lt;</span>includes<span class="token operator">></span>    <span class="token operator">&lt;</span>include<span class="token operator">></span><span class="token operator">**</span><span class="token comment">/*.*&lt;/include>    &lt;/includes>&lt;/resource>    </span></code></pre><h4 id="2-2-application-yml当中配置">2.2 application.yml当中配置</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"># flyway 配置信息# 激活 flywayspring<span class="token punctuation">.</span>flyway<span class="token punctuation">.</span>enabled<span class="token operator">=</span><span class="token boolean">true</span># 禁止清除数据库表：这个属性非常关键，它表示是否要清除已有库下的表，如果执行的脚本是 V1__xxx<span class="token punctuation">.</span>sql，那么会先清除已有库下的表，然后再执行脚本，这在开发环境下还挺方便，但是在生产环境下就要命了，而且它默认就是要清除，生产环境一定要自己配置设置为 <span class="token boolean">true</span>。spring<span class="token punctuation">.</span>flyway<span class="token punctuation">.</span>clean<span class="token operator">-</span>disabled<span class="token operator">=</span><span class="token boolean">true</span># 如果指定 schema 包含了其他表<span class="token punctuation">,</span>但没有 flyway schema history 表的话<span class="token punctuation">,</span>设置为 <span class="token boolean">true</span> 后<span class="token punctuation">,</span> flyway 将在需要 baseline 的时候<span class="token punctuation">,</span> 自动执行一次 baselinespring<span class="token punctuation">.</span>flyway<span class="token punctuation">.</span>baseline<span class="token operator">-</span>on<span class="token operator">-</span>migrate<span class="token operator">=</span><span class="token boolean">true</span># 指定 baseline 的版本号<span class="token punctuation">,</span>缺省值为 <span class="token number">1</span><span class="token punctuation">,</span> 低于该版本号的 <span class="token constant">SQL</span> 文件<span class="token punctuation">,</span> migrate 的时候被忽略spring<span class="token punctuation">.</span>flyway<span class="token punctuation">.</span>baseline<span class="token operator">-</span>version<span class="token operator">=</span><span class="token number">1</span># sql文件目录<span class="token punctuation">,</span>默认是 classpath<span class="token operator">:</span>db<span class="token operator">/</span>migration，如果有多个，用 <span class="token punctuation">,</span> 隔开spring<span class="token punctuation">.</span>flyway<span class="token punctuation">.</span>locations<span class="token operator">=</span>classpath<span class="token operator">:</span>db<span class="token operator">/</span>migration</code></pre><blockquote><p>a. 配置好此二项后，在数据源配置无问题的情况下启动项目，数据库出现flyway_schema_history表即说明整合成功。</p><p><strong>b. 工程启动时会根据当前版本依次执行比当前版本高的sql文件。</strong></p><p>c. 可将数据库初始化数据库脚本作为基准版本，新项目第一次启动时执行，避免初始化数据库的额外工作。</p></blockquote><h3 id="三、分环境配置多套数据库版本文件示例">三、分环境配置多套数据库版本文件示例</h3><p>为解决不同生产环境部分sql版本文件不通用的问题</p><p><strong>a. 配置文件目录结构</strong></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220719144029110.png" alt="image-20220719144029110"></p><p><strong>b. 主配置文件：application.properties</strong></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220719144037804.png" alt="image-20220719144037804"></p><p><strong>c. 生产环境1配置文件</strong></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220719144045083.png" alt="image-20220719144045083"></p><h3 id="四、FlyWay使用约定">四、FlyWay使用约定</h3><h4 id="4-1-数据库版本文件整体约定">4.1 数据库版本文件整体约定</h4><p>一份数据库版本文件可包含多条操作数据库的sql命令(在一个数据库版本sql文件当中，可以写多个建表，插入数据sql)。</p><blockquote><p>在一次提交中将所有需提交的数据库变更维护在同一个数据库版本文件中，无需也没有必要为每一条语句新增一个版本文件。如：在初始化的版本文件中包含了整套建表语句与初始化数据sql。</p></blockquote><p>数据库版本文件使用新增的方式进行管理，提交svn后不允许修改（数据库sql版本不允许修改，若想更新数据库结构，需要新建一个sql数据文件）</p><blockquote><p>该条约定的意思为若已添加某个数据库版本，此时又需要补充内容(或者纠错某些内容)，不允许修改之前的版本文件，只能通过新增一份版本文件对数据库进行操作。可以结合svn版本管理进行理解，文件在提交后版本即固定，再想修改文件需要提交新版而旧版本的记录不变。</p></blockquote><h4 id="4-2-数据库版本文件命名约定">4.2 数据库版本文件命名约定</h4><p><strong>数据迁移文件相关注意事项：</strong></p><ul><li><p>文件存放位置：resources/db/migration</p></li><li><p>命名规则</p><ul><li>V[version]__[name].sql</li><li>名称中[version]和[name]之间是两个下划线</li><li>[version]部分使用时间戳-年月日时分秒(例：20190625143301)</li><li>[name]描述sql作用，使用“_”分隔</li><li>添加数据的sql文件版本[name]部分均需要加data_</li></ul></li><li><p>注意事项：</p><ul><li>每次对数据库表做出改动(通用改动，即所有部署环境都可变更的改动)均需要添加新版本的数据迁移文件</li><li>添加表字段只能用ALTER…ADD，绝不能删表重建！！！(删表重建会删除生产环境的所有表数据，严格禁止！！)</li><li>慎重执行删表，删数据相关sql</li><li>可将数据库初始化数据库脚本作为基准版本，新项目第一次启动时执行，避免初始化数据库的额外工作</li><li>服务启动时会根据当前版本依次执行比当前版本高的迁移文件</li></ul></li><li><p>单一功能的版本文件[name]部分规则</p><ul><li>纯数据操作的使用data_开头</li><li>新增数据使用_add结尾</li><li>修改数据使用_mod结尾</li><li>删除数据使用_del结尾</li></ul></li></ul><h4 id="4-3-注意事项">4.3 注意事项</h4><p>当我们使用FlyWay执行数据库脚本之后，Flyway 还给创建了一个 flyway_schema_history 表，这个表用来记录数据库的更新历史。</p><blockquote><p><strong>这个表当中有记录的脚本，在下次项目启动后就不会在执行了，因为系统知道这个脚本已经执行过了，如果你还想让该 脚本再执行一遍，需要手动删除 flyway_schema_history 表中的对应记录，那么项目启动时，这个脚本就会被执行了。</strong></p></blockquote><blockquote><p>所有的脚本，一旦执行了，就会在 flyway_schema_history 表中有记录，如果你不小心搞错了，可以手动从 flyway_schema_history 表中删除记录，然后修改 SQL 脚本后再重新启动（生产环境不建议）。</p></blockquote><h3 id="五、总结">五、总结</h3><p>flyway是用来做数据库版本管理的，一般主用用途是在运行程序的时候可以顺便生成表数据，</p><p>flyway管理的数据是哪些：一般我们将建表语句以及一些核心的数据通过flyway来管理</p><p>flyway运行的，对比的是flyway_schema_history 表记录和flyway的脚本文件，根据一定的算法进行对比</p><p><strong>项目运行之后流程</strong></p><blockquote><p><strong>在项目运行之后：</strong></p><ul><li>检测数据库当中的版本和项目当中版本是否一致<ul><li>不一致，执行新脚本</li><li>一致<ul><li>检测checksum是否一致<ul><li>一致，不更新</li><li>不一致,说明已执行的flyway脚本给改动过,报错</li></ul></li></ul></li></ul></li></ul></blockquote><p><strong>注意事项如下：</strong></p><blockquote><p>所以我们在进行开发的过程当中，如果要对核心字段、核心数据进行更新，要通过flyway去执行！</p><p>因为,如果我们直接没有通过flyway去修改，而是通过sql或者直接修改的,那么在项目在其他的服务器上运行时，该字段还是之前的，不会修改！</p><p>注意：对于其他的数据，不需要维护在flyway当中,因为fly只是对表当中的数据、结构进行修改，对于未维护在flyway当中的数据，不会进行修改。</p><p>如果有多个flyway文件，在运行时会一个一个执行；如果在下次执行时，发现某个文件被改过了，则会报错</p><p>所以原则是执行后的文件如果要进行修改，不能再源文件上进行修改，需要新建文件进行修改。</p><p>注意：如果新加的版本日期小于之前的版本日期，则会报错；所以要先拉取代码，在更新脚本</p></blockquote><p><strong>flyway的checksum</strong></p><blockquote><p>官网已经说的很清楚，flyway获取flyway_schema_history中最新成功记录的版本号（基准version），与项目中db/migration文件夹中的文件version进行比对，当version大于基准version则执行。既然通过版本号就可以完成迁移前判断，那还需要checksum做什么呢？</p><p><strong>其实我们在使用flyway的时候，需要养成这样一个习惯，一旦执行过的sql脚本就不要去修改，如果需要对已有数据表进行增删改的操作，应该新建一个脚本执行</strong>。但是对于修改已经执行过的sql脚本，flyway也有预防，那就是checksum。</p><p>每个sql脚本在执行前会将基本信息写入flyway_schema_history中，flyway会把每个脚本作为输入，通过某算法（不清楚）输出一个整数，这个数就是checksum，flyway在工作之前，会先基于baseline逐个脚本比对其数据库中的checksum值，如果计算结果不同，则会报mismatch的错误.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flyway </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记</title>
      <link href="/2022/07/19/mongodb-xue-xi-bi-ji/"/>
      <url>/2022/07/19/mongodb-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="一、概述">一、概述</h3><p>内存的特点：一旦重启，或者断电，数据全部不没了，故需要将数据存在磁盘上</p><p>RDAMS（关系型数据库）：全都是表，关系型数据库是由表组成的，所有的关系型数据库都是使用SQL操作的</p><p>NoSQL（非关系型数据库）：键值对数据库，文档数据库(MongoDB)</p><p>MongoDB是为了快速开发互联网web应用而开发的一款数据库，省了建表、改表的时间，而MongoDB是文档数据库，所以速度很快，想改就改，想删就删</p><p>MongoDB的数据模型是面向文档的，所谓文档是一种类似JSON的数据格式，简单理解为，MongoDB当中存储的是各种各样的JSON（BJSON），当然也可以存储一些二进制数据，但是我们把它当成是JSON格式的</p><p>指定数据库位置：</p><pre class="language-java" data-language="java"><code class="language-java">mongod --dbpath 数据库路径 --port 端口号</code></pre><h3 id="二、Docker-componse方式安装">二、Docker-componse方式安装</h3><pre class="language-java" data-language="java"><code class="language-java">mongo:  image: mongo:4.4.6  container_name: tienChin-mongo  restart: always  privileged: true  ports:    - 27017:27017  volumes:    - &#x2F;home&#x2F;techen&#x2F;tienChin&#x2F;mongodb&#x2F;data:&#x2F;data&#x2F;db    - &#x2F;home&#x2F;techen&#x2F;tienChin&#x2F;mongodb&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mongodb    - &#x2F;home&#x2F;techen&#x2F;tienChin&#x2F;mongodb&#x2F;mongod.conf:&#x2F;etc&#x2F;mongod.conf  environment:     TZ: Asia&#x2F;Shanghai     MONGO_INITDB_ROOT_USERNAME: root # 自动开启权限认证     MONGO_INITDB_ROOT_PASSWORD: QAZqaz01  # 路径是容器的路径，不能指定宿主机的路径         command: &quot;mongod --config &#x2F;etc&#x2F;mongod.conf&quot;  networks:    tienChin:      aliases:        - tienChin-mongomongo-express:  image: mongo-express:latest  container_name: tienChin-mongo-express  restart: always  links:    - mongo:mongodb  depends_on:    - mongo  ports:    - 27018:8081  environment:    # 编辑主题    ME_CONFIG_OPTIONS_EDITORTHEME: tienChin-mongo-express    # mongo的服务地址，可以配置容器名也可以用ip    ME_CONFIG_MONGODB_SERVER: mongo    # mongo服务的端口    ME_CONFIG_MONGODB_PORT: 27017    # mongo的admin用户名    ME_CONFIG_MONGODB_ADMINUSERNAME: root    ME_CONFIG_MONGODB_ADMINPASSWORD: QAZqaz01    # 登陆页面时候的用户名    ME_CONFIG_BASICAUTH_USERNAME: admin    ME_CONFIG_BASICAUTH_PASSWORD: 666666  networks:    tienChin:      aliases:        - tienChi-mongo-express</code></pre><h3 id="三、基本概念">三、基本概念</h3><h4 id="3-1数据库操作">3.1数据库操作</h4><p>一个数据库当中有多个集合，类似于数据，数据当中可以存储文档，文档是数据库当中的最小单位，我们操作的都是文档</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20210105102350091.png" alt="image-20210105102350091"></p><p>注意：在MongoDB当中，集合与数据库都不需要手动创建，如果我们在创建文档时，如果文档所在的集合或者数据库不存在，会自动创建，只是，如果没有数据，不会显示，只有在第一次添加数据时会创建，显示</p><pre class="language-java" data-language="java"><code class="language-java">show dbs                     &#x2F;&#x2F;显示系统当中的数据库show databasesdb                           &#x2F;&#x2F;查看当前数据库use 数据库名                  &#x2F;&#x2F;数据库切换show collections             &#x2F;&#x2F;显示当前数据库当中的集合</code></pre><h4 id="3-2-库操作">3.2 库操作</h4><pre class="language-java" data-language="java"><code class="language-java">使用用户名和密码连接到 MongoDB 服务器，你必须使用 &#39;username:password@hostname&#x2F;dbname&#39; 格式，&#39;username&#39;为用户名，&#39;password&#39; 为密码。mongodb:&#x2F;&#x2F;fred:foobar@localhost   &#x2F;&#x2F;使用用户名fred，密码foobar登录localhost的admin数据库。mongodb:&#x2F;&#x2F;fred:foobar@localhost&#x2F;baz  &#x2F;&#x2F;使用用户名fred，密码foobar登录localhost的baz数据库。mongodb:&#x2F;&#x2F;localhost,localhost:27018,localhost:27019  &#x2F;&#x2F;连接 replica set 三台服务器 (端口 27017, 27018, 和27019):MongoDB创建数据库语法：use DATABASE_NAME  &#x2F;&#x2F;如果数据库不存在，则创建数据库，否则切换到指定数据库。实例：</code></pre><h4 id="3-3CRUD">3.3CRUD</h4><pre class="language-java" data-language="java"><code class="language-java">1、insert        db.collection.insert() &#x2F;&#x2F;首先切换到需要的数据库，然后插入文档到集合当中    db.stu.insert(&#123;name：&quot;古踏仙&quot;,age：36,gender：&quot;男&quot;&#125;)        db.stu.find()           &#x2F;&#x2F;查询db当中stu集合当中的所有文档        注意：如果我们给集合当中插入文档时，如果没有指定&quot;_id&quot;，那么会自动创建一个&quot;_id&quot;，作为该文档的唯一属性        可以通过ObjectId()来生成，不会重复，因为是使用时间戳生成的        db.collection.insertOne()   &#x2F;&#x2F;插入一个 ，插入单个    db.collection.insertMany()  &#x2F;&#x2F;插入多个 ，插入数据     2、find    db.stu.find()    &#x2F;db.stu.find(&#123;&#125;) &#x2F;&#x2F;查询集合当中所有符合条件的文档，如果没有传入条件，代表查询所有的文档，返回的是数组      db.stu.findOne()  &#x2F;&#x2F;查询集合当中符合条件的第一个文档，返回的是对象          db.stu.find().count()  &#x2F;&#x2F;查询集合当中符合条件的文档个数    3、update    db.student.update(&#123;query&#125;,&#123;set，unset&#125;)    db.student.update(&#123;&quot;_id&quot;:ObjectId(&quot;5ff3d22976f98c54752c019e&quot;)&#125;,&#123;$unset:&#123;address:&quot;龙符大陆&quot;&#125;&#125;);    update()默认情况下只修改第一个满足条件的判断,但是可以让改多个，加个参数就行，&#123;multil:ture&#125;    updateMany():修改多个    updateOne():修改一个            参数addToSet();    &#x2F;&#x2F;向数组当中添加一个元素push()            &#x2F;&#x2F;向数组当插入一个元素                4、delete    db.student.remove(&#123;id:&quot;sfdjhq2e124234b43534q24&quot;&#125;)  &#x2F;&#x2F;默认删除多个    db.student.remove(&#123;&#125;)    &#x2F;&#x2F;清空集合    db.student.drop()  &#x2F;&#x2F;删除集合</code></pre><pre class="language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 增加-向集合当中插入一个或者多个文档db.student.insert(&#123;name:&quot;王腾&quot;,age:24,gender:&quot;男&quot;&#125;);&#x2F;&#x2F;插入--插入多个db.student.insert([&#123;name:&quot;鲁智深&quot;,age:43,gender:&quot;男&quot;&#125;,&#123;name:&quot;阎婆惜&quot;,age:28,gender:&quot;女&quot;&#125;,&#123;name:&quot;潘金莲&quot;,age:26,gender:&quot;女&quot;&#125;]);db.student.find();ObjectId();db.student.find(&#123;age:5ff3d54ba62600002e003d72&#125;);db.student.find(&#123;&#39;name&#39;&#125;);&#x2F;&#x2F;update（查询条件，修改新信息），update默认情况下只修改第一个满足条件的db.student.update(&#123;&quot;_id&quot;:ObjectId(&quot;5ff3d22976f98c54752c019e&quot;)&#125;,&#123;$unset:&#123;address:&quot;龙符大陆&quot;&#125;&#125;);&#x2F;&#x2F;如果要对文档内的属性进行访问，要在双引号内部进行访问&#x2F;&#x2F;向number当中插入2000条数据for(var i&#x3D;0;i&lt;2000;i++)&#123;db.number.insert(&#123;num:i&#125;);&#125;db.number.find();db.number.remove(&#123;&#125;);var arr&#x3D;[];for(var i&#x3D;0;i&lt;2000;i++)&#123;arr.push(&#123;num:i&#125;);&#125;db.number.insert(arr)db.number.find(&#123;&#125;);&#x2F;&#x2F;查找大于500的db.number.find(&#123;num:&#123;$gt:500&#125;&#125;)&#x2F;&#x2F;查找40到5o的db.number.find(&#123;num:&#123;$gt:40,$lt:50&#125;&#125;);db.number.find().limit(10);&#x2F;&#x2F;skip用于跳过指定的条数，limit用于指定显示的条数，MongoDB会自动调整skip、limit的位置db.number.find().skip(10).limit(10);&#x2F;&#x2F;文档之间的关系&#x2F;&#x2F;sort()用来指定排序的顺序，正数标识升序表，负数表示降序表db.number.find(&#123;&#125;).sort(sal:1);&#x2F;&#x2F;查询时，可以在第二个参数的位置指定查询结果的投影db.number.find(&#123;&#125;,&#123;ename:1,_id:0,age:1&#125;).</code></pre><h3 id="四、备份会还原">四、备份会还原</h3><blockquote><p>数据导入：<br>mongorestore -h 127.0.0.1:27017 -d leanote --dir /mongodb_backup/leanote_install_data/<br>– --h ：服务器ip</p><p>​    -----d ：服务器上数据库<br>​    – --dir导入文件所在目录</p><p>数据导出:</p><p>​mongodump -h 192.168.17.129:27017 -d leanote -o /home/mongodump/</p><p>​    – —o:导出到本地的某个位置<br>​    -------: 将192.168.17.129服务器上的，leanote库，导出到/home/mongodump/目录下</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mina基础(二):客户端、服务端实现</title>
      <link href="/2022/07/19/mina-ji-chu-er-ke-hu-duan-fu-wu-duan-shi-xian/"/>
      <url>/2022/07/19/mina-ji-chu-er-ke-hu-duan-fu-wu-duan-shi-xian/</url>
      
        <content type="html"><![CDATA[<h3 id="一、服务端">一、服务端</h3><p>本次示例当中服务端由一下几部分构成</p><blockquote><p>1、服务端Socket</p><p>2、服务端Socket封装类</p><p>3、DataHandler数据处理</p><p>4、项目启动后调用</p></blockquote><h4 id="1-1、创建Session服务端">1.1、创建Session服务端</h4><pre class="language-java" data-language="java"><code class="language-java">package com.test.mina.server;import org.apache.mina.core.filterchain.IoFilter;import org.apache.mina.core.service.IoAcceptor;import org.apache.mina.core.service.IoHandler;import org.apache.mina.core.session.IdleStatus;import org.apache.mina.filter.codec.ProtocolCodecFilter;import org.apache.mina.filter.codec.textline.TextLineCodecFactory;import org.apache.mina.transport.socket.nio.NioSocketAcceptor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.net.InetSocketAddress;&#x2F;** * @ClassName SocketServer * @description: Mina服务端,提供socket端口侦听服务:用于监听客户端连接，并接受客户端发送过来的数据 * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-08 13:49:19 *&#x2F;public class SocketServer &#123;    private final static Logger logger &#x3D; LoggerFactory.getLogger(SocketServer.class);    &#x2F;**     * 1、创建一个非阻塞的server端的Socket     * 2、设置编码过滤器（使用Mina提供的文本换行符编解码器）     * 3、设置读取数据的缓冲区大小     * 4、设置读写通道无操作进入空闲状态的时间 10ms     * 5、绑定真正的逻辑处理     * 6、绑定端口     *&#x2F;    &#x2F;&#x2F; 绑定的端口    private int port;    private String name;    &#x2F;&#x2F; 服务启动标志    private boolean started&#x3D;false;    &#x2F;&#x2F; 设置读取、设置数据的缓冲区大小    private int readerIndleTime&#x3D;60; &#x2F;&#x2F;s    private int writerIndleTime&#x3D;900; &#x2F;&#x2F;s    private IoHandler dataHandler;    private IoAcceptor acceptorServer;    public SocketServer(String name,int port)&#123;        this.name &#x3D; name;        this.port &#x3D; port;    &#125;    public boolean start()&#123;        if(started)&#123;            return true;        &#125;        try &#123;            &#x2F;&#x2F; 创建一个非阻塞的server端的Socket            acceptorServer &#x3D; new NioSocketAcceptor();            acceptorServer.getSessionConfig().setReaderIdleTime(getReaderIndleTime());            acceptorServer.getSessionConfig().setWriterIdleTime(getWriterIndleTime());            &#x2F;&#x2F; 设置读写通道无操作进入空闲状态的时间 10ms            acceptorServer.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);            &#x2F;&#x2F; 设置过滤链            acceptorServer.getFilterChain().addLast(&quot;codec&quot;, new ProtocolCodecFilter(new TextLineCodecFactory()));            acceptorServer.setHandler(getDataHandler());            acceptorServer.bind(new InetSocketAddress(port));            logger.info(&quot;&#123;&#125; listening port:&#123;&#125;&quot;,name,port);            started &#x3D; true;            return true;        &#125; catch (IOException e) &#123;            logger.error(&quot;start&quot;,e);            return false;        &#125;    &#125;    public void close() &#123;        this.acceptorServer.dispose();    &#125;    public int getReaderIndleTime() &#123;        return readerIndleTime;    &#125;    public void setReaderIndleTime(int readerIndleTime) &#123;        this.readerIndleTime &#x3D; readerIndleTime;    &#125;    public int getWriterIndleTime() &#123;        return writerIndleTime;    &#125;    public void setWriterIndleTime(int writerIndleTime) &#123;        this.writerIndleTime &#x3D; writerIndleTime;    &#125;    public IoHandler getDataHandler() &#123;        return dataHandler;    &#125;    public void setDataHandler(IoHandler dataHandler) &#123;        this.dataHandler &#x3D; dataHandler;    &#125;&#125;</code></pre><h4 id="1-2、创建服务端封装类">1.2、创建服务端封装类</h4><pre class="language-java" data-language="java"><code class="language-java">package com.techen.mina.server;import com.techen.mina.utils.Config;import org.slf4j.Logger;import org.slf4j.LoggerFactory;&#x2F;** * @ClassName Fes * @description: * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-15 10:22:26 *&#x2F;public class Fes &#123;    private static final Logger logger&#x3D; LoggerFactory.getLogger(Fes.class);    &#x2F;&#x2F; 终端上线端口服务    private SocketServer terminalServer;    &#x2F;&#x2F; 主站侧端口服务    private SocketServer clientServer;    &#x2F;&#x2F; 终端上线端口    private int terminalPort;    &#x2F;&#x2F; 主站连接端口    private int clientPort;    private Config config;    &#x2F;&#x2F; 终端数据处理器    private DataHandler terminalDataHandler;    &#x2F;&#x2F; 主站连接数据处理器    private DataHandler clientDataHandler;    public Fes(Config config) &#123;        this.config &#x3D; config;    &#125;    public void start() &#123;        &#x2F;&#x2F; 启动终端通信监听        terminalPort &#x3D; config.getIntValue(&quot;terminal_port&quot;, 12000);        terminalServer &#x3D; new SocketServer(&quot;Terminal Service&quot;, terminalPort);        terminalServer.setReaderIndleTime(config.getIntValue(&quot;terminal_idle&quot;, 300));        terminalServer.setWriterIndleTime(config.getIntValue(&quot;terminal_idle&quot;, 300));        terminalServer.setDataHandler(terminalDataHandler);        terminalServer.start();        &#x2F;&#x2F; 启动主站通信监听        clientPort &#x3D; config.getIntValue(&quot;client_port&quot;, 12001);        clientServer &#x3D; new SocketServer(&quot;Client Service&quot;, clientPort);        clientServer.setReaderIndleTime(config.getIntValue(&quot;client_idle&quot;, 60));        clientServer.setDataHandler(clientDataHandler);        clientServer.start();        logger.info(&quot;fes started.&quot;);    &#125;    public void close() &#123;        terminalServer.close();        clientServer.close();    &#125;    public void setTerminalDataHandler(DataHandler terminalDataHandler) &#123;        this.terminalDataHandler &#x3D; terminalDataHandler;    &#125;    public DataHandler getClientDataHandler() &#123;        return clientDataHandler;    &#125;    public DataHandler getTerminalDataHandler() &#123;        return terminalDataHandler;    &#125;    public void setClientDataHandler(DataHandler clientDataHandler) &#123;        this.clientDataHandler &#x3D; clientDataHandler;    &#125;&#125;</code></pre><h4 id="1-3、数据处理">1.3、数据处理</h4><pre class="language-java" data-language="java"><code class="language-java">package com.techen.mina.server;import org.apache.mina.core.buffer.IoBuffer;import org.apache.mina.core.service.IoHandlerAdapter;import org.apache.mina.core.session.IdleStatus;import org.apache.mina.core.session.IoSession;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import java.nio.charset.StandardCharsets;&#x2F;** * @ClassName DataHandler * @description: * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-15 09:59:56 *&#x2F;@Componentpublic abstract class DataHandler extends IoHandlerAdapter &#123;    private static final Logger logger &#x3D; LoggerFactory.getLogger(DataHandler.class);    public DataHandler() &#123;        super();    &#125;    @Override    public void sessionCreated(IoSession session) throws Exception &#123;        logger.info(&quot;连接成功&quot;);    &#125;    @Override    public void sessionOpened(IoSession session) throws Exception &#123;        logger.info(&quot;服务端与客户端连接打开&quot;);    &#125;    @Override    public void sessionClosed(IoSession session) throws Exception &#123;        logger.info(&quot;服务端与客户端连接关闭&quot;);    &#125;    @Override    public void sessionIdle(IoSession session, IdleStatus status) throws Exception &#123;        logger.info(&quot;服务端进入空闲状态&quot;);    &#125;    @Override    public void exceptionCaught(IoSession session, Throwable cause) throws Exception &#123;        logger.error(&quot;服务端发生异常&quot;, cause);    &#125;    @Override    public void messageReceived(IoSession session, Object message) throws Exception &#123;        &#x2F;&#x2F; 收到的是字符串(传输之前的数据类型)        byte[] msgBytes &#x3D; message.toString().getBytes(StandardCharsets.UTF_8);        try &#123;            this.messageReceived(session, msgBytes);        &#125; catch (Exception var6) &#123;            logger.error(var6.getMessage(), var6);        &#125;    &#125;    public abstract void messageReceived(IoSession var1, byte[] var2);    @Override    public void messageSent(IoSession session, Object message) throws Exception &#123;        logger.info(&quot;服务端发送消息成功&quot;);    &#125;    @Override    public void inputClosed(IoSession session) throws Exception &#123;        logger.info(&quot;输入关闭&quot;);    &#125;&#125;&#x2F;**-----------------------------------------------------------------------------------------------------**&#x2F;package com.techen.mina.server;import org.apache.mina.core.session.IoSession;&#x2F;** * @ClassName ClientDataHandler * @description: * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-15 13:16:44 *&#x2F;public class ClientDataHandler extends DataHandler&#123;    @Override    public void messageReceived(IoSession session, byte[] msgBytes) &#123;        System.out.println(&quot;收到客户端信息：&quot;+new String(msgBytes));    &#125;&#125;&#x2F;**---------------------------------------------------------------------------------------------------**&#x2F;package com.techen.mina.server;import org.apache.mina.core.session.IoSession;&#x2F;** * @ClassName TerminalDataHandler * @description: * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-15 16:18:34 *&#x2F;public class TerminalDataHandler extends DataHandler&#123;    @Override    public void messageReceived(IoSession session, byte[] msgBytes) &#123;        System.out.println(&quot;收到设备端信息：&quot;+new String(msgBytes));    &#125;&#125;    </code></pre><h4 id="1-4、项目启动后调用">1.4、项目启动后调用</h4><pre class="language-java" data-language="java"><code class="language-java">package com.techen.mina;import com.techen.mina.server.ClientDataHandler;import com.techen.mina.server.Fes;import com.techen.mina.server.TerminalDataHandler;import com.techen.mina.utils.Configs;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SocketMinaApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SocketMinaApplication.class, args);        Fes fes &#x3D; new Fes(Configs.getConfig(&quot;&#x2F;config&#x2F;serverconfig.properties&quot;));        fes.setClientDataHandler(new ClientDataHandler());        fes.setTerminalDataHandler(new TerminalDataHandler());        fes.start();    &#125;&#125;</code></pre><h3 id="二、客户端">二、客户端</h3><p>本次示例当中客户端由一下几部分构成</p><blockquote><p>1、客户端Socket</p><p>2、客户端Socket封装类</p><p>3、DataHandler数据处理</p><p>4、项目启动后调用</p><p>5、测试</p></blockquote><h4 id="2-1-客户端Socket">2.1 客户端Socket</h4><p>该类当中有一个主要的方法init,在该方法当中，添加监听端口connect.addListener()时,监听端口类可以实现IoServiceListener，去实现自动重连功能；connect方法用于连接服务端；sendMessage方法用于发送报文</p><pre class="language-java" data-language="java"><code class="language-java">package com.techen.mina.client;import com.techen.mina.utils.CommUtils;import com.techen.mina.utils.Configs;import com.techen.mina.utils.SimpleThreadFactory;import org.apache.mina.core.future.ConnectFuture;import org.apache.mina.core.service.IoConnector;import org.apache.mina.core.service.IoHandler;import org.apache.mina.core.service.IoService;import org.apache.mina.core.service.IoServiceListener;import org.apache.mina.core.session.IdleStatus;import org.apache.mina.core.session.IoSession;import org.apache.mina.filter.codec.ProtocolCodecFactory;import org.apache.mina.filter.codec.ProtocolCodecFilter;import org.apache.mina.filter.codec.textline.TextLineCodecFactory;import org.apache.mina.filter.executor.ExecutorFilter;import org.apache.mina.transport.socket.nio.NioSocketConnector;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.net.InetSocketAddress;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicBoolean;&#x2F;** * @ClassName ClientServer：mina socket客户端封装。提供连接建立，自动重连等功能。 * @description: IoSession是最重要的一个接口：当连接建立之后，不同的客户端会单独建立一个Session，在Session当中进行数据传输 * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-18 17:39:39 *&#x2F;public class SocketClient &#123;    &#x2F;**     * 1、创建一个非阻塞的客户端     * 2、设置超时时间     * 3、设置编码解码器     * 4、绑定逻辑处理类     * 5、创建连接     * 6、等待连接创建完成     * 7、获取连接session     * 8、发送数据     * 9、等待关闭连接     *&#x2F;    private final static Logger logger &#x3D; LoggerFactory.getLogger(SocketClient.class);    private IoConnector connector;    private IoSession ioSession;    private AtomicBoolean beKilled&#x3D;new AtomicBoolean(false);    private AtomicBoolean isConnecting&#x3D;new AtomicBoolean(false);    private ProtocolCodecFactory codecFactory;    &#x2F;&#x2F; 延时连接 s    private int delayConnect &#x3D; Configs.getConfig().getIntValue(&quot;SOCKET_DELAY_CONNECT&quot;,5);    &#x2F;&#x2F; 重连间隔 s    private int reConnectInterval &#x3D; Configs.getConfig().getIntValue(&quot;SOCKET_RECONNECT_INTERVAL&quot;,10);    &#x2F;&#x2F; 连接超时时间 s    private int connectTimeout &#x3D; Configs.getConfig().getIntValue(&quot;SOCKET_CONNECT_TIMEOUT&quot;,20);    &#x2F;&#x2F; read idle time s    private int readIdleTime &#x3D; Configs.getConfig().getIntValue(&quot;SOCKET_READIDLE_TIME&quot;,30);    &#x2F;**     * 自动重连     *&#x2F;    private boolean autoReconnect&#x3D;true;    private String ip;    private int port;    public SocketClient(String ip, int port) &#123;        init(ip,port,connectTimeout, readIdleTime);    &#125;    public SocketClient(String ip, int port, int conTimeOut, int idleTime) &#123;        init(ip,port,conTimeOut, idleTime);    &#125;    &#x2F;**     * @description: 初始化连接参数     * @author: bozhiqiang     * @updateTime: 2022&#x2F;7&#x2F;18 18:59     *&#x2F;    private void init(String ip, int port,int conTimeOut, int idleTime) &#123;        this.ip &#x3D; ip;        this.port &#x3D; port;        &#x2F;&#x2F; 创建一个非阻塞的客户端        connector &#x3D; new NioSocketConnector();        connector.setConnectTimeoutMillis(conTimeOut * 1000);        connector.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE,idleTime);        &#x2F;&#x2F;设置过滤链        connector.getFilterChain().addLast(&quot;codec&quot;, new ProtocolCodecFilter(new TextLineCodecFactory()));        connector.getFilterChain().addLast(&quot;executor&quot;, new ExecutorFilter());        connector.addListener(new ClientIoServiceListener());    &#125;    &#x2F;**     * @description: mina socket连接状态监听类：mina socket连接状态监听类，在连接session失效后，自动重连     * @author: bozhiqiang     * @updateTime: 2022&#x2F;7&#x2F;18 19:02     *&#x2F;    private class ClientIoServiceListener implements IoServiceListener &#123;        @Override        public void serviceActivated(IoService service) throws Exception &#123;            &#x2F;&#x2F;logger.debug(&quot;socketClient serviceActivated&quot;);        &#125;        @Override        public void serviceDeactivated(IoService service) throws Exception &#123;            &#x2F;&#x2F;logger.debug(&quot;socketClient serviceDeactivated&quot;);        &#125;        @Override        public void serviceIdle(IoService service, IdleStatus idleStatus)                throws Exception &#123;            logger.debug(&quot;socketClient serviceIdle&quot;);        &#125;        @Override        public void sessionClosed(IoSession session) throws Exception &#123;            logger.debug(&quot;socketClient sessionClosed&quot;);        &#125;        @Override        public void sessionCreated(IoSession session) throws Exception &#123;            logger.debug(&quot;socketClient sessionCreated&quot;);        &#125;        @Override        public void sessionDestroyed(IoSession session) throws Exception &#123;            logger.debug(&quot;socketClient sessionDestroyed! &quot;);            if(autoReconnect)&#123;                delayConnect(delayConnect, TimeUnit.SECONDS);            &#125;        &#125;    &#125;    &#x2F;**     * socket连接断开后，延时重连     * @Description: 在侦听到连接断开事件后，延时重连     * @param delay延时时间     * @param timeUnit延时时间单位     * @return: void     * @Modify:     *&#x2F;    private void delayConnect(long delay, TimeUnit timeUnit) &#123;        logger.debug(&quot;delay &quot; + delay+&quot; &quot;+timeUnit  +&quot; to reconnect&quot;);        scheduleExecutor.schedule(new Runnable() &#123;            public void run() &#123;                try &#123;                    SocketClient.this.connect();                &#125; catch (Exception e) &#123;                    logger.error(&quot;error&quot;, e);                &#125;            &#125;        &#125;, delay, timeUnit);    &#125;    &#x2F;**     * 连接建立线程池，目前只是内部自动重连采用该线程池，外部调用connect方法，还是通过调用线程     *&#x2F;    private static ScheduledExecutorService scheduleExecutor &#x3D; Executors.newScheduledThreadPool(6, new SimpleThreadFactory(&quot;SocketClientConManager&quot;));    &#x2F;**     * 连接服务器     * @Description: SocketClient实例创建后，根据连接参数与服务器建立连接。建立连接为阻塞过程，如连接无法建立当前线程将一直阻塞     * @return: void     * @Modify:     *&#x2F;    public void connect() &#123;        if (isConnecting.get() ||( ioSession !&#x3D; null &amp;&amp;  ioSession.isConnected())) &#123;            return;        &#125;        isConnecting.set(true);        beKilled.set(false);        logger.info(&quot;connecting to &#123;&#125;:&#123;&#125;  &quot;,ip,port );        while(true)&#123;            try&#123;                if(beKilled.get()&#x3D;&#x3D;true)&#123;                    logger.warn(&quot;socketClient was killed, break connect(). &quot;);                    break;                &#125;                &#x2F;&#x2F; 创建连接                ConnectFuture cf &#x3D; connector.connect(new InetSocketAddress(ip, port));                &#x2F;&#x2F; 等待连接创建完成:阻塞直到连接建立,因为我们后面要使用连接成功之后创建的Session对象来进行写数据的操作                cf.awaitUninterruptibly();                &#x2F;&#x2F; 获取连接session                ioSession &#x3D; cf.getSession();                if(ioSession.isConnected())&#123;                    logger.info(&quot;connected to &#123;&#125;:&#123;&#125;&quot;,ip,port);                &#125;                isConnecting.set(false);                break;            &#125; catch(Exception e)&#123;                logger.error(e.getMessage(),e);                if(autoReconnect)&#123;                    logger.warn(&quot;connect to &#123;&#125;:&#123;&#125; failed! reconnect after &#123;&#125; s&quot;,ip,port,reConnectInterval);                    try &#123;                        Thread.sleep(reConnectInterval*1000);                    &#125; catch (InterruptedException e1) &#123;                        e1.printStackTrace();                    &#125;                &#125;                else&#123;                    break;                &#125;            &#125;        &#125;    &#125;    &#x2F;&#x2F; 当前连接是否可用    public boolean isConnected()&#123;        return (ioSession !&#x3D; null &amp;&amp; ioSession.isConnected());    &#125;    &#x2F;**     * 关闭连接     * @Description: 关闭socket连接，如close前，SocketClient实例正在进行连接建立（或重连）操作，则关闭后，连接建立或重连操作也将取消     * @return: void     * @Modify:     *&#x2F;    public void close() &#123;        if (ioSession !&#x3D; null &amp;&amp; ioSession.isConnected()) &#123;            ioSession.closeNow();        &#125;        if(connector!&#x3D;null)&#123;            connector.dispose();        &#125;        beKilled.set(true);    &#125;    &#x2F;**     * 发送报文     * @Description: 通过ioSession.write发送报文到服务端     * @param messagesbyte[] 报文，AMR自定义报文格式     * @return: void     * @Modify:     *&#x2F;    public boolean sendMessage(byte[] messages) &#123;        if (ioSession !&#x3D; null &amp;&amp; ioSession.isConnected()) &#123;            try &#123;                ioSession.write(messages);                logger.debug(&quot;forward to server:&quot; + CommUtils.byteToHexString(messages));            &#125; catch (Exception e) &#123;                logger.error(&quot;&quot;,e);                return false;            &#125;        &#125; else &#123;            logger.info(&quot;IoSession is not connected! &quot; + ioSession);            return false;        &#125;        return true;    &#125;    public String getIp() &#123;        return ip;    &#125;    public void setIp(String ip) &#123;        this.ip &#x3D; ip;    &#125;    public int getPort() &#123;        return port;    &#125;    public void setPort(int port) &#123;        this.port &#x3D; port;    &#125;    public void setDataHandler(IoHandler dataHandler) &#123;        connector.setHandler(dataHandler);    &#125;    public void setCodecFactory(ProtocolCodecFactory codecFactory) &#123;        this.codecFactory &#x3D; codecFactory;    &#125;    public IoSession getIoSession() &#123;        return ioSession;    &#125;    public AtomicBoolean getBeKilled() &#123;        return beKilled;    &#125;    public void setBeKilled(AtomicBoolean beKilled) &#123;        this.beKilled &#x3D; beKilled;    &#125;    public int getDelayConnect() &#123;        return delayConnect;    &#125;    public void setDelayConnect(int delayConnect) &#123;        this.delayConnect &#x3D; delayConnect;    &#125;    public int getReConnectInterval() &#123;        return reConnectInterval;    &#125;    public void setReConnectInterval(int reConnectInterval) &#123;        this.reConnectInterval &#x3D; reConnectInterval;    &#125;    public int getConnectTimeout() &#123;        return connectTimeout;    &#125;    public void setConnectTimeout(int connectTimeout) &#123;        this.connectTimeout &#x3D; connectTimeout;    &#125;    public int getReadIdleTime() &#123;        return readIdleTime;    &#125;    public void setReadIdleTime(int readIdleTime) &#123;        this.readIdleTime &#x3D; readIdleTime;    &#125;    public boolean isAutoReconnect() &#123;        return autoReconnect;    &#125;    public void setAutoReconnect(boolean autoReconnect) &#123;        this.autoReconnect &#x3D; autoReconnect;    &#125;&#125;</code></pre><h4 id="2-2-客户端Socket封装">2.2 客户端Socket封装</h4><pre class="language-java" data-language="java"><code class="language-java">package com.techen.mina.client;import com.techen.mina.utils.Configs;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;&#x2F;** * @ClassName JobServer * @description: * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-18 19:50:26 *&#x2F;public class JobServer &#123;    String ip;    int port;    &#x2F;&#x2F; 终端数据处理器    private DataHandler clientTaskDataHandler;    &#x2F;&#x2F; 终端上线端口服务    private SocketClient socketClient;    &#x2F;**     * 任务服务器、前置机连接集合，key为前置机的serverId     *&#x2F;    public static Map&lt;String,SocketClient&gt; onlineClients;    public JobServer()&#123;        onlineClients &#x3D; new ConcurrentHashMap&lt;&gt;();    &#125;    &#x2F;&#x2F; 服务启动时调用即可    public void start() &#123;        &#x2F;&#x2F; 启动终端通信监听        ip &#x3D; Configs.getConfig().getValue(&quot;server_ip&quot;, &quot;127.0.0.1&quot;);        port &#x3D; Configs.getConfig().getIntValue(&quot;server_port&quot;, 7950);        &#x2F;&#x2F; 初始化ip、port、创建创建一个非阻塞的客户端(connect)        socketClient &#x3D; new SocketClient(ip,port);        &#x2F;&#x2F; 设置处理器        socketClient.setDataHandler(getClientTaskDataHandler());        &#x2F;&#x2F; 将连接加入到容器当中        onlineClients.put(&quot;1&quot;,socketClient);        &#x2F;&#x2F; 创建连接、获取IoSession        socketClient.connect();    &#125;    public DataHandler getClientTaskDataHandler() &#123;        return clientTaskDataHandler;    &#125;    public void setClientTaskDataHandler(DataHandler clientTaskDataHandler) &#123;        this.clientTaskDataHandler &#x3D; clientTaskDataHandler;    &#125;    public static Map&lt;String, SocketClient&gt; getOnlineClients() &#123;        return onlineClients;    &#125;&#125;</code></pre><h4 id="2-3-DataHandler数据处理">2.3 DataHandler数据处理</h4><pre class="language-java" data-language="java"><code class="language-java">package com.techen.mina.client;import org.apache.mina.core.service.IoHandlerAdapter;import org.apache.mina.core.session.IdleStatus;import org.apache.mina.core.session.IoSession;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import java.nio.charset.StandardCharsets;&#x2F;** * @ClassName DataHandler * @description: * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-15 09:59:56 *&#x2F;@Componentpublic abstract class DataHandler extends IoHandlerAdapter &#123;    private static final Logger logger &#x3D; LoggerFactory.getLogger(DataHandler.class);    public DataHandler() &#123;        super();    &#125;    @Override    public void sessionCreated(IoSession session) throws Exception &#123;        logger.info(&quot;客端登录成功&quot;);    &#125;    @Override    public void sessionOpened(IoSession session) throws Exception &#123;        logger.info(&quot;服务端与客户端连接打开&quot;);    &#125;    @Override    public void sessionClosed(IoSession session) throws Exception &#123;        logger.info(&quot;客户端登录关闭&quot;);    &#125;    @Override    public void sessionIdle(IoSession session, IdleStatus status) throws Exception &#123;        logger.info(&quot;服务端进入空闲状态&quot;);    &#125;    @Override    public void exceptionCaught(IoSession session, Throwable cause) throws Exception &#123;        logger.error(&quot;服务端发生异常&quot;, cause);    &#125;    @Override    public void messageReceived(IoSession session, Object message) throws Exception &#123;        byte[] msgBytes &#x3D; message.toString().getBytes(StandardCharsets.UTF_8);        try &#123;            this.messageReceived(session, msgBytes);        &#125; catch (Exception var6) &#123;            logger.error(var6.getMessage(), var6);        &#125;    &#125;    public abstract void messageReceived(IoSession var1, byte[] var2);    @Override    public void messageSent(IoSession session, Object message) throws Exception &#123;    &#125;    @Override    public void inputClosed(IoSession session) throws Exception &#123;        logger.info(&quot;输入关闭&quot;);    &#125;&#125;&#x2F;**-----------------------------------------------------------------------------------------------------**&#x2F;    package com.techen.mina.client;import com.techen.mina.utils.CommUtils;import com.techen.mina.utils.Configs;import org.apache.mina.core.session.IdleStatus;import org.apache.mina.core.session.IoSession;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.net.InetSocketAddress;&#x2F;** * @ClassName ClientTaskDataHandler * @description: 该处理器的作用主要是接收信息,并维持心跳 * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-18 19:43:00 *&#x2F;public class ClientTaskDataHandler extends DataHandler &#123;    private static final Logger logger &#x3D; LoggerFactory.getLogger(ClientTaskDataHandler.class);    @Override    public void messageReceived(IoSession session, byte[] message) &#123;        logger.info(&quot;客户端收到消息:&#123;&#125;&quot;, CommUtils.byteToHexString(message));    &#125;    @Override    public void sessionIdle(IoSession session, IdleStatus status) throws Exception &#123;        InetSocketAddress remoteSocketAddress &#x3D; (InetSocketAddress)session.getRemoteAddress();        &#x2F;&#x2F;超过2个心跳周期未收到前置机报文，断开连接        if(session.getIdleCount(IdleStatus.READER_IDLE) &gt;Integer.parseInt(Configs.getConfig().getValue(&quot;max_heart_count&quot;, &quot;2&quot;)))&#123;            logger.info(&quot;taskclient readidle count&gt;&#x3D;2, close now. &#123;&#125;&quot;,remoteSocketAddress);            session.closeNow();            return;        &#125;        &#x2F;&#x2F;发送心跳报文        if(status&#x3D;&#x3D;IdleStatus.READER_IDLE)&#123;            logger.debug(&quot;send heart bytes to:&#123;&#125;&quot;,remoteSocketAddress);            session.write(&quot;心跳报文&quot;);        &#125;    &#125;    @Override    public void sessionOpened(IoSession session) throws Exception &#123;        &#x2F;&#x2F;发送登录报文        InetSocketAddress remoteSocketAddress &#x3D; (InetSocketAddress)session.getRemoteAddress();        logger.info(&quot;send login bytes to:&#123;&#125;&quot;,remoteSocketAddress);        session.write(&quot;登录报文&quot;);    &#125;&#125;</code></pre><h4 id="2-4-容器启动时创建">2.4 容器启动时创建</h4><pre class="language-java" data-language="java"><code class="language-java">package com.techen.mina;import com.techen.mina.client.ClientTaskDataHandler;import com.techen.mina.client.JobServer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SocketMinaApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SocketMinaApplication.class, args);        JobServer jobServer &#x3D; new JobServer();        jobServer.setClientTaskDataHandler(new ClientTaskDataHandler());        jobServer.start();    &#125;&#125;</code></pre><h4 id="2-5-测试">2.5 测试</h4><pre class="language-java" data-language="java"><code class="language-java">package com.techen.mina.controller;import com.techen.mina.client.JobServer;import com.techen.mina.client.SocketClient;import com.techen.mina.utils.CommUtils;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;&#x2F;** * @ClassName ClientController * @description: * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-19 10:06:19 *&#x2F;@RestControllerpublic class ClientController &#123;    @GetMapping(&quot;&#x2F;test1&quot;)    public void test1()&#123;        SocketClient socketClient &#x3D; JobServer.getOnlineClients().get(&quot;1&quot;);        &#x2F;&#x2F; 发送报文到服务端        socketClient.sendMessage(CommUtils.hex2BinaryLH(&quot;168e200e200684b000586000210f70000010002cbbc0a100068562113000000681104333334333c1600000000000000000000000000000000574010090800c916&quot;));    &#125;    @GetMapping(&quot;&#x2F;test2&quot;)    public void test2()&#123;        SocketClient socketClient &#x3D; JobServer.getOnlineClients().get(&quot;1&quot;);        &#x2F;&#x2F; 发送报文到服务端        socketClient.sendMessage(CommUtils.hex2BinaryLH(&quot;268e200e200684b000586000210f70000010002cbbc0a100068562113000000681104333334333c1600000000000000000000000000000000574010090800c916&quot;));    &#125;    @GetMapping(&quot;&#x2F;test3&quot;)    public void test3()&#123;        SocketClient socketClient &#x3D; JobServer.getOnlineClients().get(&quot;1&quot;);        &#x2F;&#x2F; 发送报文到服务端        socketClient.sendMessage(CommUtils.hex2BinaryLH(&quot;368e200e200684b000586000210f70000010002cbbc0a100068562113000000681104333334333c1600000000000000000000000000000000574010090800c916&quot;));    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
            <tag> 网络通信 </tag>
            
            <tag> 长链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java调用C动态库</title>
      <link href="/2022/07/18/java-diao-yong-c-dong-tai-ku/"/>
      <url>/2022/07/18/java-diao-yong-c-dong-tai-ku/</url>
      
        <content type="html"><![CDATA[<p>java调用C++动态库</p><p>由于项目，需要调用明华IC卡读卡器接口，项目使用的语言是java，所以需要用到java的JNA技术，去调用C的DLL动态库</p><h3 id="一、JNI、JNA介绍">一、JNI、JNA介绍</h3><blockquote><p>java调用C的方式有两种JNA、JNI</p><p>JNI(Java Native Interface):通过使用 Java本地接口书写程序，可以确保代码在不同的平台上方便移植</p><p>JNA（Java Native Access）：提供一组Java工具类用于在运行期间动态访问系统本地库（native library：如Window的dll）而不需要编写任何Native/JNI代码。开发人员只要在一个java接口中描述目标native library的函数与结构，JNA将自动实现Java接口到native function的映射。<br>简而言之，就是jna基于jni的方式封装了很多api，在使用上面相对于jni来说简化了很多。</p><p>JNA全称Java  Access，是一个建立在经典的JNI技术之上的Java开源框架。JNA提供一组Java工具类用于在运行期动态访问系统本地库（native library：如Window的dll）而不需要编写任何Native/JNI代码。开发人员只要在一个java接口中描述目标native library的函数与结构，JNA将自动实现Java接口到native function的映射。</p><p>需要注意的是：在使用JNI技术调用dll动态链接库时，32位dll只能是32位JDK去调用，64位dll只能是64位JDK去调用。这个必须是这样的，如果发现无法调用或者提示版本错误，首先要检查下JDK的位数和dll的位数是否是对应的。</p></blockquote><h3 id="二、代码演示">二、代码演示</h3><h4 id="1、引入jar包">1、引入jar包</h4><pre class="language-java" data-language="java"><code class="language-java">&lt;dependency&gt;    &lt;groupId&gt;net.java.dev.jna&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;jna&lt;&#x2F;artifactId&gt;    &lt;version&gt;5.12.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><h4 id="2、定义接口，创建动态库实例和动态库接口">2、定义接口，创建动态库实例和动态库接口</h4><blockquote><p>1、接口需要继承Library类</p><p>2、定义动态库接口</p><p>3、定义动态库实例</p></blockquote><pre class="language-java" data-language="java"><code class="language-java">package com.test.jnademo.utils;import com.sun.jna.Library;import com.sun.jna.Native;import com.sun.jna.ptr.IntByReference;import java.io.File;&#x2F;** * @ClassName JnaUtils * @description: * @author: codesheep * @Version 1.0.0 * @createTime: 2022-07-18 09:10:47 *&#x2F;public class JnaInterface &#123;    &#x2F;**     * @description:  明华IC卡读卡器接口:IC（Integrated Circuit）卡，也被称作智能卡（Smart Card），具有写入数据和存储数据的功能，IC卡内存储器的内容可以根据需要有条件地供外部读取，完成信息处理和判定。     * IC卡是携带应用信息和数据的媒体，空白IC卡是不能立即使用的，必须对IC卡应用系统进行初始化，写入系统IC卡和个人密码，个人专用信息和应用数据,所以需要用到读卡器进行操作     * @author: bozhiqiang     * @updateTime: 2022&#x2F;7&#x2F;18 10:33     *&#x2F;    public interface MwIc extends Library &#123;        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;  动态库实例 &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;        &#x2F;&#x2F; load需要指定绝对路径        File file &#x3D; new File(&quot;src&#x2F;main&#x2F;resources&#x2F;lib&#x2F;Mwic_32.dll&quot;);        MwIc INSTANCE  &#x3D;  Native.load(file.getAbsolutePath(),MwIc.class);        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;  动态库接口 &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;        &#x2F;**         * 说明：初始化通讯接口         * 调用：Port: 通讯口号 0、1、2、3 分别代表串口 1、2、3、4 ; baud: 通讯口为串口时代表波特率，其值可为 1200-115200         * 返回：   &lt;0 错误 ; &gt;0 通讯设备标识符         * 举例： icdev&#x3D;ic_init(0,9600);初始化串口 1，波特率为 9600         *&#x2F;        public int ic_init(int port,long baud);        &#x2F;**         * 说明： 关闭通讯口,串口、USB 接口都使用这个函数         * 调用： icdev: 通讯设备标识符         * 返回： &lt;0 错误;&#x3D;0 正确         * 举例： st&#x3D;ic_exit(icdev);         *&#x2F;        public short ic_exit(int icdev);        &#x2F;**         * 说明： 读写器蜂鸣（RD 读写器专用函数）         * 调用： icdev: 通讯设备标识符;time: 蜂鸣时间，值范围 0-255（单位 10ms）         * 返回： &lt;0 错误;&#x3D;0 正确         * 举例： st&#x3D;ic_beep(icdev,100);         *&#x2F;        public short dv_beep(int icdev,short time);        &#x2F;**         * 说明： 读取设备版本号         * 调用： icdev: 通讯设备标识符,len: 版本号字符串长度，其值为 18,databuff: 存放读取的版本号字符串         * 返回： &lt;0 错误,&#x3D;0 正确         * 举例： unsigned char databuff[18];st&#x3D;srd_ver(icdev,18,databuff);         *&#x2F;        public short srd_ver(int icdev,short len,byte[] databuff);        &#x2F;**         * 说明： 检查卡型是否正确         * 调用： icdev: 通讯设备标识符         * 返回： &lt;0 错误,&#x3D;0 正确         * 举例： st&#x3D;chk_4442(icdev)         *&#x2F;        public short chk_4442(int icdev);        &#x2F;**         * 说明： 返回设备当前状态         * 调用： icdev: 通讯设备标识符         * state: 插卡状态         *          1)有检测脚的卡座，读写器返回 4 种插卡状态：         *          00——无卡         *          01——有用户卡         * 返回： &lt;0 错误;&#x3D;0 正确，         * 举例： int status;st&#x3D;get_status(icdev,&amp;status);         *&#x2F;        public short get_status(int icdev, IntByReference statu);        public short srd_4442(int icdev,short offset,short len,byte[] data_buffer);        public short swr_4442(int icdev,short offset,short len,byte[] data_buffer);        public short prd_4442(int icdev,short len,byte[] data_buffer);        public short pwr_4442(int icdev,short offset,short len,byte[] data_buffer);        public short csc_4442(int icdev,short len,byte[] data_buffer);        public short wsc_4442(int icdev,short len,byte[] data_buffer);        public short rsc_4442(int icdev,short len,byte[] data_buffer);        public short rsct_4442(int icdev,IntByReference counter);        public short hex_asc(byte[] hex,byte[] asc,short len);        public short asc_hex(byte[] asc,byte[] hex,short len);    &#125;&#125;</code></pre><h4 id="3、工具类封装">3、工具类封装</h4><pre class="language-java" data-language="java"><code class="language-java">package com.test.jnademo.utils;import com.sun.jna.ptr.IntByReference;&#x2F;** * @ClassName JnaUtils * @description: * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-18 10:38:25 *&#x2F;public class JnaUtils &#123;    public static class MwIc&#123;        &#x2F;**         * @param args         *&#x2F;        int icdev&#x3D;0;        short st&#x3D;1;        byte[] ver&#x3D;new byte[20];        public void DevConnect(JnaInterface.MwIc epen) &#123;            icdev&#x3D;epen.ic_init(0, 9600);            st&#x3D;epen.srd_ver(icdev, (short)18, ver);            if(st!&#x3D;0) &#123;                System.out.println(&quot;ic_init error!&quot;);            &#125;            else &#123;                String str&#x3D;new String(ver,0,18);                System.out.println(str);            &#125;            epen.dv_beep(icdev, (short)30);        &#125;        public void disconnectDev(JnaInterface.MwIc epen) &#123;            epen.ic_exit(icdev);            &#x2F;&#x2F;System.out.println(&quot;ceshi&quot;);        &#125;        public void Card4442(JnaInterface.MwIc epen) &#123;            IntByReference ret &#x3D; new IntByReference();            st&#x3D;epen.get_status(icdev,  ret);            if(st!&#x3D;0) &#123;                System.out.println(&quot;get_status error!&quot;);            &#125;            else &#123;                System.out.println(&quot;ret is &quot;+ ret.getValue());            &#125;            st&#x3D;epen.chk_4442(icdev);            if(st!&#x3D;0) &#123;                System.out.println(&quot;chk_4442 error!&quot;);            &#125;            IntByReference counter&#x3D;new IntByReference();            st&#x3D;epen.rsct_4442(icdev, counter);            if(st!&#x3D;0) &#123;                System.out.println(&quot;rsct_4442 error!&quot;);            &#125;            else &#123;                System.out.println(counter.getValue());            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="4、调用">4、调用</h4><pre class="language-java" data-language="java"><code class="language-java">package com.test.jnademo;import com.test.jnademo.utils.JnaInterface;import com.test.jnademo.utils.JnaUtils;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass JnaDemoApplicationTests &#123;    @Test    void contextLoads() &#123;        JnaInterface.MwIc epen &#x3D; JnaInterface.MwIc.INSTANCE;        if (epen !&#x3D; null)&#123;            System.out.println(&quot;DLL连接成功!&quot;);        &#125; else&#123;            System.out.println(&quot;DLL连接失败!&quot;);        &#125;        JnaUtils.MwIc con&#x3D;new JnaUtils.MwIc();        con.DevConnect(epen);        con.Card4442(epen);        con.disconnectDev(epen);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JNA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mina基础(一):基础介绍</title>
      <link href="/2022/07/17/mina-ji-chu-yi-ji-chu-jie-shao/"/>
      <url>/2022/07/17/mina-ji-chu-yi-ji-chu-jie-shao/</url>
      
        <content type="html"><![CDATA[<p><strong>1、在应用程序中的地位</strong></p><pre class="language-none"><code class="language-none">主要屏蔽了网络通信的一些细节，对Socket进行封装，并且是NIO的一个实现架构，可以帮助我们快速的开发网络通信，常用于游戏的开发、中间件服务端的程序中。Mina最主要的工作就是把底层传输的字节码转换为Java对象，提供给应用程序；或者把应用程序返回的结果转换为字节码，交给底层传输。</code></pre><p><strong>2、长短链接</strong></p><blockquote><p>长链接和短链接<br>长链接：通信双方长期保持一个链接状态不断开，比如QQ，当我们登陆QQ的时候，就会链接腾讯的服务器建立一个链接，链接一旦建立就一会断开，除非发生异常<br>短链接：通信双方不是保持一个长链接状态，比如http协议，请求数据响应完成之后，链接就会断开</p></blockquote><p><strong>3、IOService接口</strong></p><p>*<strong>实现了对网络通信的客户端和服务端之间的抽象，子接口IOConnector用于描述客户端，子接口IOAcceptor用于描述服务端。*</strong></p><p>**作用：**IOService可以管理我们网络通信的客户端和服务端，并且可以管理连接双方的会话session，同样可以添加过滤器。</p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220717174143094.png" alt="image-20220717174143094" style="zoom:50%;" /><blockquote><p>IoService接口声明了服务端的共有属性和行为；</p><p>IoAcceptor接口继承了IoService接口，并添加了服务端特有的接口属性及方法，比如bind（）方法，成为典型的服务端接口；</p><p>IoConnector接口同样继承了IoService接口，并添加了客户端特有的接口属性及方法，比如connect（）方法，成为典型的客户端接口；</p><p>AbstractIoService实现了IoService中管理服务的方法，比如getFilterChainBuilder方法—获得过滤器链；</p><p>AbstractIoService抽象类继承了AbstractIoService抽象类并实现了IoAcceptor接口，成为了拥有管理服务端实现功能的服务端类；我们常用的NioSocketAcceptor就是它的子类；</p><p>AbstractIoConnector抽象类继承了AbstractIoService抽象类并实现了IoConnector接口，成为了拥有管理客户端实现功能的客户端类；我们常用的NioSocketConnector就是它的子类；</p></blockquote><p><strong>4、编码解码</strong></p><p>前面提到Mina最主要的工作就是把底层传输的字节码转换为Java对象，提供给应用程序；或者把应用程序返回的结果转换为字节码，交给底层传输。</p><blockquote><p>应用程序         网络<br>java对象或者基本数据类型   二进制</p><p>对象输出到网络---------------------编码----------------------------&gt;需要编码成二进制</p><p>网络传入的应用程序&lt;---------------------------解码----------------需要解码成java对象或者基本数据类型</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
            <tag> 网络通信 </tag>
            
            <tag> 长链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis分页</title>
      <link href="/2022/07/14/mybatis-fen-ye/"/>
      <url>/2022/07/14/mybatis-fen-ye/</url>
      
        <content type="html"><![CDATA[<p>mybatis分页查询</p><pre class="language-none"><code class="language-none">1、分页类定义    package com.techen.tap.vo;import java.io.Serializable;import java.util.Map;import lombok.Getter;import lombok.Setter;&#x2F;** * 分页查询参数 * @author sunmingzhi * @date 2019年11月22日 下午7:23:57   * @Modify *&#x2F;@Getter@Setterpublic class PageQuery implements Serializable &#123;    private static final long serialVersionUID &#x3D; 1L;    &#x2F;&#x2F; 当前页码    private int currentPage;    &#x2F;&#x2F; 每页条数    private int pageSize;    &#x2F;&#x2F; 排序字段    private String sidx;    &#x2F;&#x2F; 顺序    private String sord;    &#x2F;**     * 构造函数     * @Title:Query     * @Description:     * @param params     *&#x2F;    public PageQuery(Map&lt;String, Object&gt; params) &#123;        this.currentPage &#x3D; Integer.parseInt(params.get(&quot;currentPage&quot;).toString());        this.pageSize &#x3D; Integer.parseInt(params.get(&quot;pageSize&quot;).toString());        this.sidx &#x3D; params.get(&quot;sidx&quot;).toString();        this.sord &#x3D; params.get(&quot;sord&quot;).toString();    &#125;&#125;2、分页查询结果package com.techen.tap.vo;import java.io.Serializable;import java.util.List;import lombok.Data;&#x2F;** * @description:分页查询结果 * @author: zs * @date: 2019年8月17日上午9:52:48 * @modify: *&#x2F;@Datapublic class Page implements Serializable &#123;    private static final long serialVersionUID &#x3D; 1L;    &#x2F;&#x2F; 总记录数    private int totalCount;    &#x2F;&#x2F; 每页记录数    private int pageSize;    &#x2F;&#x2F; 总页数    private int totalPage;    &#x2F;&#x2F; 当前页数    private int currentPage;    &#x2F;&#x2F; 列表数据    private List&lt;?&gt; dataList;    public Page(List&lt;?&gt; dataList, int totalCount, int pageSize, int currentPage) &#123;        this.dataList &#x3D; dataList;        this.totalCount &#x3D; totalCount;        this.pageSize &#x3D; pageSize;        this.currentPage &#x3D; currentPage;        this.totalPage &#x3D; (int) Math.ceil((double) totalCount &#x2F; pageSize);    &#125;&#125;3、分页逻辑@GetMapping(value &#x3D; &quot;&#x2F;meterlist&quot;)public ResponseResult&lt;Object&gt; meterlist(@RequestParam(required &#x3D; false) Map&lt;String, Object&gt; paraMap) &#123;    PageQuery query &#x3D; new PageQuery(paraMap);    &#x2F;&#x2F;拼接查询语句---sql语句(拼接前台选择的查询条件)    &#x2F;**    String sqlWhere &#x3D; this.spellListSql(paraMap);    sqlWhere +&#x3D; &quot; and c_meter.run_status_code&lt;&gt;&#39;9&#39;&quot;;    **&#x2F;    paraMap.put(&quot;whereSql&quot;, sqlWhere);    &#x2F;&#x2F;查询符合条件的总数量    int totalCount &#x3D; service.count(paraMap);    List&lt;Map&lt;String, Object&gt;&gt; tempList &#x3D; new ArrayList&lt;Map&lt;String, Object&gt;&gt;();    if (totalCount &gt; 0) &#123;       &#x2F;&#x2F;进行分页查询---查询结果是List       tempList &#x3D; service.queryMapForPage(sqlWhere, query.getCurrentPage(), query.getPageSize(),                                                                           query.getSidx(),query.getSord());       service.setDispFields(tempList);    &#125;    &#x2F;&#x2F;组装分页查询到的分页类    Page page &#x3D; new Page(tempList, totalCount, query.getPageSize(), query.getCurrentPage());    &#x2F;&#x2F;返回分页信息    return ResponseResult.ok(page);&#125;4、分页sql  &lt;select id&#x3D;&quot;queryMapForPage&quot; resultType&#x3D;&quot;com.techen.tap.base.BasicLowerMap&quot; parameterType&#x3D;&quot;map&quot;&gt;        &lt;![CDATA[            SELECT * FROM file_upload_details             WHERE $&#123;whereSql&#125;            order by $&#123;sidx&#125; $&#123;sord&#125;,id asc             &lt;!-- 查询pagesize条语句，从begincount开始 --&gt;            limit #&#123;pagesize&#125; offset #&#123;begincount&#125;          ]]&gt;   &lt;&#x2F;select&gt;    &#x2F;&#x2F;注意  public List&lt;Map&lt;String, Object&gt;&gt; queryMapForPage(String whereSql, int curPageIndex, int pageSize, String                                                                                        sidx, String sord) &#123;    int beginCount &#x3D; curPageIndex * pageSize - pageSize;    Map&lt;String, Object&gt; paraMap &#x3D; new HashMap&lt;String, Object&gt;();    paraMap.put(&quot;begincount&quot;, beginCount);    paraMap.put(&quot;pagesize&quot;, pageSize);    paraMap.put(&quot;whereSql&quot;, whereSql);    paraMap.put(&quot;sidx&quot;, sidx);    paraMap.put(&quot;sord&quot;, sord);    return this.getSqlSessionTemplate().selectList(entityClass.getName() + &quot;.queryMapForPage&quot; , paraMap);&#125;  5、拼接sqlprotected String convertSql(Map&lt;String, Object&gt; paraMap) &#123;        StringBufferProxy sql &#x3D; new StringBufferProxy();        sql.appendSingle(&quot; 1&#x3D;1 &quot;);        if (paraMap.containsKey(&quot;file_name&quot;) &amp;&amp; !StringUtils.isEmpty(paraMap.get(&quot;file_name&quot;))) &#123;            String value &#x3D; paraMap.get(&quot;file_name&quot;).toString();            if (!StringUtil.isEmpty(value)) &#123;                sql.appendSingle(&quot; and file_name like &#39;%&#123;0&#125;%&#39; &quot;, value);            &#125;        &#125;        if (paraMap.containsKey(&quot;data_date&quot;) &amp;&amp; !StringUtils.isEmpty(paraMap.get(&quot;data_date&quot;))) &#123;            String value &#x3D; paraMap.get(&quot;data_date&quot;).toString();            String getLastDayOfMonth&#x3D;DateUtil.getLastDayOfMonth(value);            String date1&#x3D;value+&quot; 00:00:00&quot;;            String date2&#x3D;getLastDayOfMonth+&quot; 00:00:00&quot;;            if (!StringUtil.isEmpty(value)) &#123;                sql.appendSingle(&quot; and createon between &#39;&#123;0&#125;&#39; and &#39;&#123;1&#125;&#39;&quot;, date1, date2);            &#125;        &#125;        if (paraMap.containsKey(&quot;createuser&quot;) &amp;&amp; !StringUtils.isEmpty(paraMap.get(&quot;createuser&quot;))) &#123;            String createuser &#x3D; paraMap.get(&quot;createuser&quot;).toString();            List&lt;CboUser&gt; cboUsers &#x3D; cboUserService.queryByWhere(&quot; cbo_user.name like &#39;%&quot; + createuser + &quot;%&#39;&quot;);            Long[] idArray &#x3D; new Long[cboUsers.size()];            for (int i &#x3D; 0; i &lt; cboUsers.size(); i++) &#123;                idArray[i] &#x3D; cboUsers.get(i).getId();            &#125;            String substring &#x3D; Arrays.toString(idArray);            substring &#x3D; substring.substring(1, substring.length() - 1);            sql.appendSingle(&quot; and createuser  in (&quot; + substring + &quot;)&quot;);        &#125;        if (paraMap.containsKey(&quot;upload_status&quot;)) &#123;            String value &#x3D; paraMap.get(&quot;upload_status&quot;).toString();            if (!StringUtil.isEmpty(value)) &#123;                sql.appendSingle(&quot; and upload_status &#x3D; &#39;&#123;0&#125;&#39;&quot;, value);            &#125;        &#125;        return sql.toString();    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows下查找java应用内存情况分析</title>
      <link href="/2022/07/14/windows-xia-cha-zhao-java-ying-yong-nei-cun-qing-kuang-fen-xi/"/>
      <url>/2022/07/14/windows-xia-cha-zhao-java-ying-yong-nei-cun-qing-kuang-fen-xi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_14996421/article/details/115726673?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-115726673-blog-105843937.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/qq_14996421/article/details/115726673?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-115726673-blog-105843937.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p><p>在65服务器上查看各java应用的内存占用情况，大多数应用的CPU占用都在1%-5%之间，但是nb-hes的内存占用长期达到了13%左右，遂开始排查nb-hes占用内存过分高的原因，具体步奏如下。</p><h2 id="一、JConsole">一、JConsole</h2><p>排查65服务器上个java应用的内存占用情况</p><p>JConsole是JDK自带的一个工具，也是 一个图形界面的工具，只要装了JDK就有这个工具；可以直接在服务器上连接本地的java进程，也可以从本机去跟踪远程服务器上的一个进程，如下图所示：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615194250948.png" alt="image-20220615194250948"></p><p>点击连接即可</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615194903776.png" alt="image-20220615194903776"></p><p>确认连接</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615195009791.png" alt="image-20220615195009791"></p><p>服务器上面的基本情况如下：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615195315959.png" alt="image-20220615195315959"></p><p>可以看到CPU占用比较高</p><h2 id="二、使用任务管理器查询应用所在详情-PID、安装位置">二、使用任务管理器查询应用所在详情(PID、安装位置)</h2><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615200142459.png" alt="image-20220615200142459"></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615200343473.png" alt="image-20220615200343473"></p><h2 id="三、使用Jstack下载stack信息到某个位置">三、使用Jstack下载stack信息到某个位置</h2><p>使用Jstack将第二步查询到的PID对应的应用的stack信息下载下来</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615195812485.png" alt="image-20220615195812485"></p><h2 id="四、-Process-Explorer">四、 Process Explorer</h2><p>用的是微软提供的 Process Explorer工具，排查上一步查询的进程当中，那个线程所占用的内存最多。</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615201109069.png" alt="image-20220615201109069"></p><h2 id="五、找到占用内存多的那段代码">五、找到占用内存多的那段代码</h2><p>由于stack导出的信息里面线程对应的tid是16进制的，所以要把前面的线程的TID转成16进制的，再在stack导出的文件当中全局搜索该PID(9726—&gt;25FC)</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615201211363.png" alt="image-20220615201211363"></p><h2 id="六、分析">六、分析</h2><p>在代码当中查找该段代码，发现是由于引入的第三方的这个Jar包里面写了一个死循环，去一直监听设备的上线下</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615201654127.png" alt="image-20220615201654127"></p><p>为了验证是否是死循环引起的，现在修改代码不做成死循环</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220616093046466.png" alt="image-20220616093046466"></p><p>打包后重新运行程序，再次测试内存占比，情况如下</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220702135156318.png" alt="image-20220702135156318"></p><p>由此确定，确实是由于这段代码引起的！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存分析 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSql数组及JSON类型数据在Mybatis项目中的使用</title>
      <link href="/2022/07/12/postgresql-shu-zu-ji-json-lei-xing-shu-ju-zai-mybatis-xiang-mu-zhong-de-shi-yong/"/>
      <url>/2022/07/12/postgresql-shu-zu-ji-json-lei-xing-shu-ju-zai-mybatis-xiang-mu-zhong-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>postgresql提供了很多数据类型，某些特殊的类型无法同java数据类型映射。Mybatis提供了一些默认的TypeHandler，但不包含诸如数组、json这些类型在内。为了使用pgsql的这些类型，我们可以自己添加一些特定的typehandler，注册后就可以标注使用了。</p><p><strong>基本操作流程如下：</strong></p><pre class="language-java" data-language="java"><code class="language-java">1、定义实体类，继承BaseTypeHandler  2、在映射文件当中指明typeHandler是这个实体类  3、字符赋值为JSONObject类型</code></pre><p><strong>实体类代码块：</strong></p><pre class="language-java" data-language="java"><code class="language-java">package com.techen.ami.hes.jobserver.entity;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import com.alibaba.fastjson.JSON;import org.apache.ibatis.type.BaseTypeHandler;import org.apache.ibatis.type.JdbcType;import org.postgresql.util.PGobject;&#x2F;** * @description: postgresql提供了很多数据类型，某些特殊的类型无法同java数据类型映射。Mybatis提供了一些默认的TypeHandler，但不包含诸如数组、json这些类型在内。为了使用pgsql的这些类型，我们可以自己添加一些特定的typehandler，注册后就可以标注使用了。 * @author: bozhiqiang * @updateTime: 2022&#x2F;7&#x2F;12 17:07 * @Param:  * @return:  * @throw: *&#x2F;public class JsonTypeHandler extends BaseTypeHandler&lt;Object&gt; &#123;    private static final PGobject pgObject &#x3D; new PGobject();    @Override    public Object getNullableResult(ResultSet resultSet, String columnLabel) throws SQLException &#123;        return resultSet.getString(columnLabel);    &#125;    @Override    public Object getNullableResult(ResultSet resultSet, int columnIndex) throws SQLException &#123;        return resultSet.getString(columnIndex);    &#125;    @Override    public Object getNullableResult(CallableStatement callableStatement, int parameterIndex) throws SQLException &#123;        return callableStatement.getString(parameterIndex);    &#125;    @Override    public void setNonNullParameter(PreparedStatement preparedStatement, int i, Object object, JdbcType jdbcType) throws SQLException &#123;        pgObject.setType(&quot;json&quot;);        pgObject.setValue(JSON.toJSONString(object));        preparedStatement.setObject(i, pgObject);    &#125;&#125;</code></pre><p><strong>JSONObject类型数据</strong></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220712214436903.png" alt="image-20220712214436903"></p><p><strong>映射文件</strong></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220712214502296.png" alt="image-20220712214502296"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo部署到服务器</title>
      <link href="/2022/07/10/hexo-bu-shu-dao-fu-wu-qi/"/>
      <url>/2022/07/10/hexo-bu-shu-dao-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、服务器配置">一、服务器配置</h2><h3 id="1-1-新建用户作为git登陆用户">1.1 新建用户作为git登陆用户</h3><pre class="language-markup" data-language="markup"><code class="language-markup">[root@VM-12-10-centos superzqbo]# sudo adduser git[root@VM-12-10-centos superzqbo]# sudo passwd git更改用户 git 的密码 。新的 密码：重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。</code></pre><h3 id="1-2-修改新建用户的权限为git权限">1.2 修改新建用户的权限为git权限</h3><p>现在这个用户是具备 SSH 权限的，我们需将其切换为仅具有 git 权限。</p><pre class="language-markup" data-language="markup"><code class="language-markup">$ vi /etc/passwd# git:x:1001:1001::/home/git:/bin/bash 修改为下面的$ git:x:1001:1001::/home/git:/bin/git-shell</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220707235803442.png" alt="image-20220707235803442"></p><h3 id="1-3-安装git">1.3 安装git</h3><pre class="language-markup" data-language="markup"><code class="language-markup">[root@VM-12-10-centos superzqbo]# sudo yum install -y git</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220707210450899.png" alt="image-20220707210450899"></p><h3 id="1-4-生成git密钥">1.4 生成git密钥</h3><p><code>ssh</code>，简单来讲，就是一个秘钥，其中，<code>id_rsa</code>是你这台电脑的私人秘钥，不能给别人看的，<code>id_rsa.pub</code>是公共秘钥，可以随便给别人看。把这个公钥放在<code>git仓库</code>上，这样当你链接<code>git仓库</code>自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过<code>git</code>上传你的文件到<code>git仓库</code>上。</p><p>如果有生成过git密钥，直接去~/.ssh/目录下查找即可，该目录下有两个文件</p><pre class="language-markup" data-language="markup"><code class="language-markup">公钥：id_rsa.pub私钥：id_rsa</code></pre><p>如果之前没有生成过，就需要使用下面指令生成一个</p><pre class="language-markup" data-language="markup"><code class="language-markup">ssh-keygen -t rsa -C "superzqbo@163.com"</code></pre><h3 id="1-5-将密钥保存在服务器">1.5 将密钥保存在服务器</h3><pre class="language-markup" data-language="markup"><code class="language-markup">1、服务器运行下面命令，创建.ssh文件夹$ su git$ mkdir ~/.ssh2、创建.ssh/authorized_keys文件，打开authorized_keys文件并将id_rsa.pub的内容复制拷贝其中并保存$ vim ~/.ssh/authorized_keys3、修改权限$ chmod 755 ~$ chmod 700 ~/.ssh$ chmod 600 ~/.ssh/authorized_keys4、测试本地连接服务器（git bash here）,连接成功表示本地和服务器连接时ok的$ ssh -v git@42.194.221.71</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220707214208446.png" alt="image-20220707214208446"></p><h3 id="1-6-创建git仓库">1.6 创建git仓库</h3><pre class="language-markup" data-language="markup"><code class="language-markup">1、切换到root用户，创建一个目录用于存储网站的根目录$ su root2、创建网站的根目录$ mkdir /home/superzqbo/git/hexo$ cd /home/superzqbo/git3、修改用户所有权和用户权限（将当前目录下，所有文件的拥有者修改为git，用户组改为 git）$ chown -R  git:git  hexo$ chown -R 755 hexo$ cd hexo4、创建一个git项目（这里有一个细节，就是.git目录必须要有可读写权限，因为当我们在push的时候，是使用git用户推送到服务器上面去，会有一个写入的过程，如果不赋予可写权限，push就会失败。git目录，用于存储记录版本信息）$ git init --bare hexo.git5、新建git 钩子 post-receive，方便博客推送自动部署(相当于拷贝一份到Ngnix的html当中)$ vim hexo.git/hooks/post-receive# 输入下面的数据#!/bin/shgit --work-tree=/home/superzqbo/hexo --git-dir=/home/superzqbo/git/hexo/hexo.git checkout -f6、赋予这个文件可执行权限chmod +x /home/superzqbo/git/hexo/hexo.git/hooks/post-receive</code></pre><p><strong>钩子函数解析</strong></p><pre class="language-java" data-language="java"><code class="language-java">git --work-tree&#x3D;&#x2F;home&#x2F;superzqbo&#x2F;hexo --git-dir&#x3D;&#x2F;home&#x2F;superzqbo&#x2F;git&#x2F;hexo&#x2F;hexo.git checkout -f# --work-tree&#x3D;&#x2F;home&#x2F;superzqbo&#x2F;hexo 指定hexo文件的位置(ngnix的根目录)    # --git-dir&#x3D;&#x2F;home&#x2F;superzqbo&#x2F;git&#x2F;hexo&#x2F;hexo.git git仓库的地址</code></pre><p>此时，使用客户端上传代码后，除了在仓库下还会在<code>/home/superzqbo/hexo</code>目录下生成上传的代码，Nginx当中指定地址是这个即可。</p><h2 id="二、客户端配置">二、客户端配置</h2><h3 id="2-1-配置">2.1 配置</h3><p>博客根目录_config下增加</p><pre class="language-java" data-language="java"><code class="language-java">root: &#x2F;deploy:  type: git     # 用户@服务器地址:git仓库地址  repository: git@42.194.221.71:&#x2F;home&#x2F;superzqbo&#x2F;git&#x2F;hexo&#x2F;hexo.git  branch: master</code></pre><h3 id="2-2-部署">2.2 部署</h3><pre class="language-text" data-language="text"><code class="language-text">hexo cleanhexo ghexo d</code></pre><h3 id="2-3-Nginx配置">2.3 Nginx配置</h3><p>参考地址：<a href="https://www.yyyzyyyz.cn/posts/45dafe31d273/">https://www.yyyzyyyz.cn/posts/45dafe31d273/</a></p><pre class="language-java" data-language="java"><code class="language-java"># 安装$ yum install -y nginx# 查看Nginx配置文件的位置$ whereis nginx  # 设置开机自启$ systemctl enable nginx.service  # 检查配置文件$ nginx -t</code></pre><p><strong>配置nginx为服务(Systemd服务)</strong></p><pre class="language-java" data-language="java"><code class="language-java">vim &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service--------------------------------------------------------  [Unit]Description&#x3D;nginxAfter&#x3D;network.target  [Service]Type&#x3D;forkingExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginxExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reloadExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s quitPrivateTmp&#x3D; true  [Install]WantedBy&#x3D;multi-user.target  --------------------------------------------------------  [Unit]:服务的说明Description:描述服务After:描述服务类别[Service]服务运行参数的设置Type&#x3D;forking是后台运行的形式ExecStart为服务的具体运行命令ExecReload为重启命令ExecStop为停止命令PrivateTmp&#x3D;True表示给服务分配独立的临时空间注意：[Service]的启动、重启、停止命令全部要求使用绝对路径[Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3</code></pre><p><strong>配置如下</strong></p><pre class="language-markup" data-language="markup"><code class="language-markup">server &#123;  listen       80 default_server;  listen       [::]:80 default_server;  server_name  42.194.221.71;  root         /home/superzqbo/hexo;// 代码地址  charset koi8-r;  # access_log  /var/log/nginx/host.access.log  main;  location / &#123;  &#125;  error_page  404              /404.html;  location = /40x.html &#123;  &#125;  # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;  location = /50x.html &#123;    root   html;  &#125;  # proxy the PHP scripts to Apache listening on 127.0.0.1:80    #    #location ~ \.php$ &#123;    #    proxy_pass   http://127.0.0.1;    #&#125;  # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    #    #location ~ \.php$ &#123;    #    root           html;    #    fastcgi_pass   127.0.0.1:9000;    #    fastcgi_index  index.php;    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;    #    include        fastcgi_params;    #&#125;  # deny access to .htaccess files, if Apache's document root    # concurs with nginx's one    #    #location ~ /\.ht &#123;    #    deny  all;    #&#125;&#125;</code></pre><h2 id="三、Https配置">三、Https配置</h2><p>参考地址： <a href="https://www.freesion.com/article/16501347598/">https://www.freesion.com/article/16501347598/</a></p><p>步奏如下</p><pre class="language-java" data-language="java"><code class="language-java">1、首先我们要拥有一个域名。本文使用的是腾讯云注册的域名。接着申请免费的SSL域名证书。  2、腾讯云首页登录后搜索SSL（其他网站类似），申请SSL证书，一般申请过程会在4小时以内给出结果  3、SSL证书申请成功之后，将其文件点击下载到本地上。这里我们使用的是Nginx证书  4、在服务器Nginx配置文件同级目录创建一个conf目录，将Nginx证书上传到该目录下  5、修改Nginx配置文件</code></pre><pre class="language-markup" data-language="markup"><code class="language-markup"># HTTPS server#server &#123;    #SSL 访问端口号为 443    listen       443 ssl;    #填写绑定证书的域名    server_name  www.superbo.cloud;    #证书文件名称    ssl_certificate      /usr/local/nginx/conf/conf/superbo.cloud_bundle.pem;    #私钥文件名称    ssl_certificate_key  /usr/local/nginx/conf/conf/superbo.cloud.key;    ssl_session_cache    shared:SSL:1m;    ssl_session_timeout  5m;    #请按照以下协议配置    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;    ssl_prefer_server_ciphers  on;    root         /home/superzqbo/hexo;    location / &#123;    &#125;&#125;server &#123;    listen 80;    #填写绑定证书的域名    server_name www.superbo.cloud;    #把http的域名请求转成https    return 301 https://$host$request_uri;&#125;</code></pre><p>注意，如果网站想要正常访问，还需要进行备案！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket通信</title>
      <link href="/2022/07/06/socket-tong-xin/"/>
      <url>/2022/07/06/socket-tong-xin/</url>
      
        <content type="html"><![CDATA[<h3 id="一、数据通信过程">一、数据通信过程</h3><p><strong>一个数据包经由应用程序产生，进入到协议栈中进行各种报文头的包装，然后操作系统调用网卡驱动程序指挥硬件，把数据发送到对端主机</strong>。整个过程的大体的图示如下。</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220706142933670.png" alt="image-20220706142933670"></p><p>协议栈其实是位于操作系统中的一些协议的堆叠，这些协议包括 TCP、UDP、ARP、ICMP、IP等。</p><pre class="language-java" data-language="java"><code class="language-java">通常某个协议的设计都是为了解决某些问题，比如TCP 的设计就负责安全可靠的传输数据，UDP 设计就是报文小，传输效率高，ARP 的设计是能够通过 IP 地址查询物理（Mac）地址，ICMP 的设计目的是返回错误报文给主机，IP 设计的目的是为了实现大规模主机的互联互通。    </code></pre><p><strong>一般处于协议上层的是TCP、UDP协议，IP协议处于下层，这个从TCP/IP四层协议当也可以看得到，IP协议是不可靠的，需要为上层的TCP协议提供通信支持，TCP协议是可靠的，因为有三次握手四次挥手。</strong></p><p>应用程序比如浏览器、电子邮件、文件传输服务器等产生的数据，会通过传输层协议进行传输，而应用程序是不会和传输层直接建立联系的，而是有一个能够连接应用层和传输层之间的套件，这个套件就是 <code>Socket</code>。</p><p>应用程序的下面就是操作系统内部，操作系统内部包括协议栈，协议栈是一系列协议的堆叠。操作系统下面就是网卡驱动程序，网卡驱动程序负责控制网卡硬件，驱动程序驱动网卡硬件完成收发工作.</p><h3 id="二、通过netstat-命令来展示套接字">二、通过netstat 命令来展示套接字</h3><pre class="language-java" data-language="java"><code class="language-java">netstat -ano # netstat 用于显示套接字内容 , -ano 是可选选项# a 不仅显示正在通信的套接字，还显示包括尚未开始通信等状态的所有套接字# n 显示 IP 地址和端口号# o 显示套接字的程序 PID</code></pre><p><img src="https://pic3.zhimg.com/v2-a5b445147b1f4a683500901d35704662_r.jpg" alt="preview"></p><p>图中的每一行都相当于一个套接字，每一列也被称为一个元组，所以一个套接字就是五元组（协议、本地地址、外部地址、状态、PID）。有的时候也被叫做四元组，四元组不包括协议。</p><p>比如图中的第一行，它的协议就是 TCP，本地地址和远程地址都是 0.0.0.0，这表示通信还没有开始，IP 地址暂时还未确定，而本地端口已知是 135，但是远程端口还未知，此时的状态是 <code>LISTENING</code>，LISTENING 表示应用程序已经打开，正在等待与远程主机建立连接最后一个元组是 PID，即进程标识符，PID 就像我们的身份证号码，能够精确定位唯一的进程。</p><h3 id="三、OSI七层协议模型-open-system-interconnection">三、OSI七层协议模型 (open system interconnection)</h3><pre class="language-java" data-language="java"><code class="language-java">应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等表示层：处理数据格式，数据加密等会话层：建立、维护和管理会话传输层：TCP，UDP网络层：IP，ICMP，OSPF，EIGRP，IGMP数据链路层：SLIP，CSLIP，PPP，MTU物理层：比特流传输</code></pre><p>每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220706135944058.png" alt="image-20220706135944058"></p><p>通过上面的图形，由于底一层的需要向高一层的提供服务，我们大致的理解<strong>应用程序需要传输层的tcp和网络层的ip协议提供服务</strong>，可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。</p><h3 id="四、Socket">四、Socket</h3><p><strong>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口，Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</strong></p><h4 id="3-1-Socket创建">3.1 Socket创建</h4><p>Socket 是和应用程序一起创建的。</p><pre class="language-java" data-language="java"><code class="language-java">1、应用程序中有一个 socket 组件，在应用程序启动时，会调用 socket 申请创建套接字，协议栈会根据应用程序的申请创建套接字：2、首先分配一个套接字所需的内存空间，这一步相当于是为控制信息准备一个容器，但只有容器并没有实际作用，所以你还需要向容器中放入控制信息；3、如果你不申请创建套接字所需要的内存空间，你创建的控制信息也没有地方存放，所以分配内存空间，放入控制信息缺一不可。至此套接字的创建就已经完成了。4、套接字创建完成后，会返回一个套接字描述符给应用程序，这个描述符相当于是区分不同套接字的号码牌。根据这个描述符，应用程序在委托协议栈收发数据时就需要提供这个描述符。</code></pre><h4 id="3-2-套接字连接">3.2 套接字连接</h4><p>套接字创建完成后，最终还是为数据收发服务的，在数据收发之前，还需要进行一步 <code>connect</code>，也就是建立连接的过程。应用程序通过 TCP/IP 协议标准从一个主机通过网络介质传输到另一个主机的过程。</p><pre class="language-java" data-language="java"><code class="language-java">1、套接字刚刚创建完成后，还没有数据，也不知道通信对象。在这种状态下，即使你让客户端应用程序委托协议栈发送数据，它也不知道发送到哪里。    2、所以浏览器需要根据网址来查询服务器的 IP 地址，做这项工作的协议是 DNS，查询到目标主机后，再把目标主机的 IP 告诉协议栈，至此，客户端这边就准备好了    3、在服务器上，与客户端一样也需要创建套接字，但是同样的它也不知道通信对象是谁，所以我们需要让客户端向服务器告知客户端的必要信息：IP 地址和端口号。    4、通信双方收到数据之后，还需要一块位置来存放，这个位置就是缓冲区，它是内存的一部分，有了缓冲区，就能够进行数据的收发操作了。</code></pre><p>具体实现</p><p>客户端应用程序需要调用 <code>Socket</code> 库中的 connect 方法，提供 socket 描述符和服务器 IP 地址、端口号。</p><p>这些信息会传递给协议栈中的 TCP 模块，TCP 模块会对请求报文进行封装，再传递给 IP 模块，进行 IP 报文头的封装，然后传递给物理层，进行帧头封装，之后通过网络介质传递给服务器，服务器上会对帧头、IP 模块、TCP 模块的报文头进行解析，从而找到对应的套接字，套接字收到请求后，会写入相应的信息，并且把状态改为正在连接。请求过程完成后，服务器的 TCP 模块会返回响应，这个过程和客户端是一样的。</p><h3 id="四、TCP-IP、Socket、Http的区别">四、TCP/IP、Socket、Http的区别</h3><p>http是要基于TCP连接基础上的，简单的说，TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。客户端和应用服务器建立TCP连接之后，就需要用http协议来传送数据了，HTTP协议简单来说，还是请求，确认，连接。 总体就是C发送一个HTTP请求给S，S收到了这个http请求，然后返回给Chttp响应，然后C的中间件或者说浏览器把这些数据渲染成为了网页，展示在用户面前。</p><pre class="language-java" data-language="java"><code class="language-java">1.socket是通信的基石，是TCP&#x2F;IP的基本操作单元（最小单位），可以理解为TCP&#x2F;IP的封装，调用接口,(所有的程序都是默认调用吗？)    2.应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务(所有应用层都一样？)    3.HTTP等应用层协议，格式的统一（像串口协议一样，格式和速度）    4.Http是基于TCP协议的，tcp计算机通信传数据，但是无法解析数据，解析需要http协议</code></pre><p>http是网络上层协议。底层还是socket短连接是发送数据时进行联接。发送完关闭(http基于短连接的tcp协议)；可以认为不论应用层协议使用的是什么，都是通过调用Socket(对传输层的封装)去进行数据传输的。</p><p>具体应用层使用什么协议，需要按照实际需求去进行操作，比如短连接则可以通过http请求实现；长链接可以使用调用Socket去实现。</p><pre class="language-java" data-language="java"><code class="language-java">长连接：通信双方长期的保持一个连接状态不断开，一旦建立连接后，就不断开，除非发生异常，比较消耗IO资源。短连接：通信双方不是保持一个长期的连接状态，比如Http协议，当客户端发起http请求，服务器处理http请求，当服务器处理完成后，返回客户端数据后就断开链接。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记(一)</title>
      <link href="/2022/07/03/docker-xue-xi-bi-ji-yi/"/>
      <url>/2022/07/03/docker-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<p>Docker是基于go开发的</p><h3 id="一、为什么使用docker">一、为什么使用docker</h3><p>带着环境安装到Docker上，解决环境问题；解决了集群问题</p><p>镜像：将代码，Redis、、、等环境打包成一个镜像，在其他地方可以直接运行，无需在重新安装软件、代码；将正确的环境打包成镜像，直接运行，理念是一次打包处处运行，“一次封装，处处运行”</p><p>只需要一次配置好环境，换到其他的机子上就可以一键运行，大大简化了操作</p><p>四个集装箱（部署四个软件），各自独立，放到一个镜像当中，运行镜像即可</p><h3 id="二、Docker三要素：仓库、镜像、容器">二、Docker三要素：仓库、镜像、容器</h3><p>容器：集装箱就是一个容器，每一个容器当中安装我们要需要的软件，Docker就是鲸鱼，背上有几个集装箱就有几个容器</p><p>虚拟机：模拟的是整套操作系统（模拟的操作系统、软硬件—虚拟硬件，然后在硬件上虚拟软件操作系统），但是启动时间时分钟级别的，Docker启动时秒级别的；</p><p>Docker模拟的是操作系统，直接运行在宿主机上的（没有进行硬件虚拟），没有虚拟自己的内核，用的是宿主机的，所以启动快；容器之间是相互隔离的，每个容器由自己的文件系统，容器之间进程不会相互影响，能区分计算资源</p><p>运行环境的打包封装，这饿环境的一个整体就是镜像，DockerHub上就是存镜像的，</p><p>从仓库拉一个应用到本地就是镜像（Image）,某一个镜像的实例就是一个集装箱容器，各自独立的容器就是一个一个的环境(Redis、Ngnix)</p><h4 id="1、镜像">1、镜像</h4><p>镜像(Image)：Docker镜像就是一个只读的模版，镜像可以用来创建Docker容器，一个镜像可以创建很多容器—类</p><h4 id="2、容器">2、容器</h4><p>容器(Container)：镜像的实例—对象，Docker利用容器运行一个或一组应用，容器是用镜像创建的运行实例，可以对容器进行启动、开始、停止、删除；每个容器都是相互隔离的、保证安全的平台</p><p>可以吧容器看成是一个简易版本的Linux环境(包括root用户权限、进程空间、用户空间、网络空间等)和运行在其中的程序</p><p>容器的定义和镜像几乎一摸一样，也是一堆层的统一视角，唯一的区别是，容器的最上面那一层是可读可写的</p><p>容器是一个运行时环境，可以看成是鲸鱼上一个个的集装箱。</p><h4 id="3、仓库">3、仓库</h4><p>仓库(Repository)：仓库是存放镜像文件的场所,仓库和仓库注册服务器是有区别的，仓库注册服务器上面存放着多个仓库，每个仓库又包含多个镜像，每个镜像又不同的标签(tag)</p><p>仓库分为公共仓库(public)和私有仓库(private)2种，最大的公共仓库是Docker Hub(<a href="https://hub.docker.com">https://hub.docker.com</a>)—在国外，特别慢，存放了数量庞大的镜像供用户下载，国内的公共开源镜像又阿里云、网易云等</p><p>Docker本身是一个容器运行载体，或者称之为管理引擎，我们把应用程序和配置文件打包成包，形成一个可交付的运行环境，这个打包好的运行环境就似乎是一个镜像，只有通过镜像才可以生成Docker容器</p><p>镜像可以看成是容器的模版，Docker根据Image文件生成容器的实例，同一个镜像文件，可以生成多个同时运行的容器实例。</p><p>镜像文件生成的容器实例，本身也是一个文件，称为镜像文件</p><p>一个容器运行一种服务，当我们需要的时候，就可以通过Docker客户端创建一个对应的运行实例，也就是我们的容器</p><p>至于仓库，也就是存放镜像的地方，我们可以吧镜像发布到仓库中，需要的时候从仓库中拉下来救可以啦</p><p>平台架构图如下所示：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220618162307428.png" alt="image-20220618162307428"></p><h3 id="三、指令">三、指令</h3><p>1、docker相关–帮助启动类命令</p><pre class="language-java" data-language="java"><code class="language-java"># 启动$ systemctl start docker  # 停止$ systemctl stop docker  # 重启$ systemctl restart docker  # 查看状态$ systemctl status docker  # 开机自启$ systemctl enable docker  # docker信息$ docker info  # 帮助$ docker --help  # 具体帮助$ docker  具体指令 --help</code></pre><p>2、镜像</p><pre class="language-jav" data-language="jav"><code class="language-jav"># 查看所有镜像$ docker images# 查看远程镜像$ docker search 镜像名# 下载镜像$ docker pull 镜像名# 查看 镜像&#x2F;容器&#x2F;数据卷所占用的内存空间$ docker system df# 删除镜像$ docker rmi 镜像名# 强制删除镜像$ docker rmi -f 镜像名</code></pre><p>虚悬镜像：仓库名和tag都是空的镜像，一般是由于构建镜像的时候出问题导致的，这种镜像删除就好了</p><p>3、容器</p><pre class="language-java" data-language="java"><code class="language-java"># 运行ubunto:latest镜像，并开启交互式模式启动一个容器，在容器内部执行&#x2F;bin&#x2F;sh指令，推出使用exec；$ docker run -it ubunto &#x2F;bin&#x2F;sh# 给容器起名字$ docker run -it --name&#x3D;&quot;myubunto&quot; ubunto &#x2F;bin&#x2F;sh# 后台方式启动容器$ docker run -d --name&#x3D;&quot;myubunto&quot; ubunto # 列出所有正在运行的容器$ docker ps# 列出所有正在运行&#x2F;历史运行的容器包括挂了的容器）$ docker ps -a# 列出最近创建的容器（包括挂了的容器）$ docker ps -l# 列出最近创建的3个容器（包括挂了的容器）$ docker ps -n 3    # 退出容器--容器关闭$ exec# 退出容器--容器不关闭$ ctrl+p+q  # 启动已经停止运行的容器$ docker start 容器ID&#x2F;名字  # 重启容器$ docker restart 容器ID&#x2F;名字    # 关闭容器$ docker stop 容器ID&#x2F;名字   # 强制停止容器$ docker kill 容器ID&#x2F;名字     # 删除已停止的容器$ docker rm 容器ID&#x2F;名字       # 查看容器运行日志$ docker logs 容器ID  # 查看容器内部运行的进程$ docker top 容器ID  # 查看容器内部情况$ docker inspect 容器ID  </code></pre><p>exec和attach的区别</p><pre class="language-java" data-language="java"><code class="language-java"># 使用exit退出不会关闭容器(一般进入容器当中查看信息)docker exec -it 容器ID  &#x2F;bin&#x2F;sh # 使用exit退出会关闭容器docker attach 容器ID </code></pre><p>从镜像的角度看，可以把容器看成是简易版本的Linux环境，</p><pre class="language-java" data-language="java"><code class="language-java"># 将容器内的内容拷贝到宿主机上$ docker cp 容器ID：容器内路径  宿主机路径# 将容器拷贝到宿主机上,归档成一个tar包$ docker export 容器ID  &gt;  文件名.tareg: docker export efewtwe1231  &gt;  ubunto.tar# 根据tar包的内容创建一个新的系统并导入成镜像(即新建一个镜像)$ cat  文件名.tar | docker import - 镜像用户&#x2F;镜像名：版本号eg: cat  ubunto.tar | docker import - techen&#x2F;ubanto：3.7</code></pre><h3 id="四、Docker仓库">四、Docker仓库</h3><p>镜像是只读的，容器是可写的，一般在容器当中新增功能，然后使用commit指令生成新的镜像</p><pre class="language-java" data-language="java"><code class="language-java"># 提交镜像:提交之后成为了一个新的镜像$ docker commit  # 提交镜像:提交之后成为了一个新的镜像$ docker commit -m&#x3D;&quot;提交的描述信息&quot; -a&#x3D;&quot;作者&quot; 容器ID  要创建的目标镜像名：版本eg：docker commit -m&#x3D;&quot;add vim &quot; -a&#x3D;&quot;techen&quot; efrfsfd12  techen&#x2F;myubunto:3.23  </code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619145133791.png" alt="image-20220619145133791"></p><p>1、将本地镜像提交到阿里云镜像当中</p><p>登陆阿里云—&gt; 管理控制台—〉 容器镜像服务 —&gt;实例列表 —&gt; 个人实例 —&gt; 命名空间建命名、镜像仓库建立仓库</p><pre class="language-java" data-language="java"><code class="language-java">1. 登录阿里云Docker Registry$ docker login --username&#x3D;乾程吴彦祖 registry.cn-hangzhou.aliyuncs.com用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。（bzq18107155240）您可以在访问凭证页面修改凭证密码。2. 从Registry中拉取镜像$ docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;techen&#x2F;superzqbo:[镜像版本号]3. 将镜像推送到Registry$ docker login --username&#x3D;乾程吴彦祖 registry.cn-hangzhou.aliyuncs.com$ docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com&#x2F;techen&#x2F;superzqbo:[镜像版本号]$ docker push registry.cn-hangzhou.aliyuncs.com&#x2F;techen&#x2F;superzqbo:[镜像版本号]请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。4. 选择合适的镜像仓库地址从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-hangzhou.aliyuncs.com 作为Registry的域名登录。5. 示例使用&quot;docker tag&quot;命令重命名镜像，并将它通过专有网络地址推送至Registry。$ docker imagesREPOSITORY                                                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZEregistry.aliyuncs.com&#x2F;acs&#x2F;agent                                    0.7-dfb6816         37bb9c63c8b2        7 days ago          37.89 MB$ docker tag 37bb9c63c8b2 registry-vpc.cn-hangzhou.aliyuncs.com&#x2F;acs&#x2F;agent:0.7-dfb6816使用 &quot;docker push&quot; 命令将该镜像推送至远程。$ docker push registry-vpc.cn-hangzhou.aliyuncs.com&#x2F;acs&#x2F;agent:0.7-dfb6816</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619152906932.png" alt="image-20220619152906932"></p><p>2、将本地镜像推送到私服</p><p>在本地新建一个私有仓库供内部使用，Docker Registry是官方提供的工具，用于构建本地私有镜像仓库</p><pre class="language-java" data-language="java"><code class="language-java"># 拉取Docker Registry工具$ docker pull registry  # 查看拉取Docker Registry工具是否成功$ docker images  # 运行私有库Registry，相当于本地有一个Docker Hub;默认情况下会被容器会被创建在&#x2F;var&#x2F;lib&#x2F;registry下$ docker run -d -p 5000:5000 -v &#x2F;home&#x2F;techen&#x2F;docker_registry&#x2F;:tmp&#x2F;registry --privileged&#x3D;true registry    # 验证私服库上有什么镜像（相当于发送了一个Get请求）$ curl -XGET http:&#x2F;&#x2F;ip:port&#x2F;v2&#x2F;_catalog# 将新镜像改造成符合私服镜像的tag$ docker tag 镜像：Tag  IP：port&#x2F;Repository:Tag  # 推送$ docker push ip:port&#x2F;镜像:版本  # 拉取$ docker pull ip:port&#x2F;镜像:版本</code></pre><p>Docker默认不支持http方式推送镜像，要做如下处理</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619160634368.png" alt="image-20220619160634368"></p><h3 id="五、数据卷">五、数据卷</h3><p>Docker挂载主机目录访问出现：cannot open directory.:Permission denied</p><p>解决办法；在挂载后面加上 --privileged = true 参数即可</p><p>原理：Linux内部默认关掉了容器目录挂载的权限</p><p>数据卷主要的作用是映射(数据互相访问)，完成容器内数据的持久化</p><pre class="language-java" data-language="java"><code class="language-java"># 运行一个带有数据卷的容器（如果目录不存在，会自动创建）$ docker run -it --priviledged&#x3D;true -v 宿主机目录:&#x2F;容器目录  --name&#x3D;容器起名  镜像名    # 运行一个带有数据卷的容器（如果目录不存在，会自动创建）,容器可读可写(默认)$ docker run -it --priviledged&#x3D;true -v 宿主机目录:&#x2F;容器目录:rv  --name&#x3D;容器起名  镜像名  # 运行一个带有数据卷的容器（如果目录不存在，会自动创建）,容器可读不可写(容器内不能创建目录、编写文件)$ docker run -it --priviledged&#x3D;true -v 宿主机目录:&#x2F;容器目录:ro  --name&#x3D;容器起名  镜像名</code></pre><pre class="language-java" data-language="java"><code class="language-java"># 查看挂载信息(Mounts里面会有挂载信息)$ docker inspect 容器id</code></pre><p>数据卷的继承和共享</p><pre class="language-java" data-language="java"><code class="language-java"># 实现容器u1和u2之间的数据共享$ docker run -it --priviledged&#x3D;true --volumes-from 父类(容器名-u1)   --name&#x3D;u2  镜像名</code></pre><h3 id="六、DockerFile">六、DockerFile</h3><p>1、DockerFile概念</p><p>DockerFile是用来构建<strong>Docker镜像</strong>的文本文件，是由一条条构建镜像所需的指令和参数构成的<strong>脚本</strong></p><p>DockerFile相当于是一个镜像文件，是可以正常打包运行的</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619170534907.png" alt="image-20220619170534907"></p><p>2、DockerFile构建过程</p><p>DockerFile内容基础知识</p><pre class="language-java" data-language="java"><code class="language-java">1、每条保留字指令都必须为大写字母且后面要跟随至少一个参数2、指令按照从上到下的顺序执行3、#表示注解4、每条指令都会创建一个新的镜像层，并对镜像层进行镜像提交</code></pre><p>3、Docker执行DockerFile的大致流程</p><pre class="language-java" data-language="java"><code class="language-java">1、Docker从基础镜像运行一个容器2、执行一条指令并对容器做出修改3、执行类似docker commit的操作提交一个新的镜像层4、docker基于刚刚提交的镜像运行一个新的容器5、执行DockerFile当中的下一条指令，直到所有的指令都执行完毕</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619172050676.png" alt="image-20220619172050676"></p><p>4、DockerFile保留字介绍</p><pre class="language-java" data-language="java"><code class="language-java">FROM:基础镜像，当前的新镜像是基于哪个镜像MAINTAINER：镜像维护者的姓名和邮箱RUN：容器构建是需要执行的指令，即build时就会执行DockerFile当中run里面的指令，一般有2种格式shell、exec格式(docker build时执行)EXPOSE：当前容器对外暴漏的端口WORKDIR：指定在创建容器后，终端默认登陆进来的目录，一个落脚点USER：指令该镜像已什么样的用户去执行，默认rootENV：设置环境变量，设置后后面可以使用     eg: ENV MY_PATH &#x2F;usr&#x2F;mytest         WORKDIR $MY_PATHADD:将宿主机目录下的文件拷贝进镜像，且会自动处理URL和解压tar压缩包(copy+解压)COPY：类似ADD，将文件拷贝到镜像VOLUME：数据卷CMD：指定容器启动后要做的操作，DockerFile当中可以有多个CMD指令，但是只有最后一个会生效，CMD会被docker run之后的参数替换掉     CMD是在docker run的时候运行     RUN是在docker build的时候运行ENTRYPOINT:也是用来指定一个**容器启动时要执行的指令**，类似于CMD，但是ENTRYPOINT不会被docker run之后的参数替换掉，而且这些命令行参数会被当中参数传递给ENTRYPOINT指定的程序     ENTRYPOINT[&quot;exec&quot;,&quot;parm1&quot;,&quot;parm2&quot;]     ENTRYPOINT、CMD可以一起使用，一般变参会使用CMD，这里的CMD相当于给ENTRYPOINT传递参数     eg:FROM nginx          ENTRYPOINT [&quot;nginx&quot;,&quot;-c&quot;] # 定参          CMD [&quot;&#x2F;etc&#x2F;ngnix&#x2F;nginx.conf&quot;]   #变参     ------》 nginx -c &#x2F;etc&#x2F;ngnix&#x2F;nginx.conf  </code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619175320535.png" alt="image-20220619175320535"></p><p>5、构建DockerFile文件</p><p>1、编写</p><pre class="language-java" data-language="java"><code class="language-java">FROM java:8   # java8作为基础镜像ENV PROJECT_HOME &#x2F;home&#x2F;project  #设置环境变量，设置后后面可以使用ENV FILE_NAME placeholderENV EXPOSE_PORT 8080ENV ACTIVE_ENV devENV JAVA_OPTS &quot;&quot;RUN ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtimeRUN echo &#39;Asia&#x2F;Shanghai&#39; &gt;&#x2F;etc&#x2F;timezoneRUN apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf &#x2F;var&#x2F;cache&#x2F;apk&#x2F;*RUN set -x &amp;&amp; \    mkdir -p &#x2F;root&#x2F;logs&#x2F;$FILE_NAME &amp;&amp; \    mkdir -p $PROJECT_HOMEWORKDIR $PROJECT_HOMEENTRYPOINT [ &quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom -jar $PROJECT_HOME&#x2F;$FILE_NAME.jar --spring.profiles.active&#x3D;$ACTIVE_ENV&quot; ]EXPOSE $EXPOSE_PORT</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619181857597.png" alt="image-20220619181857597"></p><p>2、构建</p><pre class="language-java" data-language="java"><code class="language-java"># 在dockerfile文件下执行下面的指令（注意tag后面有个空格和点）$ docker build -t 新镜像的名字：TAG .</code></pre><p>3、运行</p><pre class="language-java" data-language="java"><code class="language-java">docker run 镜像名  # 测试服务接口是否可用  $ curl  127.0.0.1:6001&#x2F;order&#x2F;test</code></pre><h3 id="七、Docker网络">七、Docker网络</h3><p>docker安装之后会默认创建三个网络</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621003150868.png" alt="image-20220621003150868"></p><pre class="language-java" data-language="java"><code class="language-java"># 创建网络$ docker network create net1  # 删除网络$ docker network rm net1  # 查看网络源数据$ docker network inspect net1</code></pre><p>1、容器之间的互联通信以及端口映射</p><p>2、容器Ip发生变化时，可以通过服务名直接调用</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621003304909.png" alt="image-20220621003304909"></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619205257295.png" alt="image-20220619205257295"></p><p>Docker容器内部的IP时有可能变化的，所以一般相互通信的服务要设置在同一个网段下面，新建一个网络，它的驱动模式是bridge。</p><h3 id="八、Docker-compose">八、Docker-compose</h3><p>用来做容器管理的，相当于一次启动所有容器</p><pre class="language-java" data-language="java"><code class="language-java">Docker-compose使用的流程1、编写DockerFile文件，定义各个微服务并构建成镜像2、使用Docker-componse定义完整的业务单元3、使用docker-compose up启动</code></pre><p>常用指令</p><pre class="language-java" data-language="java"><code class="language-java"># 查看帮助$ docker-compose -h   # 启动服务$ docker-compose up   # 后台启动服务$ docker-compose up -d  # 停止并删除所有容器、网络、卷、镜像$ docker-compose down  # 进入容器内部$ docker-compose exec yml里面服务的ID &#x2F;bin&#x2F;bash  # 展示所有当前docker-compose编排过且运行的容器$ docker-compose ps # 展示所有当前docker-compose编排过的容器的进程$ docker-compose top  # 查看容器的输出日志$ docker-compose logs yml里面服务的ID # 检查配置(检查语法)$ docker-compose config # 检查配置，有问题才输出$ docker-compose config -q  # 重启$ docker-compose restart  # 关闭$ docker-compose stop  # 开启$ docker-compose start</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark使用手册</title>
      <link href="/2022/05/11/wireshark-shi-yong-shou-ce/"/>
      <url>/2022/05/11/wireshark-shi-yong-shou-ce/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Wireshark-介绍">一、Wireshark 介绍</h2><p>Wireshark是网络包分析工具，可以捕获多种网络接口类型的包，甚至包括无线局域网接口网络。包分析工具的主要作用是尝试分析捕获到的数据包，并尝试显示数据包尽可能详细的信息。</p><p>Wireshark是开源软件项目，用GPL（General Public License）协议发行。可以免费在任意数量的机器上使用，不用担心授权和付费问题，所有的源代码在GPL框架下都可以免费使用。因为以上原因，人们可以很容易在Wireshark上添加新的协议，或者将其作为插件整合到自己的程序里，这种应用十分广泛。</p><h2 id="二、Wireshark下载、安装">二、Wireshark下载、安装</h2><p>官网下载,一路next即可：<a href="https://www.wireshark.org">https://www.wireshark.org</a></p><h2 id="三、界面介绍">三、界面介绍</h2><h3 id="3-1-打开Wireshark-2-6-5，主界面如下：">3.1 打开Wireshark 2.6.5，主界面如下：</h3><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621192240599.png" alt="image-20220621192240599"></p><h3 id="3-2-选择要捕获的连接，双击打开">3.2 选择要捕获的连接，双击打开</h3><p>此时会显示所有，需要进行筛选</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621192325257.png" alt="image-20220621192325257"></p><h3 id="3-3-按照条件刷选包">3.3 按照条件刷选包</h3><p><a href="https://blog.csdn.net/qq_44275213/article/details/118873256">https://blog.csdn.net/qq_44275213/article/details/118873256</a></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621192356639.png" alt="image-20220621192356639"></p><h4 id="3-3-1-列表介绍">3.3.1 列表介绍</h4><p>数据包列表窗格，显示捕获的数据包，每个数据包包含编号，时间戳，源地址，目标地址，协议，长度和数据包信息。不同的协议数据包使用不同的颜色区分</p><p>时间格式化：视图—&gt;显示时间格式化—&gt;格式化时间</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621192419204.png" alt="image-20220621192419204"></p><h2 id="四、重点分析：">四、重点分析：</h2><p><a href="https://blog.csdn.net/itcodexy/article/details/122593288">https://blog.csdn.net/itcodexy/article/details/122593288</a></p><p>对于我们日常的分析有用的就是前面的五个字段。它们的含义是：SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有DATA数据传输，RST表示连接重置。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> WireShark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/05/hello-world/"/>
      <url>/2022/05/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
