<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="/2022/07/03/docker-xue-xi-bi-ji/"/>
      <url>/2022/07/03/docker-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>Docker是基于go开发的</p><h3 id="一、为什么使用docker"><a href="#一、为什么使用docker" class="headerlink" title="一、为什么使用docker"></a>一、为什么使用docker</h3><p>带着环境安装到Docker上，解决环境问题；解决了集群问题</p><p>镜像：将代码，Redis、、、等环境打包成一个镜像，在其他地方可以直接运行，无需在重新安装软件、代码；将正确的环境打包成镜像，直接运行，理念是一次打包处处运行，”一次封装，处处运行”</p><p>只需要一次配置好环境，换到其他的机子上就可以一键运行，大大简化了操作</p><p>四个集装箱（部署四个软件），各自独立，放到一个镜像当中，运行镜像即可</p><h3 id="二、Docker三要素：仓库、镜像、容器"><a href="#二、Docker三要素：仓库、镜像、容器" class="headerlink" title="二、Docker三要素：仓库、镜像、容器"></a>二、Docker三要素：仓库、镜像、容器</h3><p>容器：集装箱就是一个容器，每一个容器当中安装我们要需要的软件，Docker就是鲸鱼，背上有几个集装箱就有几个容器</p><p>虚拟机：模拟的是整套操作系统（模拟的操作系统、软硬件—虚拟硬件，然后在硬件上虚拟软件操作系统），但是启动时间时分钟级别的，Docker启动时秒级别的；</p><p>Docker模拟的是操作系统，直接运行在宿主机上的（没有进行硬件虚拟），没有虚拟自己的内核，用的是宿主机的，所以启动快；容器之间是相互隔离的，每个容器由自己的文件系统，容器之间进程不会相互影响，能区分计算资源</p><p>运行环境的打包封装，这饿环境的一个整体就是镜像，DockerHub上就是存镜像的，</p><p>从仓库拉一个应用到本地就是镜像（Image）,某一个镜像的实例就是一个集装箱容器，各自独立的容器就是一个一个的环境(Redis、Ngnix)</p><h4 id="1、镜像"><a href="#1、镜像" class="headerlink" title="1、镜像"></a>1、镜像</h4><p>镜像(Image)：Docker镜像就是一个只读的模版，镜像可以用来创建Docker容器，一个镜像可以创建很多容器—类</p><h4 id="2、容器"><a href="#2、容器" class="headerlink" title="2、容器"></a>2、容器</h4><p>容器(Container)：镜像的实例—对象，Docker利用容器运行一个或一组应用，容器是用镜像创建的运行实例，可以对容器进行启动、开始、停止、删除；每个容器都是相互隔离的、保证安全的平台</p><p>可以吧容器看成是一个简易版本的Linux环境(包括root用户权限、进程空间、用户空间、网络空间等)和运行在其中的程序</p><p>容器的定义和镜像几乎一摸一样，也是一堆层的统一视角，唯一的区别是，容器的最上面那一层是可读可写的</p><p>容器是一个运行时环境，可以看成是鲸鱼上一个个的集装箱。</p><h4 id="3、仓库"><a href="#3、仓库" class="headerlink" title="3、仓库"></a>3、仓库</h4><p>仓库(Repository)：仓库是存放镜像文件的场所,仓库和仓库注册服务器是有区别的，仓库注册服务器上面存放着多个仓库，每个仓库又包含多个镜像，每个镜像又不同的标签(tag)</p><p>仓库分为公共仓库(public)和私有仓库(private)2种，最大的公共仓库是Docker Hub(<a href="https://hub.docker.com)---在国外,特别慢,存放了数量庞大的镜像供用户下载,国内的公共开源镜像又阿里云、网易云等/">https://hub.docker.com)---在国外，特别慢，存放了数量庞大的镜像供用户下载，国内的公共开源镜像又阿里云、网易云等</a></p><p>Docker本身是一个容器运行载体，或者称之为管理引擎，我们把应用程序和配置文件打包成包，形成一个可交付的运行环境，这个打包好的运行环境就似乎是一个镜像，只有通过镜像才可以生成Docker容器</p><p>镜像可以看成是容器的模版，Docker根据Image文件生成容器的实例，同一个镜像文件，可以生成多个同时运行的容器实例。</p><p>镜像文件生成的容器实例，本身也是一个文件，称为镜像文件</p><p>一个容器运行一种服务，当我们需要的时候，就可以通过Docker客户端创建一个对应的运行实例，也就是我们的容器</p><p>至于仓库，也就是存放镜像的地方，我们可以吧镜像发布到仓库中，需要的时候从仓库中拉下来救可以啦</p><p>平台架构图如下所示：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220618162307428.png" alt="image-20220618162307428"></p><h3 id="三、指令"><a href="#三、指令" class="headerlink" title="三、指令"></a>三、指令</h3><p>1、docker相关–帮助启动类命令</p><pre class=" language-java"><code class="language-java"># 启动$ systemctl start docker  # 停止$ systemctl stop docker  # 重启$ systemctl restart docker  # 查看状态$ systemctl status docker  # 开机自启$ systemctl enable docker  # docker信息$ docker info  # 帮助$ docker <span class="token operator">--</span>help  # 具体帮助$ docker  具体指令 <span class="token operator">--</span>help</code></pre><p>2、镜像</p><pre class=" language-jav"><code class="language-jav"># 查看所有镜像$ docker images# 查看远程镜像$ docker search 镜像名# 下载镜像$ docker pull 镜像名# 查看 镜像/容器/数据卷所占用的内存空间$ docker system df# 删除镜像$ docker rmi 镜像名# 强制删除镜像$ docker rmi -f 镜像名</code></pre><p>虚悬镜像：仓库名和tag都是空的镜像，一般是由于构建镜像的时候出问题导致的，这种镜像删除就好了</p><p>3、容器</p><pre class=" language-java"><code class="language-java"># 运行ubunto<span class="token operator">:</span>latest镜像，并开启交互式模式启动一个容器，在容器内部执行<span class="token operator">/</span>bin<span class="token operator">/</span>sh指令，推出使用exec；$ docker run <span class="token operator">-</span>it ubunto <span class="token operator">/</span>bin<span class="token operator">/</span>sh# 给容器起名字$ docker run <span class="token operator">-</span>it <span class="token operator">--</span>name<span class="token operator">=</span><span class="token string">"myubunto"</span> ubunto <span class="token operator">/</span>bin<span class="token operator">/</span>sh# 后台方式启动容器$ docker run <span class="token operator">-</span>d <span class="token operator">--</span>name<span class="token operator">=</span><span class="token string">"myubunto"</span> ubunto # 列出所有正在运行的容器$ docker ps# 列出所有正在运行<span class="token operator">/</span>历史运行的容器包括挂了的容器）$ docker ps <span class="token operator">-</span>a# 列出最近创建的容器（包括挂了的容器）$ docker ps <span class="token operator">-</span>l# 列出最近创建的<span class="token number">3</span>个容器（包括挂了的容器）$ docker ps <span class="token operator">-</span>n <span class="token number">3</span>    # 退出容器<span class="token operator">--</span>容器关闭$ exec# 退出容器<span class="token operator">--</span>容器不关闭$ ctrl<span class="token operator">+</span>p<span class="token operator">+</span>q  # 启动已经停止运行的容器$ docker start 容器ID<span class="token operator">/</span>名字  # 重启容器$ docker restart 容器ID<span class="token operator">/</span>名字    # 关闭容器$ docker stop 容器ID<span class="token operator">/</span>名字   # 强制停止容器$ docker kill 容器ID<span class="token operator">/</span>名字     # 删除已停止的容器$ docker rm 容器ID<span class="token operator">/</span>名字       # 查看容器运行日志$ docker logs 容器ID  # 查看容器内部运行的进程$ docker top 容器ID  # 查看容器内部情况$ docker inspect 容器ID  </code></pre><p>exec和attach的区别</p><pre class=" language-java"><code class="language-java"># 使用exit退出不会关闭容器<span class="token punctuation">(</span>一般进入容器当中查看信息<span class="token punctuation">)</span>docker exec <span class="token operator">-</span>it 容器ID  <span class="token operator">/</span>bin<span class="token operator">/</span>sh # 使用exit退出会关闭容器docker attach 容器ID </code></pre><p>从镜像的角度看，可以把容器看成是简易版本的Linux环境，</p><pre><code># 将容器内的内容拷贝到宿主机上$ docker cp 容器ID：容器内路径  宿主机路径# 将容器拷贝到宿主机上,归档成一个tar包$ docker export 容器ID  &gt;  文件名.tareg: docker export efewtwe1231  &gt;  ubunto.tar# 根据tar包的内容创建一个新的系统并导入成镜像(即新建一个镜像)$ cat  文件名.tar | docker import - 镜像用户/镜像名：版本号eg: cat  ubunto.tar | docker import - techen/ubanto：3.7</code></pre><h3 id="四、Docker仓库"><a href="#四、Docker仓库" class="headerlink" title="四、Docker仓库"></a>四、Docker仓库</h3><p>镜像是只读的，容器是可写的，一般在容器当中新增功能，然后使用commit指令生成新的镜像</p><pre class=" language-java"><code class="language-java"># 提交镜像<span class="token operator">:</span>提交之后成为了一个新的镜像$ docker commit  # 提交镜像<span class="token operator">:</span>提交之后成为了一个新的镜像$ docker commit <span class="token operator">-</span>m<span class="token operator">=</span><span class="token string">"提交的描述信息"</span> <span class="token operator">-</span>a<span class="token operator">=</span><span class="token string">"作者"</span> 容器ID  要创建的目标镜像名：版本eg：docker commit <span class="token operator">-</span>m<span class="token operator">=</span><span class="token string">"add vim "</span> <span class="token operator">-</span>a<span class="token operator">=</span><span class="token string">"techen"</span> efrfsfd12  techen<span class="token operator">/</span>myubunto<span class="token operator">:</span><span class="token number">3.23</span>  </code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619145133791.png" alt="image-20220619145133791"></p><p>1、将本地镜像提交到阿里云镜像当中</p><p>登陆阿里云—&gt; 管理控制台—〉 容器镜像服务 —&gt;实例列表 —&gt; 个人实例 —&gt; 命名空间建命名、镜像仓库建立仓库</p><pre class=" language-java"><code class="language-java"><span class="token number">1</span><span class="token punctuation">.</span> 登录阿里云Docker Registry$ docker login <span class="token operator">--</span>username<span class="token operator">=</span>乾程吴彦祖 registry<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。（bzq18107155240）您可以在访问凭证页面修改凭证密码。<span class="token number">2</span><span class="token punctuation">.</span> 从Registry中拉取镜像$ docker pull registry<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com<span class="token operator">/</span>techen<span class="token operator">/</span>superzqbo<span class="token operator">:</span><span class="token punctuation">[</span>镜像版本号<span class="token punctuation">]</span><span class="token number">3</span><span class="token punctuation">.</span> 将镜像推送到Registry$ docker login <span class="token operator">--</span>username<span class="token operator">=</span>乾程吴彦祖 registry<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com$ docker tag <span class="token punctuation">[</span>ImageId<span class="token punctuation">]</span> registry<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com<span class="token operator">/</span>techen<span class="token operator">/</span>superzqbo<span class="token operator">:</span><span class="token punctuation">[</span>镜像版本号<span class="token punctuation">]</span>$ docker push registry<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com<span class="token operator">/</span>techen<span class="token operator">/</span>superzqbo<span class="token operator">:</span><span class="token punctuation">[</span>镜像版本号<span class="token punctuation">]</span>请根据实际镜像信息替换示例中的<span class="token punctuation">[</span>ImageId<span class="token punctuation">]</span>和<span class="token punctuation">[</span>镜像版本号<span class="token punctuation">]</span>参数。<span class="token number">4</span><span class="token punctuation">.</span> 选择合适的镜像仓库地址从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。如果您使用的机器位于VPC网络，请使用 registry<span class="token operator">-</span>vpc<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com 作为Registry的域名登录。<span class="token number">5</span><span class="token punctuation">.</span> 示例使用<span class="token string">"docker tag"</span>命令重命名镜像，并将它通过专有网络地址推送至Registry。$ docker imagesREPOSITORY                                                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZEregistry<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com<span class="token operator">/</span>acs<span class="token operator">/</span>agent                                    <span class="token number">0.7</span><span class="token operator">-</span>dfb6816         37bb9c63c8b2        <span class="token number">7</span> days ago          <span class="token number">37.89</span> MB$ docker tag 37bb9c63c8b2 registry<span class="token operator">-</span>vpc<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com<span class="token operator">/</span>acs<span class="token operator">/</span>agent<span class="token operator">:</span><span class="token number">0.7</span><span class="token operator">-</span>dfb6816使用 <span class="token string">"docker push"</span> 命令将该镜像推送至远程。$ docker push registry<span class="token operator">-</span>vpc<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com<span class="token operator">/</span>acs<span class="token operator">/</span>agent<span class="token operator">:</span><span class="token number">0.7</span><span class="token operator">-</span>dfb6816</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619152906932.png" alt="image-20220619152906932"></p><p>2、将本地镜像推送到私服</p><p>在本地新建一个私有仓库供内部使用，Docker Registry是官方提供的工具，用于构建本地私有镜像仓库</p><pre class=" language-java"><code class="language-java"># 拉取Docker Registry工具$ docker pull registry  # 查看拉取Docker Registry工具是否成功$ docker images  # 运行私有库Registry，相当于本地有一个Docker Hub<span class="token punctuation">;</span>默认情况下会被容器会被创建在<span class="token operator">/</span>var<span class="token operator">/</span>lib<span class="token operator">/</span>registry下$ docker run <span class="token operator">-</span>d <span class="token operator">-</span>p <span class="token number">5000</span><span class="token operator">:</span><span class="token number">5000</span> <span class="token operator">-</span>v <span class="token operator">/</span>home<span class="token operator">/</span>techen<span class="token operator">/</span>docker_registry<span class="token operator">/</span><span class="token operator">:</span>tmp<span class="token operator">/</span>registry <span class="token operator">--</span>privileged<span class="token operator">=</span><span class="token boolean">true</span> registry    # 验证私服库上有什么镜像（相当于发送了一个Get请求）$ curl <span class="token operator">-</span>XGET http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>ip<span class="token operator">:</span>port<span class="token operator">/</span>v2<span class="token operator">/</span>_catalog# 将新镜像改造成符合私服镜像的tag$ docker tag 镜像：Tag  IP：port<span class="token operator">/</span>Repository<span class="token operator">:</span>Tag  # 推送$ docker push ip<span class="token operator">:</span>port<span class="token operator">/</span>镜像<span class="token operator">:</span>版本  # 拉取$ docker pull ip<span class="token operator">:</span>port<span class="token operator">/</span>镜像<span class="token operator">:</span>版本</code></pre><p>Docker默认不支持http方式推送镜像，要做如下处理</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619160634368.png" alt="image-20220619160634368"></p><h3 id="五、数据卷"><a href="#五、数据卷" class="headerlink" title="五、数据卷"></a>五、数据卷</h3><p>Docker挂载主机目录访问出现：cannot open directory.:Permission denied</p><p>解决办法；在挂载后面加上 –privileged &#x3D; true 参数即可</p><p>原理：Linux内部默认关掉了容器目录挂载的权限</p><p>数据卷主要的作用是映射(数据互相访问)，完成容器内数据的持久化</p><pre class=" language-java"><code class="language-java"># 运行一个带有数据卷的容器（如果目录不存在，会自动创建）$ docker run <span class="token operator">-</span>it <span class="token operator">--</span>priviledged<span class="token operator">=</span><span class="token boolean">true</span> <span class="token operator">-</span>v 宿主机目录<span class="token operator">:</span><span class="token operator">/</span>容器目录  <span class="token operator">--</span>name<span class="token operator">=</span>容器起名  镜像名    # 运行一个带有数据卷的容器（如果目录不存在，会自动创建）<span class="token punctuation">,</span>容器可读可写<span class="token punctuation">(</span>默认<span class="token punctuation">)</span>$ docker run <span class="token operator">-</span>it <span class="token operator">--</span>priviledged<span class="token operator">=</span><span class="token boolean">true</span> <span class="token operator">-</span>v 宿主机目录<span class="token operator">:</span><span class="token operator">/</span>容器目录<span class="token operator">:</span>rv  <span class="token operator">--</span>name<span class="token operator">=</span>容器起名  镜像名  # 运行一个带有数据卷的容器（如果目录不存在，会自动创建）<span class="token punctuation">,</span>容器可读不可写<span class="token punctuation">(</span>容器内不能创建目录、编写文件<span class="token punctuation">)</span>$ docker run <span class="token operator">-</span>it <span class="token operator">--</span>priviledged<span class="token operator">=</span><span class="token boolean">true</span> <span class="token operator">-</span>v 宿主机目录<span class="token operator">:</span><span class="token operator">/</span>容器目录<span class="token operator">:</span>ro  <span class="token operator">--</span>name<span class="token operator">=</span>容器起名  镜像名</code></pre><pre class=" language-java"><code class="language-java"># 查看挂载信息<span class="token punctuation">(</span>Mounts里面会有挂载信息<span class="token punctuation">)</span>$ docker inspect 容器id</code></pre><p>数据卷的继承和共享</p><pre class=" language-java"><code class="language-java"># 实现容器u1和u2之间的数据共享$ docker run <span class="token operator">-</span>it <span class="token operator">--</span>priviledged<span class="token operator">=</span><span class="token boolean">true</span> <span class="token operator">--</span>volumes<span class="token operator">-</span>from 父类<span class="token punctuation">(</span>容器名<span class="token operator">-</span>u1<span class="token punctuation">)</span>   <span class="token operator">--</span>name<span class="token operator">=</span>u2  镜像名</code></pre><h3 id="六、DockerFile"><a href="#六、DockerFile" class="headerlink" title="六、DockerFile"></a>六、DockerFile</h3><p>1、DockerFile概念</p><p>DockerFile是用来构建<strong>Docker镜像</strong>的文本文件，是由一条条构建镜像所需的指令和参数构成的<strong>脚本</strong></p><p>DockerFile相当于是一个镜像文件，是可以正常打包运行的</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619170534907.png" alt="image-20220619170534907"></p><p>2、DockerFile构建过程</p><p>DockerFile内容基础知识</p><pre class=" language-java"><code class="language-java"><span class="token number">1</span>、每条保留字指令都必须为大写字母且后面要跟随至少一个参数<span class="token number">2</span>、指令按照从上到下的顺序执行<span class="token number">3</span>、#表示注解<span class="token number">4</span>、每条指令都会创建一个新的镜像层，并对镜像层进行镜像提交</code></pre><p>3、Docker执行DockerFile的大致流程</p><pre class=" language-java"><code class="language-java"><span class="token number">1</span>、Docker从基础镜像运行一个容器<span class="token number">2</span>、执行一条指令并对容器做出修改<span class="token number">3</span>、执行类似docker commit的操作提交一个新的镜像层<span class="token number">4</span>、docker基于刚刚提交的镜像运行一个新的容器<span class="token number">5</span>、执行DockerFile当中的下一条指令，直到所有的指令都执行完毕</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619172050676.png" alt="image-20220619172050676"></p><p>4、DockerFile保留字介绍</p><pre class=" language-java"><code class="language-java">FROM<span class="token operator">:</span>基础镜像，当前的新镜像是基于哪个镜像MAINTAINER：镜像维护者的姓名和邮箱RUN：容器构建是需要执行的指令，即build时就会执行DockerFile当中run里面的指令，一般有<span class="token number">2</span>种格式shell、exec格式<span class="token punctuation">(</span>docker build时执行<span class="token punctuation">)</span>EXPOSE：当前容器对外暴漏的端口WORKDIR：指定在创建容器后，终端默认登陆进来的目录，一个落脚点USER：指令该镜像已什么样的用户去执行，默认rootENV：设置环境变量，设置后后面可以使用     eg<span class="token operator">:</span> ENV MY_PATH <span class="token operator">/</span>usr<span class="token operator">/</span>mytest         WORKDIR $MY_PATHADD<span class="token operator">:</span>将宿主机目录下的文件拷贝进镜像，且会自动处理URL和解压tar压缩包<span class="token punctuation">(</span>copy<span class="token operator">+</span>解压<span class="token punctuation">)</span>COPY：类似ADD，将文件拷贝到镜像VOLUME：数据卷CMD：指定容器启动后要做的操作，DockerFile当中可以有多个CMD指令，但是只有最后一个会生效，CMD会被docker run之后的参数替换掉     CMD是在docker run的时候运行     RUN是在docker build的时候运行ENTRYPOINT<span class="token operator">:</span>也是用来指定一个<span class="token operator">*</span><span class="token operator">*</span>容器启动时要执行的指令<span class="token operator">*</span><span class="token operator">*</span>，类似于CMD，但是ENTRYPOINT不会被docker run之后的参数替换掉，而且这些命令行参数会被当中参数传递给ENTRYPOINT指定的程序     ENTRYPOINT<span class="token punctuation">[</span><span class="token string">"exec"</span><span class="token punctuation">,</span><span class="token string">"parm1"</span><span class="token punctuation">,</span><span class="token string">"parm2"</span><span class="token punctuation">]</span>     ENTRYPOINT、CMD可以一起使用，一般变参会使用CMD，这里的CMD相当于给ENTRYPOINT传递参数     eg<span class="token operator">:</span>                    FROM nginx          ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"nginx"</span><span class="token punctuation">,</span><span class="token string">"-c"</span><span class="token punctuation">]</span> # 定参          CMD <span class="token punctuation">[</span><span class="token string">"/etc/ngnix/nginx.conf"</span><span class="token punctuation">]</span>   #变参     <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>》 nginx <span class="token operator">-</span>c <span class="token operator">/</span>etc<span class="token operator">/</span>ngnix<span class="token operator">/</span>nginx<span class="token punctuation">.</span>conf  </code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619175320535.png" alt="image-20220619175320535"></p><p>5、构建DockerFile文件</p><p>1、编写</p><pre class=" language-java"><code class="language-java">FROM java<span class="token operator">:</span><span class="token number">8</span>   # java8作为基础镜像ENV PROJECT_HOME <span class="token operator">/</span>home<span class="token operator">/</span>project  #设置环境变量，设置后后面可以使用ENV FILE_NAME placeholderENV EXPOSE_PORT <span class="token number">8080</span>ENV ACTIVE_ENV devENV JAVA_OPTS <span class="token string">""</span>RUN ln <span class="token operator">-</span>sf <span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>zoneinfo<span class="token operator">/</span>Asia<span class="token operator">/</span>Shanghai <span class="token operator">/</span>etc<span class="token operator">/</span>localtimeRUN echo <span class="token string">'Asia/Shanghai'</span> <span class="token operator">></span><span class="token operator">/</span>etc<span class="token operator">/</span>timezoneRUN apk add <span class="token operator">--</span>update ttf<span class="token operator">-</span>dejavu fontconfig <span class="token operator">&amp;&amp;</span> rm <span class="token operator">-</span>rf <span class="token operator">/</span>var<span class="token operator">/</span>cache<span class="token operator">/</span>apk<span class="token operator">/</span><span class="token operator">*</span>RUN set <span class="token operator">-</span>x <span class="token operator">&amp;&amp;</span> \    mkdir <span class="token operator">-</span>p <span class="token operator">/</span>root<span class="token operator">/</span>logs<span class="token operator">/</span>$FILE_NAME <span class="token operator">&amp;&amp;</span> \    mkdir <span class="token operator">-</span>p $PROJECT_HOMEWORKDIR $PROJECT_HOMEENTRYPOINT <span class="token punctuation">[</span> <span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar $PROJECT_HOME/$FILE_NAME.jar --spring.profiles.active=$ACTIVE_ENV"</span> <span class="token punctuation">]</span>EXPOSE $EXPOSE_PORT</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619181857597.png" alt="image-20220619181857597"></p><p>2、构建</p><pre class=" language-java"><code class="language-java"># 在dockerfile文件下执行下面的指令（注意tag后面有个空格和点）$ docker build <span class="token operator">-</span>t 新镜像的名字：TAG <span class="token punctuation">.</span></code></pre><p>3、运行</p><pre class=" language-java"><code class="language-java">docker run 镜像名  # 测试服务接口是否可用  $ curl  <span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6001</span><span class="token operator">/</span>order<span class="token operator">/</span>test</code></pre><h3 id="七、Docker网络"><a href="#七、Docker网络" class="headerlink" title="七、Docker网络"></a>七、Docker网络</h3><p>docker安装之后会默认创建三个网络</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621003150868.png" alt="image-20220621003150868"></p><pre class=" language-java"><code class="language-java"># 创建网络$ docker network create net1  # 删除网络$ docker network rm net1  # 查看网络源数据$ docker network inspect net1</code></pre><p>1、容器之间的互联通信以及端口映射</p><p>2、容器Ip发生变化时，可以通过服务名直接调用</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621003304909.png" alt="image-20220621003304909"></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619205257295.png" alt="image-20220619205257295"></p><p>Docker容器内部的IP时有可能变化的，所以一般相互通信的服务要设置在同一个网段下面，新建一个网络，它的驱动模式是bridge。</p><h3 id="八、Docker-compose"><a href="#八、Docker-compose" class="headerlink" title="八、Docker-compose"></a>八、Docker-compose</h3><p>用来做容器管理的，相当于一次启动所有容器</p><pre class=" language-java"><code class="language-java">Docker<span class="token operator">-</span>compose使用的流程<span class="token number">1</span>、编写DockerFile文件，定义各个微服务并构建成镜像<span class="token number">2</span>、使用Docker<span class="token operator">-</span>componse定义完整的业务单元<span class="token number">3</span>、使用docker<span class="token operator">-</span>compose up启动</code></pre><p>常用指令</p><pre class=" language-java"><code class="language-java"># 查看帮助$ docker<span class="token operator">-</span>compose <span class="token operator">-</span>h   # 启动服务$ docker<span class="token operator">-</span>compose up   # 后台启动服务$ docker<span class="token operator">-</span>compose up <span class="token operator">-</span>d  # 停止并删除所有容器、网络、卷、镜像$ docker<span class="token operator">-</span>compose down  # 进入容器内部$ docker<span class="token operator">-</span>compose exec yml里面服务的ID <span class="token operator">/</span>bin<span class="token operator">/</span>bash  # 展示所有当前docker<span class="token operator">-</span>compose编排过且运行的容器$ docker<span class="token operator">-</span>compose ps # 展示所有当前docker<span class="token operator">-</span>compose编排过的容器的进程$ docker<span class="token operator">-</span>compose top  # 查看容器的输出日志$ docker<span class="token operator">-</span>compose logs yml里面服务的ID # 检查配置<span class="token punctuation">(</span>检查语法<span class="token punctuation">)</span>$ docker<span class="token operator">-</span>compose config # 检查配置，有问题才输出$ docker<span class="token operator">-</span>compose config <span class="token operator">-</span>q  # 重启$ docker<span class="token operator">-</span>compose restart  # 关闭$ docker<span class="token operator">-</span>compose stop  # 开启$ docker<span class="token operator">-</span>compose start</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>wireshark使用手册</title>
      <link href="/2022/05/11/wireshark-shi-yong-shou-ce/"/>
      <url>/2022/05/11/wireshark-shi-yong-shou-ce/</url>
      
        <content type="html"><![CDATA[<p>这个抓包工具介绍,具体袭击我如下所示</p><p>这是概览，期间能遇到各种报错，只需复制报错信息到网上查找即可。</p><p>1.注册git账号（zhangsan），创建以账号名加.github.io为名的仓库（zhangsan.github.io即为博客地址，输入浏览器即可浏览）</p><p>2.在windows中安装gitbash，安装Nodejs，Nodejs要设置环境变量</p><p>3.下载hexo，将git仓库的ssh地址写入配置文件</p><p>4.windows中生成git的rsa密钥，将id_rsa.pub添加都git账号的ssh key中，一个系统中可以支持多个git密钥的生成，都生成在~&#x2F;.ssh&#x2F;目录下，命名不同即可</p><p>5.hexo常用命令</p><p>hexo new “titename” (生成文章，默认在source&#x2F;_post&#x2F;下，内容以markdown编辑)</p><p>hexo clean(清理旧的生成)</p><p>hexo generation（重新生成页面）</p><p>hexo deploy（部署到git上，部署前，如果</p>]]></content>
      
      
      <categories>
          
          <category> 网络工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makrdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建个人博客</title>
      <link href="/2022/05/06/ru-he-da-jian-ge-ren-bo-ke/"/>
      <url>/2022/05/06/ru-he-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<p>Welcome come to my blog</p><p>这是概览，期间能遇到各种报错，只需复制报错信息到网上查找即可。</p><p>1.注册git账号（zhangsan），创建以账号名加.github.io为名的仓库（zhangsan.github.io即为博客地址，输入浏览器即可浏览）</p><p>2.在windows中安装gitbash，安装Nodejs，Nodejs要设置环境变量</p><p>3.下载hexo，将git仓库的ssh地址写入配置文件</p><p>4.windows中生成git的rsa密钥，将id_rsa.pub添加都git账号的ssh key中，一个系统中可以支持多个git密钥的生成，都生成在~&#x2F;.ssh&#x2F;目录下，命名不同即可</p><p>5.hexo常用命令</p><p>hexo new “titename” (生成文章，默认在source&#x2F;_post&#x2F;下，内容以markdown编辑)</p><p>hexo clean(清理旧的生成)</p><p>hexo generation（重新生成页面）</p><p>hexo deploy（部署到git上，部署前，如果</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/05/hello-world/"/>
      <url>/2022/05/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
