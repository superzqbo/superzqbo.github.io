<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mina基础(一):基础介绍</title>
      <link href="/2022/07/17/mina-ji-chu-yi-ji-chu-jie-shao/"/>
      <url>/2022/07/17/mina-ji-chu-yi-ji-chu-jie-shao/</url>
      
        <content type="html"><![CDATA[<p><strong>1、在应用程序中的地位</strong></p><pre class="language-none"><code class="language-none">主要屏蔽了网络通信的一些细节，对Socket进行封装，并且是NIO的一个实现架构，可以帮助我们快速的开发网络通信，常用于游戏的开发、中间件服务端的程序中。Mina最主要的工作就是把底层传输的字节码转换为Java对象，提供给应用程序；或者把应用程序返回的结果转换为字节码，交给底层传输。</code></pre><p><strong>2、长短链接</strong></p><blockquote><p>长链接和短链接<br>长链接：通信双方长期保持一个链接状态不断开，比如QQ，当我们登陆QQ的时候，就会链接腾讯的服务器建立一个链接，链接一旦建立就一会断开，除非发生异常<br>短链接：通信双方不是保持一个长链接状态，比如http协议，请求数据响应完成之后，链接就会断开</p></blockquote><p><strong>3、IOService接口</strong></p><p>*<strong>实现了对网络通信的客户端和服务端之间的抽象，子接口IOConnector用于描述客户端，子接口IOAcceptor用于描述服务端。*</strong></p><p>  <strong>作用：</strong>IOService可以管理我们网络通信的客户端和服务端，并且可以管理连接双方的会话session，同样可以添加过滤器。</p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220717174143094.png" alt="image-20220717174143094" style="zoom:50%;" /><blockquote><p>IoService接口声明了服务端的共有属性和行为；</p><p>IoAcceptor接口继承了IoService接口，并添加了服务端特有的接口属性及方法，比如bind（）方法，成为典型的服务端接口；</p><p>IoConnector接口同样继承了IoService接口，并添加了客户端特有的接口属性及方法，比如connect（）方法，成为典型的客户端接口；</p><p>AbstractIoService实现了IoService中管理服务的方法，比如getFilterChainBuilder方法—获得过滤器链；</p><p>AbstractIoService抽象类继承了AbstractIoService抽象类并实现了IoAcceptor接口，成为了拥有管理服务端实现功能的服务端类；我们常用的NioSocketAcceptor就是它的子类；</p><p>AbstractIoConnector抽象类继承了AbstractIoService抽象类并实现了IoConnector接口，成为了拥有管理客户端实现功能的客户端类；我们常用的NioSocketConnector就是它的子类；</p></blockquote><p><strong>4、编码解码</strong></p><p>前面提到Mina最主要的工作就是把底层传输的字节码转换为Java对象，提供给应用程序；或者把应用程序返回的结果转换为字节码，交给底层传输。</p><blockquote><p>应用程序         网络<br>java对象或者基本数据类型   二进制</p><p>对象输出到网络———————编码———–&#x3D;—————-&gt;需要编码成二进制</p><p>网络传入的应用程序&lt;—————————解码—————-需要解码成java对象或者基本数据类型</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mina </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
            <tag> 网络通信 </tag>
            
            <tag> 长链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis分页</title>
      <link href="/2022/07/14/mybatis-fen-ye/"/>
      <url>/2022/07/14/mybatis-fen-ye/</url>
      
        <content type="html"><![CDATA[<p>mybatis分页查询</p><pre class="language-none"><code class="language-none">1、分页类定义    package com.techen.tap.vo;import java.io.Serializable;import java.util.Map;import lombok.Getter;import lombok.Setter;&#x2F;** * 分页查询参数 * @author sunmingzhi * @date 2019年11月22日 下午7:23:57   * @Modify *&#x2F;@Getter@Setterpublic class PageQuery implements Serializable &#123;    private static final long serialVersionUID &#x3D; 1L;    &#x2F;&#x2F; 当前页码    private int currentPage;    &#x2F;&#x2F; 每页条数    private int pageSize;    &#x2F;&#x2F; 排序字段    private String sidx;    &#x2F;&#x2F; 顺序    private String sord;    &#x2F;**     * 构造函数     * @Title:Query     * @Description:     * @param params     *&#x2F;    public PageQuery(Map&lt;String, Object&gt; params) &#123;        this.currentPage &#x3D; Integer.parseInt(params.get(&quot;currentPage&quot;).toString());        this.pageSize &#x3D; Integer.parseInt(params.get(&quot;pageSize&quot;).toString());        this.sidx &#x3D; params.get(&quot;sidx&quot;).toString();        this.sord &#x3D; params.get(&quot;sord&quot;).toString();    &#125;&#125;2、分页查询结果package com.techen.tap.vo;import java.io.Serializable;import java.util.List;import lombok.Data;&#x2F;** * @description:分页查询结果 * @author: zs * @date: 2019年8月17日上午9:52:48 * @modify: *&#x2F;@Datapublic class Page implements Serializable &#123;    private static final long serialVersionUID &#x3D; 1L;    &#x2F;&#x2F; 总记录数    private int totalCount;    &#x2F;&#x2F; 每页记录数    private int pageSize;    &#x2F;&#x2F; 总页数    private int totalPage;    &#x2F;&#x2F; 当前页数    private int currentPage;    &#x2F;&#x2F; 列表数据    private List&lt;?&gt; dataList;    public Page(List&lt;?&gt; dataList, int totalCount, int pageSize, int currentPage) &#123;        this.dataList &#x3D; dataList;        this.totalCount &#x3D; totalCount;        this.pageSize &#x3D; pageSize;        this.currentPage &#x3D; currentPage;        this.totalPage &#x3D; (int) Math.ceil((double) totalCount &#x2F; pageSize);    &#125;&#125;3、分页逻辑@GetMapping(value &#x3D; &quot;&#x2F;meterlist&quot;)public ResponseResult&lt;Object&gt; meterlist(@RequestParam(required &#x3D; false) Map&lt;String, Object&gt; paraMap) &#123;    PageQuery query &#x3D; new PageQuery(paraMap);    &#x2F;&#x2F;拼接查询语句---sql语句(拼接前台选择的查询条件)    &#x2F;**    String sqlWhere &#x3D; this.spellListSql(paraMap);    sqlWhere +&#x3D; &quot; and c_meter.run_status_code&lt;&gt;&#39;9&#39;&quot;;    **&#x2F;    paraMap.put(&quot;whereSql&quot;, sqlWhere);    &#x2F;&#x2F;查询符合条件的总数量    int totalCount &#x3D; service.count(paraMap);    List&lt;Map&lt;String, Object&gt;&gt; tempList &#x3D; new ArrayList&lt;Map&lt;String, Object&gt;&gt;();    if (totalCount &gt; 0) &#123;       &#x2F;&#x2F;进行分页查询---查询结果是List       tempList &#x3D; service.queryMapForPage(sqlWhere, query.getCurrentPage(), query.getPageSize(),                                                                           query.getSidx(),query.getSord());       service.setDispFields(tempList);    &#125;    &#x2F;&#x2F;组装分页查询到的分页类    Page page &#x3D; new Page(tempList, totalCount, query.getPageSize(), query.getCurrentPage());    &#x2F;&#x2F;返回分页信息    return ResponseResult.ok(page);&#125;4、分页sql  &lt;select id&#x3D;&quot;queryMapForPage&quot; resultType&#x3D;&quot;com.techen.tap.base.BasicLowerMap&quot; parameterType&#x3D;&quot;map&quot;&gt;        &lt;![CDATA[            SELECT * FROM file_upload_details             WHERE $&#123;whereSql&#125;            order by $&#123;sidx&#125; $&#123;sord&#125;,id asc             &lt;!-- 查询pagesize条语句，从begincount开始 --&gt;            limit #&#123;pagesize&#125; offset #&#123;begincount&#125;          ]]&gt;   &lt;&#x2F;select&gt;    &#x2F;&#x2F;注意  public List&lt;Map&lt;String, Object&gt;&gt; queryMapForPage(String whereSql, int curPageIndex, int pageSize, String                                                                                        sidx, String sord) &#123;    int beginCount &#x3D; curPageIndex * pageSize - pageSize;    Map&lt;String, Object&gt; paraMap &#x3D; new HashMap&lt;String, Object&gt;();    paraMap.put(&quot;begincount&quot;, beginCount);    paraMap.put(&quot;pagesize&quot;, pageSize);    paraMap.put(&quot;whereSql&quot;, whereSql);    paraMap.put(&quot;sidx&quot;, sidx);    paraMap.put(&quot;sord&quot;, sord);    return this.getSqlSessionTemplate().selectList(entityClass.getName() + &quot;.queryMapForPage&quot; , paraMap);&#125;  5、拼接sqlprotected String convertSql(Map&lt;String, Object&gt; paraMap) &#123;        StringBufferProxy sql &#x3D; new StringBufferProxy();        sql.appendSingle(&quot; 1&#x3D;1 &quot;);        if (paraMap.containsKey(&quot;file_name&quot;) &amp;&amp; !StringUtils.isEmpty(paraMap.get(&quot;file_name&quot;))) &#123;            String value &#x3D; paraMap.get(&quot;file_name&quot;).toString();            if (!StringUtil.isEmpty(value)) &#123;                sql.appendSingle(&quot; and file_name like &#39;%&#123;0&#125;%&#39; &quot;, value);            &#125;        &#125;        if (paraMap.containsKey(&quot;data_date&quot;) &amp;&amp; !StringUtils.isEmpty(paraMap.get(&quot;data_date&quot;))) &#123;            String value &#x3D; paraMap.get(&quot;data_date&quot;).toString();            String getLastDayOfMonth&#x3D;DateUtil.getLastDayOfMonth(value);            String date1&#x3D;value+&quot; 00:00:00&quot;;            String date2&#x3D;getLastDayOfMonth+&quot; 00:00:00&quot;;            if (!StringUtil.isEmpty(value)) &#123;                sql.appendSingle(&quot; and createon between &#39;&#123;0&#125;&#39; and &#39;&#123;1&#125;&#39;&quot;, date1, date2);            &#125;        &#125;        if (paraMap.containsKey(&quot;createuser&quot;) &amp;&amp; !StringUtils.isEmpty(paraMap.get(&quot;createuser&quot;))) &#123;            String createuser &#x3D; paraMap.get(&quot;createuser&quot;).toString();            List&lt;CboUser&gt; cboUsers &#x3D; cboUserService.queryByWhere(&quot; cbo_user.name like &#39;%&quot; + createuser + &quot;%&#39;&quot;);            Long[] idArray &#x3D; new Long[cboUsers.size()];            for (int i &#x3D; 0; i &lt; cboUsers.size(); i++) &#123;                idArray[i] &#x3D; cboUsers.get(i).getId();            &#125;            String substring &#x3D; Arrays.toString(idArray);            substring &#x3D; substring.substring(1, substring.length() - 1);            sql.appendSingle(&quot; and createuser  in (&quot; + substring + &quot;)&quot;);        &#125;        if (paraMap.containsKey(&quot;upload_status&quot;)) &#123;            String value &#x3D; paraMap.get(&quot;upload_status&quot;).toString();            if (!StringUtil.isEmpty(value)) &#123;                sql.appendSingle(&quot; and upload_status &#x3D; &#39;&#123;0&#125;&#39;&quot;, value);            &#125;        &#125;        return sql.toString();    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows下查找java应用内存情况分析</title>
      <link href="/2022/07/14/windows-xia-cha-zhao-java-ying-yong-nei-cun-qing-kuang-fen-xi/"/>
      <url>/2022/07/14/windows-xia-cha-zhao-java-ying-yong-nei-cun-qing-kuang-fen-xi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_14996421/article/details/115726673?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-115726673-blog-105843937.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/qq_14996421/article/details/115726673?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-115726673-blog-105843937.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p><p>在65服务器上查看各java应用的内存占用情况，大多数应用的CPU占用都在1%-5%之间，但是nb-hes的内存占用长期达到了13%左右，遂开始排查nb-hes占用内存过分高的原因，具体步奏如下。</p><h2 id="一、JConsole"><a href="#一、JConsole" class="headerlink" title="一、JConsole"></a>一、JConsole</h2><p>排查65服务器上个java应用的内存占用情况</p><p>JConsole是JDK自带的一个工具，也是 一个图形界面的工具，只要装了JDK就有这个工具；可以直接在服务器上连接本地的java进程，也可以从本机去跟踪远程服务器上的一个进程，如下图所示：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615194250948.png" alt="image-20220615194250948"></p><p>点击连接即可</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615194903776.png" alt="image-20220615194903776"></p><p>确认连接</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615195009791.png" alt="image-20220615195009791"></p><p>服务器上面的基本情况如下：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615195315959.png" alt="image-20220615195315959"></p><p>可以看到CPU占用比较高</p><h2 id="二、使用任务管理器查询应用所在详情-PID、安装位置"><a href="#二、使用任务管理器查询应用所在详情-PID、安装位置" class="headerlink" title="二、使用任务管理器查询应用所在详情(PID、安装位置)"></a>二、使用任务管理器查询应用所在详情(PID、安装位置)</h2><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615200142459.png" alt="image-20220615200142459"></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615200343473.png" alt="image-20220615200343473"></p><h2 id="三、使用Jstack下载stack信息到某个位置"><a href="#三、使用Jstack下载stack信息到某个位置" class="headerlink" title="三、使用Jstack下载stack信息到某个位置"></a>三、使用Jstack下载stack信息到某个位置</h2><p>使用Jstack将第二步查询到的PID对应的应用的stack信息下载下来</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615195812485.png" alt="image-20220615195812485"></p><h2 id="四、-Process-Explorer"><a href="#四、-Process-Explorer" class="headerlink" title="四、 Process Explorer"></a>四、 Process Explorer</h2><p>用的是微软提供的 Process Explorer工具，排查上一步查询的进程当中，那个线程所占用的内存最多。</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615201109069.png" alt="image-20220615201109069"></p><h2 id="五、找到占用内存多的那段代码"><a href="#五、找到占用内存多的那段代码" class="headerlink" title="五、找到占用内存多的那段代码"></a>五、找到占用内存多的那段代码</h2><p>由于stack导出的信息里面线程对应的tid是16进制的，所以要把前面的线程的TID转成16进制的，再在stack导出的文件当中全局搜索该PID(9726—&gt;25FC)</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615201211363.png" alt="image-20220615201211363"></p><h2 id="六、分析"><a href="#六、分析" class="headerlink" title="六、分析"></a>六、分析</h2><p>在代码当中查找该段代码，发现是由于引入的第三方的这个Jar包里面写了一个死循环，去一直监听设备的上线下</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615201654127.png" alt="image-20220615201654127"></p><p>为了验证是否是死循环引起的，现在修改代码不做成死循环</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220616093046466.png" alt="image-20220616093046466"></p><p>打包后重新运行程序，再次测试内存占比，情况如下</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220702135156318.png" alt="image-20220702135156318"></p><p>由此确定，确实是由于这段代码引起的！</p>]]></content>
      
      
      <categories>
          
          <category> 内存分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存分析 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSql数组及JSON类型数据在Mybatis项目中的使用</title>
      <link href="/2022/07/12/postgresql-shu-zu-ji-json-lei-xing-shu-ju-zai-mybatis-xiang-mu-zhong-de-shi-yong/"/>
      <url>/2022/07/12/postgresql-shu-zu-ji-json-lei-xing-shu-ju-zai-mybatis-xiang-mu-zhong-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>postgresql提供了很多数据类型，某些特殊的类型无法同java数据类型映射。Mybatis提供了一些默认的TypeHandler，但不包含诸如数组、json这些类型在内。为了使用pgsql的这些类型，我们可以自己添加一些特定的typehandler，注册后就可以标注使用了。</p><p><strong>基本操作流程如下：</strong></p><pre class="language-java" data-language="java"><code class="language-java">1、定义实体类，继承BaseTypeHandler  2、在映射文件当中指明typeHandler是这个实体类  3、字符赋值为JSONObject类型</code></pre><p><strong>实体类代码块：</strong></p><pre class="language-java" data-language="java"><code class="language-java">package com.techen.ami.hes.jobserver.entity;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import com.alibaba.fastjson.JSON;import org.apache.ibatis.type.BaseTypeHandler;import org.apache.ibatis.type.JdbcType;import org.postgresql.util.PGobject;&#x2F;** * @description: postgresql提供了很多数据类型，某些特殊的类型无法同java数据类型映射。Mybatis提供了一些默认的TypeHandler，但不包含诸如数组、json这些类型在内。为了使用pgsql的这些类型，我们可以自己添加一些特定的typehandler，注册后就可以标注使用了。 * @author: bozhiqiang * @updateTime: 2022&#x2F;7&#x2F;12 17:07 * @Param:  * @return:  * @throw: *&#x2F;public class JsonTypeHandler extends BaseTypeHandler&lt;Object&gt; &#123;    private static final PGobject pgObject &#x3D; new PGobject();    @Override    public Object getNullableResult(ResultSet resultSet, String columnLabel) throws SQLException &#123;        return resultSet.getString(columnLabel);    &#125;    @Override    public Object getNullableResult(ResultSet resultSet, int columnIndex) throws SQLException &#123;        return resultSet.getString(columnIndex);    &#125;    @Override    public Object getNullableResult(CallableStatement callableStatement, int parameterIndex) throws SQLException &#123;        return callableStatement.getString(parameterIndex);    &#125;    @Override    public void setNonNullParameter(PreparedStatement preparedStatement, int i, Object object, JdbcType jdbcType) throws SQLException &#123;        pgObject.setType(&quot;json&quot;);        pgObject.setValue(JSON.toJSONString(object));        preparedStatement.setObject(i, pgObject);    &#125;&#125;</code></pre><p><strong>JSONObject类型数据</strong></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220712214436903.png" alt="image-20220712214436903"></p><p><strong>映射文件</strong></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220712214502296.png" alt="image-20220712214502296"></p>]]></content>
      
      
      <categories>
          
          <category> PostgreSQL </category>
          
          <category> JSON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo部署到服务器</title>
      <link href="/2022/07/10/hexo-bu-shu-dao-fu-wu-qi/"/>
      <url>/2022/07/10/hexo-bu-shu-dao-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、服务器配置"><a href="#一、服务器配置" class="headerlink" title="一、服务器配置"></a>一、服务器配置</h2><h3 id="1-1-新建用户作为git登陆用户"><a href="#1-1-新建用户作为git登陆用户" class="headerlink" title="1.1 新建用户作为git登陆用户"></a>1.1 新建用户作为git登陆用户</h3><pre class="language-markup" data-language="markup"><code class="language-markup">[root@VM-12-10-centos superzqbo]# sudo adduser git[root@VM-12-10-centos superzqbo]# sudo passwd git更改用户 git 的密码 。新的 密码：重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。</code></pre><h3 id="1-2-修改新建用户的权限为git权限"><a href="#1-2-修改新建用户的权限为git权限" class="headerlink" title="1.2 修改新建用户的权限为git权限"></a>1.2 修改新建用户的权限为git权限</h3><p>现在这个用户是具备 SSH 权限的，我们需将其切换为仅具有 git 权限。</p><pre class="language-markup" data-language="markup"><code class="language-markup">$ vi /etc/passwd# git:x:1001:1001::/home/git:/bin/bash 修改为下面的$ git:x:1001:1001::/home/git:/bin/git-shell</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220707235803442.png" alt="image-20220707235803442"></p><h3 id="1-3-安装git"><a href="#1-3-安装git" class="headerlink" title="1.3 安装git"></a>1.3 安装git</h3><pre class="language-markup" data-language="markup"><code class="language-markup">[root@VM-12-10-centos superzqbo]# sudo yum install -y git</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220707210450899.png" alt="image-20220707210450899"></p><h3 id="1-4-生成git密钥"><a href="#1-4-生成git密钥" class="headerlink" title="1.4 生成git密钥"></a>1.4 生成git密钥</h3><p><code>ssh</code>，简单来讲，就是一个秘钥，其中，<code>id_rsa</code>是你这台电脑的私人秘钥，不能给别人看的，<code>id_rsa.pub</code>是公共秘钥，可以随便给别人看。把这个公钥放在<code>git仓库</code>上，这样当你链接<code>git仓库</code>自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过<code>git</code>上传你的文件到<code>git仓库</code>上。</p><p>如果有生成过git密钥，直接去~&#x2F;.ssh&#x2F;目录下查找即可，该目录下有两个文件</p><pre class="language-markup" data-language="markup"><code class="language-markup">公钥：id_rsa.pub私钥：id_rsa</code></pre><p>如果之前没有生成过，就需要使用下面指令生成一个</p><pre class="language-markup" data-language="markup"><code class="language-markup">ssh-keygen -t rsa -C "superzqbo@163.com"</code></pre><h3 id="1-5-将密钥保存在服务器"><a href="#1-5-将密钥保存在服务器" class="headerlink" title="1.5 将密钥保存在服务器"></a>1.5 将密钥保存在服务器</h3><pre class="language-markup" data-language="markup"><code class="language-markup">1、服务器运行下面命令，创建.ssh文件夹$ su git$ mkdir ~/.ssh2、创建.ssh/authorized_keys文件，打开authorized_keys文件并将id_rsa.pub的内容复制拷贝其中并保存$ vim ~/.ssh/authorized_keys3、修改权限$ chmod 755 ~$ chmod 700 ~/.ssh$ chmod 600 ~/.ssh/authorized_keys4、测试本地连接服务器（git bash here）,连接成功表示本地和服务器连接时ok的$ ssh -v git@42.194.221.71</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220707214208446.png" alt="image-20220707214208446"></p><h3 id="1-6-创建git仓库"><a href="#1-6-创建git仓库" class="headerlink" title="1.6 创建git仓库"></a>1.6 创建git仓库</h3><pre class="language-markup" data-language="markup"><code class="language-markup">1、切换到root用户，创建一个目录用于存储网站的根目录$ su root2、创建网站的根目录$ mkdir /home/superzqbo/git/hexo$ cd /home/superzqbo/git3、修改用户所有权和用户权限（将当前目录下，所有文件的拥有者修改为git，用户组改为 git）$ chown -R  git:git  hexo$ chown -R 755 hexo$ cd hexo4、创建一个git项目（这里有一个细节，就是.git目录必须要有可读写权限，因为当我们在push的时候，是使用git用户推送到服务器上面去，会有一个写入的过程，如果不赋予可写权限，push就会失败。git目录，用于存储记录版本信息）$ git init --bare hexo.git5、新建git 钩子 post-receive，方便博客推送自动部署(相当于拷贝一份到Ngnix的html当中)$ vim hexo.git/hooks/post-receive# 输入下面的数据#!/bin/shgit --work-tree=/home/superzqbo/hexo --git-dir=/home/superzqbo/git/hexo/hexo.git checkout -f6、赋予这个文件可执行权限chmod +x /home/superzqbo/git/hexo/hexo.git/hooks/post-receive</code></pre><p><strong>钩子函数解析</strong></p><pre class="language-java" data-language="java"><code class="language-java">git --work-tree&#x3D;&#x2F;home&#x2F;superzqbo&#x2F;hexo --git-dir&#x3D;&#x2F;home&#x2F;superzqbo&#x2F;git&#x2F;hexo&#x2F;hexo.git checkout -f# --work-tree&#x3D;&#x2F;home&#x2F;superzqbo&#x2F;hexo 指定hexo文件的位置(ngnix的根目录)    # --git-dir&#x3D;&#x2F;home&#x2F;superzqbo&#x2F;git&#x2F;hexo&#x2F;hexo.git git仓库的地址</code></pre><p>此时，使用客户端上传代码后，除了在仓库下还会在<code>/home/superzqbo/hexo</code>目录下生成上传的代码，Nginx当中指定地址是这个即可。</p><h2 id="二、客户端配置"><a href="#二、客户端配置" class="headerlink" title="二、客户端配置"></a>二、客户端配置</h2><h3 id="2-1-配置"><a href="#2-1-配置" class="headerlink" title="2.1 配置"></a>2.1 配置</h3><p>博客根目录_config下增加</p><pre class="language-java" data-language="java"><code class="language-java">root: &#x2F;deploy:  type: git     # 用户@服务器地址:git仓库地址  repository: git@42.194.221.71:&#x2F;home&#x2F;superzqbo&#x2F;git&#x2F;hexo&#x2F;hexo.git  branch: master</code></pre><h3 id="2-2-部署"><a href="#2-2-部署" class="headerlink" title="2.2 部署"></a>2.2 部署</h3><pre class="language-text" data-language="text"><code class="language-text">hexo cleanhexo ghexo d</code></pre><h3 id="2-3-Nginx配置"><a href="#2-3-Nginx配置" class="headerlink" title="2.3 Nginx配置"></a>2.3 Nginx配置</h3><p>参考地址：<a href="https://www.yyyzyyyz.cn/posts/45dafe31d273/">https://www.yyyzyyyz.cn/posts/45dafe31d273/</a></p><pre class="language-java" data-language="java"><code class="language-java"># 安装$ yum install -y nginx# 查看Nginx配置文件的位置$ whereis nginx  # 设置开机自启$ systemctl enable nginx.service  # 检查配置文件$ nginx -t</code></pre><p><strong>配置nginx为服务(Systemd服务)</strong></p><pre class="language-java" data-language="java"><code class="language-java">vim &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service--------------------------------------------------------  [Unit]Description&#x3D;nginxAfter&#x3D;network.target  [Service]Type&#x3D;forkingExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginxExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reloadExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s quitPrivateTmp&#x3D; true  [Install]WantedBy&#x3D;multi-user.target  --------------------------------------------------------  [Unit]:服务的说明Description:描述服务After:描述服务类别[Service]服务运行参数的设置Type&#x3D;forking是后台运行的形式ExecStart为服务的具体运行命令ExecReload为重启命令ExecStop为停止命令PrivateTmp&#x3D;True表示给服务分配独立的临时空间注意：[Service]的启动、重启、停止命令全部要求使用绝对路径[Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3</code></pre><p><strong>配置如下</strong></p><pre class="language-markup" data-language="markup"><code class="language-markup">server &#123;  listen       80 default_server;  listen       [::]:80 default_server;  server_name  42.194.221.71;  root         /home/superzqbo/hexo;// 代码地址  charset koi8-r;  # access_log  /var/log/nginx/host.access.log  main;  location / &#123;  &#125;  error_page  404              /404.html;  location = /40x.html &#123;  &#125;  # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;  location = /50x.html &#123;    root   html;  &#125;  # proxy the PHP scripts to Apache listening on 127.0.0.1:80    #    #location ~ \.php$ &#123;    #    proxy_pass   http://127.0.0.1;    #&#125;  # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    #    #location ~ \.php$ &#123;    #    root           html;    #    fastcgi_pass   127.0.0.1:9000;    #    fastcgi_index  index.php;    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;    #    include        fastcgi_params;    #&#125;  # deny access to .htaccess files, if Apache's document root    # concurs with nginx's one    #    #location ~ /\.ht &#123;    #    deny  all;    #&#125;&#125;</code></pre><h2 id="三、Https配置"><a href="#三、Https配置" class="headerlink" title="三、Https配置"></a>三、Https配置</h2><p>参考地址： <a href="https://www.freesion.com/article/16501347598/">https://www.freesion.com/article/16501347598/</a></p><p>步奏如下</p><pre class="language-java" data-language="java"><code class="language-java">1、首先我们要拥有一个域名。本文使用的是腾讯云注册的域名。接着申请免费的SSL域名证书。  2、腾讯云首页登录后搜索SSL（其他网站类似），申请SSL证书，一般申请过程会在4小时以内给出结果  3、SSL证书申请成功之后，将其文件点击下载到本地上。这里我们使用的是Nginx证书  4、在服务器Nginx配置文件同级目录创建一个conf目录，将Nginx证书上传到该目录下  5、修改Nginx配置文件</code></pre><pre class="language-markup" data-language="markup"><code class="language-markup"># HTTPS server#server &#123;    #SSL 访问端口号为 443    listen       443 ssl;    #填写绑定证书的域名    server_name  www.superbo.cloud;    #证书文件名称    ssl_certificate      /usr/local/nginx/conf/conf/superbo.cloud_bundle.pem;    #私钥文件名称    ssl_certificate_key  /usr/local/nginx/conf/conf/superbo.cloud.key;    ssl_session_cache    shared:SSL:1m;    ssl_session_timeout  5m;    #请按照以下协议配置    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;    ssl_prefer_server_ciphers  on;    root         /home/superzqbo/hexo;    location / &#123;    &#125;&#125;server &#123;    listen 80;    #填写绑定证书的域名    server_name www.superbo.cloud;    #把http的域名请求转成https    return 301 https://$host$request_uri;&#125;</code></pre><p>注意，如果网站想要正常访问，还需要进行备案！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket通信</title>
      <link href="/2022/07/06/socket-tong-xin/"/>
      <url>/2022/07/06/socket-tong-xin/</url>
      
        <content type="html"><![CDATA[<h3 id="一、数据通信过程"><a href="#一、数据通信过程" class="headerlink" title="一、数据通信过程"></a>一、数据通信过程</h3><p><strong>一个数据包经由应用程序产生，进入到协议栈中进行各种报文头的包装，然后操作系统调用网卡驱动程序指挥硬件，把数据发送到对端主机</strong>。整个过程的大体的图示如下。</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220706142933670.png" alt="image-20220706142933670"></p><p>协议栈其实是位于操作系统中的一些协议的堆叠，这些协议包括 TCP、UDP、ARP、ICMP、IP等。</p><pre class="language-java" data-language="java"><code class="language-java">通常某个协议的设计都是为了解决某些问题，比如TCP 的设计就负责安全可靠的传输数据，UDP 设计就是报文小，传输效率高，ARP 的设计是能够通过 IP 地址查询物理（Mac）地址，ICMP 的设计目的是返回错误报文给主机，IP 设计的目的是为了实现大规模主机的互联互通。    </code></pre><p><strong>一般处于协议上层的是TCP、UDP协议，IP协议处于下层，这个从TCP&#x2F;IP四层协议当也可以看得到，IP协议是不可靠的，需要为上层的TCP协议提供通信支持，TCP协议是可靠的，因为有三次握手四次挥手。</strong></p><p>应用程序比如浏览器、电子邮件、文件传输服务器等产生的数据，会通过传输层协议进行传输，而应用程序是不会和传输层直接建立联系的，而是有一个能够连接应用层和传输层之间的套件，这个套件就是 <code>Socket</code>。</p><p>应用程序的下面就是操作系统内部，操作系统内部包括协议栈，协议栈是一系列协议的堆叠。操作系统下面就是网卡驱动程序，网卡驱动程序负责控制网卡硬件，驱动程序驱动网卡硬件完成收发工作.</p><h3 id="二、通过netstat-命令来展示套接字"><a href="#二、通过netstat-命令来展示套接字" class="headerlink" title="二、通过netstat 命令来展示套接字"></a>二、通过netstat 命令来展示套接字</h3><pre class="language-java" data-language="java"><code class="language-java">netstat -ano # netstat 用于显示套接字内容 , -ano 是可选选项# a 不仅显示正在通信的套接字，还显示包括尚未开始通信等状态的所有套接字# n 显示 IP 地址和端口号# o 显示套接字的程序 PID</code></pre><p><img src="https://pic3.zhimg.com/v2-a5b445147b1f4a683500901d35704662_r.jpg" alt="preview"></p><p>图中的每一行都相当于一个套接字，每一列也被称为一个元组，所以一个套接字就是五元组（协议、本地地址、外部地址、状态、PID）。有的时候也被叫做四元组，四元组不包括协议。</p><p>比如图中的第一行，它的协议就是 TCP，本地地址和远程地址都是 0.0.0.0，这表示通信还没有开始，IP 地址暂时还未确定，而本地端口已知是 135，但是远程端口还未知，此时的状态是 <code>LISTENING</code>，LISTENING 表示应用程序已经打开，正在等待与远程主机建立连接最后一个元组是 PID，即进程标识符，PID 就像我们的身份证号码，能够精确定位唯一的进程。</p><h3 id="三、OSI七层协议模型-open-system-interconnection"><a href="#三、OSI七层协议模型-open-system-interconnection" class="headerlink" title="三、OSI七层协议模型 (open system interconnection)"></a>三、OSI七层协议模型 (open system interconnection)</h3><pre class="language-java" data-language="java"><code class="language-java">应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等表示层：处理数据格式，数据加密等会话层：建立、维护和管理会话传输层：TCP，UDP网络层：IP，ICMP，OSPF，EIGRP，IGMP数据链路层：SLIP，CSLIP，PPP，MTU物理层：比特流传输</code></pre><p>每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220706135944058.png" alt="image-20220706135944058"></p><p>通过上面的图形，由于底一层的需要向高一层的提供服务，我们大致的理解<strong>应用程序需要传输层的tcp和网络层的ip协议提供服务</strong>，可以说，TPC&#x2F;IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。</p><h3 id="四、Socket"><a href="#四、Socket" class="headerlink" title="四、Socket"></a>四、Socket</h3><p><strong>Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口，Socket是对TCP&#x2F;IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP&#x2F;IP协议。</strong></p><h4 id="3-1-Socket创建"><a href="#3-1-Socket创建" class="headerlink" title="3.1 Socket创建"></a>3.1 Socket创建</h4><p>Socket 是和应用程序一起创建的。</p><pre class="language-java" data-language="java"><code class="language-java">1、应用程序中有一个 socket 组件，在应用程序启动时，会调用 socket 申请创建套接字，协议栈会根据应用程序的申请创建套接字：2、首先分配一个套接字所需的内存空间，这一步相当于是为控制信息准备一个容器，但只有容器并没有实际作用，所以你还需要向容器中放入控制信息；3、如果你不申请创建套接字所需要的内存空间，你创建的控制信息也没有地方存放，所以分配内存空间，放入控制信息缺一不可。至此套接字的创建就已经完成了。4、套接字创建完成后，会返回一个套接字描述符给应用程序，这个描述符相当于是区分不同套接字的号码牌。根据这个描述符，应用程序在委托协议栈收发数据时就需要提供这个描述符。</code></pre><h4 id="3-2-套接字连接"><a href="#3-2-套接字连接" class="headerlink" title="3.2 套接字连接"></a>3.2 套接字连接</h4><p>套接字创建完成后，最终还是为数据收发服务的，在数据收发之前，还需要进行一步 <code>connect</code>，也就是建立连接的过程。应用程序通过 TCP&#x2F;IP 协议标准从一个主机通过网络介质传输到另一个主机的过程。</p><pre class="language-java" data-language="java"><code class="language-java">1、套接字刚刚创建完成后，还没有数据，也不知道通信对象。在这种状态下，即使你让客户端应用程序委托协议栈发送数据，它也不知道发送到哪里。    2、所以浏览器需要根据网址来查询服务器的 IP 地址，做这项工作的协议是 DNS，查询到目标主机后，再把目标主机的 IP 告诉协议栈，至此，客户端这边就准备好了    3、在服务器上，与客户端一样也需要创建套接字，但是同样的它也不知道通信对象是谁，所以我们需要让客户端向服务器告知客户端的必要信息：IP 地址和端口号。    4、通信双方收到数据之后，还需要一块位置来存放，这个位置就是缓冲区，它是内存的一部分，有了缓冲区，就能够进行数据的收发操作了。</code></pre><p>具体实现</p><p>客户端应用程序需要调用 <code>Socket</code> 库中的 connect 方法，提供 socket 描述符和服务器 IP 地址、端口号。</p><p>这些信息会传递给协议栈中的 TCP 模块，TCP 模块会对请求报文进行封装，再传递给 IP 模块，进行 IP 报文头的封装，然后传递给物理层，进行帧头封装，之后通过网络介质传递给服务器，服务器上会对帧头、IP 模块、TCP 模块的报文头进行解析，从而找到对应的套接字，套接字收到请求后，会写入相应的信息，并且把状态改为正在连接。请求过程完成后，服务器的 TCP 模块会返回响应，这个过程和客户端是一样的。</p><h3 id="四、TCP-x2F-IP、Socket、Http的区别"><a href="#四、TCP-x2F-IP、Socket、Http的区别" class="headerlink" title="四、TCP&#x2F;IP、Socket、Http的区别"></a>四、TCP&#x2F;IP、Socket、Http的区别</h3><p>http是要基于TCP连接基础上的，简单的说，TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。客户端和应用服务器建立TCP连接之后，就需要用http协议来传送数据了，HTTP协议简单来说，还是请求，确认，连接。 总体就是C发送一个HTTP请求给S，S收到了这个http请求，然后返回给Chttp响应，然后C的中间件或者说浏览器把这些数据渲染成为了网页，展示在用户面前。</p><pre class="language-java" data-language="java"><code class="language-java">1.socket是通信的基石，是TCP&#x2F;IP的基本操作单元（最小单位），可以理解为TCP&#x2F;IP的封装，调用接口,(所有的程序都是默认调用吗？)    2.应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务(所有应用层都一样？)    3.HTTP等应用层协议，格式的统一（像串口协议一样，格式和速度）    4.Http是基于TCP协议的，tcp计算机通信传数据，但是无法解析数据，解析需要http协议</code></pre><p>http是网络上层协议。底层还是socket短连接是发送数据时进行联接。发送完关闭(http基于短连接的tcp协议)；可以认为不论应用层协议使用的是什么，都是通过调用Socket(对传输层的封装)去进行数据传输的。</p><p>具体应用层使用什么协议，需要按照实际需求去进行操作，比如短连接则可以通过http请求实现；长链接可以使用调用Socket去实现。</p><pre class="language-java" data-language="java"><code class="language-java">长连接：通信双方长期的保持一个连接状态不断开，一旦建立连接后，就不断开，除非发生异常，比较消耗IO资源。短连接：通信双方不是保持一个长期的连接状态，比如Http协议，当客户端发起http请求，服务器处理http请求，当服务器处理完成后，返回客户端数据后就断开链接。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Mina </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="/2022/07/03/docker-xue-xi-bi-ji/"/>
      <url>/2022/07/03/docker-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>Docker是基于go开发的</p><h3 id="一、为什么使用docker"><a href="#一、为什么使用docker" class="headerlink" title="一、为什么使用docker"></a>一、为什么使用docker</h3><p>带着环境安装到Docker上，解决环境问题；解决了集群问题</p><p>镜像：将代码，Redis、、、等环境打包成一个镜像，在其他地方可以直接运行，无需在重新安装软件、代码；将正确的环境打包成镜像，直接运行，理念是一次打包处处运行，”一次封装，处处运行”</p><p>只需要一次配置好环境，换到其他的机子上就可以一键运行，大大简化了操作</p><p>四个集装箱（部署四个软件），各自独立，放到一个镜像当中，运行镜像即可</p><h3 id="二、Docker三要素：仓库、镜像、容器"><a href="#二、Docker三要素：仓库、镜像、容器" class="headerlink" title="二、Docker三要素：仓库、镜像、容器"></a>二、Docker三要素：仓库、镜像、容器</h3><p>容器：集装箱就是一个容器，每一个容器当中安装我们要需要的软件，Docker就是鲸鱼，背上有几个集装箱就有几个容器</p><p>虚拟机：模拟的是整套操作系统（模拟的操作系统、软硬件—虚拟硬件，然后在硬件上虚拟软件操作系统），但是启动时间时分钟级别的，Docker启动时秒级别的；</p><p>Docker模拟的是操作系统，直接运行在宿主机上的（没有进行硬件虚拟），没有虚拟自己的内核，用的是宿主机的，所以启动快；容器之间是相互隔离的，每个容器由自己的文件系统，容器之间进程不会相互影响，能区分计算资源</p><p>运行环境的打包封装，这饿环境的一个整体就是镜像，DockerHub上就是存镜像的，</p><p>从仓库拉一个应用到本地就是镜像（Image）,某一个镜像的实例就是一个集装箱容器，各自独立的容器就是一个一个的环境(Redis、Ngnix)</p><h4 id="1、镜像"><a href="#1、镜像" class="headerlink" title="1、镜像"></a>1、镜像</h4><p>镜像(Image)：Docker镜像就是一个只读的模版，镜像可以用来创建Docker容器，一个镜像可以创建很多容器—类</p><h4 id="2、容器"><a href="#2、容器" class="headerlink" title="2、容器"></a>2、容器</h4><p>容器(Container)：镜像的实例—对象，Docker利用容器运行一个或一组应用，容器是用镜像创建的运行实例，可以对容器进行启动、开始、停止、删除；每个容器都是相互隔离的、保证安全的平台</p><p>可以吧容器看成是一个简易版本的Linux环境(包括root用户权限、进程空间、用户空间、网络空间等)和运行在其中的程序</p><p>容器的定义和镜像几乎一摸一样，也是一堆层的统一视角，唯一的区别是，容器的最上面那一层是可读可写的</p><p>容器是一个运行时环境，可以看成是鲸鱼上一个个的集装箱。</p><h4 id="3、仓库"><a href="#3、仓库" class="headerlink" title="3、仓库"></a>3、仓库</h4><p>仓库(Repository)：仓库是存放镜像文件的场所,仓库和仓库注册服务器是有区别的，仓库注册服务器上面存放着多个仓库，每个仓库又包含多个镜像，每个镜像又不同的标签(tag)</p><p>仓库分为公共仓库(public)和私有仓库(private)2种，最大的公共仓库是Docker Hub(<a href="https://hub.docker.com)---在国外,特别慢,存放了数量庞大的镜像供用户下载,国内的公共开源镜像又阿里云、网易云等/">https://hub.docker.com)---在国外，特别慢，存放了数量庞大的镜像供用户下载，国内的公共开源镜像又阿里云、网易云等</a></p><p>Docker本身是一个容器运行载体，或者称之为管理引擎，我们把应用程序和配置文件打包成包，形成一个可交付的运行环境，这个打包好的运行环境就似乎是一个镜像，只有通过镜像才可以生成Docker容器</p><p>镜像可以看成是容器的模版，Docker根据Image文件生成容器的实例，同一个镜像文件，可以生成多个同时运行的容器实例。</p><p>镜像文件生成的容器实例，本身也是一个文件，称为镜像文件</p><p>一个容器运行一种服务，当我们需要的时候，就可以通过Docker客户端创建一个对应的运行实例，也就是我们的容器</p><p>至于仓库，也就是存放镜像的地方，我们可以吧镜像发布到仓库中，需要的时候从仓库中拉下来救可以啦</p><p>平台架构图如下所示：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220618162307428.png" alt="image-20220618162307428"></p><h3 id="三、指令"><a href="#三、指令" class="headerlink" title="三、指令"></a>三、指令</h3><p>1、docker相关–帮助启动类命令</p><pre class="language-java" data-language="java"><code class="language-java"># 启动$ systemctl start docker  # 停止$ systemctl stop docker  # 重启$ systemctl restart docker  # 查看状态$ systemctl status docker  # 开机自启$ systemctl enable docker  # docker信息$ docker info  # 帮助$ docker --help  # 具体帮助$ docker  具体指令 --help</code></pre><p>2、镜像</p><pre class="language-jav" data-language="jav"><code class="language-jav"># 查看所有镜像$ docker images# 查看远程镜像$ docker search 镜像名# 下载镜像$ docker pull 镜像名# 查看 镜像&#x2F;容器&#x2F;数据卷所占用的内存空间$ docker system df# 删除镜像$ docker rmi 镜像名# 强制删除镜像$ docker rmi -f 镜像名</code></pre><p>虚悬镜像：仓库名和tag都是空的镜像，一般是由于构建镜像的时候出问题导致的，这种镜像删除就好了</p><p>3、容器</p><pre class="language-java" data-language="java"><code class="language-java"># 运行ubunto:latest镜像，并开启交互式模式启动一个容器，在容器内部执行&#x2F;bin&#x2F;sh指令，推出使用exec；$ docker run -it ubunto &#x2F;bin&#x2F;sh# 给容器起名字$ docker run -it --name&#x3D;&quot;myubunto&quot; ubunto &#x2F;bin&#x2F;sh# 后台方式启动容器$ docker run -d --name&#x3D;&quot;myubunto&quot; ubunto # 列出所有正在运行的容器$ docker ps# 列出所有正在运行&#x2F;历史运行的容器包括挂了的容器）$ docker ps -a# 列出最近创建的容器（包括挂了的容器）$ docker ps -l# 列出最近创建的3个容器（包括挂了的容器）$ docker ps -n 3    # 退出容器--容器关闭$ exec# 退出容器--容器不关闭$ ctrl+p+q  # 启动已经停止运行的容器$ docker start 容器ID&#x2F;名字  # 重启容器$ docker restart 容器ID&#x2F;名字    # 关闭容器$ docker stop 容器ID&#x2F;名字   # 强制停止容器$ docker kill 容器ID&#x2F;名字     # 删除已停止的容器$ docker rm 容器ID&#x2F;名字       # 查看容器运行日志$ docker logs 容器ID  # 查看容器内部运行的进程$ docker top 容器ID  # 查看容器内部情况$ docker inspect 容器ID  </code></pre><p>exec和attach的区别</p><pre class="language-java" data-language="java"><code class="language-java"># 使用exit退出不会关闭容器(一般进入容器当中查看信息)docker exec -it 容器ID  &#x2F;bin&#x2F;sh # 使用exit退出会关闭容器docker attach 容器ID </code></pre><p>从镜像的角度看，可以把容器看成是简易版本的Linux环境，</p><pre class="language-java" data-language="java"><code class="language-java"># 将容器内的内容拷贝到宿主机上$ docker cp 容器ID：容器内路径  宿主机路径# 将容器拷贝到宿主机上,归档成一个tar包$ docker export 容器ID  &gt;  文件名.tareg: docker export efewtwe1231  &gt;  ubunto.tar# 根据tar包的内容创建一个新的系统并导入成镜像(即新建一个镜像)$ cat  文件名.tar | docker import - 镜像用户&#x2F;镜像名：版本号eg: cat  ubunto.tar | docker import - techen&#x2F;ubanto：3.7</code></pre><h3 id="四、Docker仓库"><a href="#四、Docker仓库" class="headerlink" title="四、Docker仓库"></a>四、Docker仓库</h3><p>镜像是只读的，容器是可写的，一般在容器当中新增功能，然后使用commit指令生成新的镜像</p><pre class="language-java" data-language="java"><code class="language-java"># 提交镜像:提交之后成为了一个新的镜像$ docker commit  # 提交镜像:提交之后成为了一个新的镜像$ docker commit -m&#x3D;&quot;提交的描述信息&quot; -a&#x3D;&quot;作者&quot; 容器ID  要创建的目标镜像名：版本eg：docker commit -m&#x3D;&quot;add vim &quot; -a&#x3D;&quot;techen&quot; efrfsfd12  techen&#x2F;myubunto:3.23  </code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619145133791.png" alt="image-20220619145133791"></p><p>1、将本地镜像提交到阿里云镜像当中</p><p>登陆阿里云—&gt; 管理控制台—〉 容器镜像服务 —&gt;实例列表 —&gt; 个人实例 —&gt; 命名空间建命名、镜像仓库建立仓库</p><pre class="language-java" data-language="java"><code class="language-java">1. 登录阿里云Docker Registry$ docker login --username&#x3D;乾程吴彦祖 registry.cn-hangzhou.aliyuncs.com用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。（bzq18107155240）您可以在访问凭证页面修改凭证密码。2. 从Registry中拉取镜像$ docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;techen&#x2F;superzqbo:[镜像版本号]3. 将镜像推送到Registry$ docker login --username&#x3D;乾程吴彦祖 registry.cn-hangzhou.aliyuncs.com$ docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com&#x2F;techen&#x2F;superzqbo:[镜像版本号]$ docker push registry.cn-hangzhou.aliyuncs.com&#x2F;techen&#x2F;superzqbo:[镜像版本号]请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。4. 选择合适的镜像仓库地址从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-hangzhou.aliyuncs.com 作为Registry的域名登录。5. 示例使用&quot;docker tag&quot;命令重命名镜像，并将它通过专有网络地址推送至Registry。$ docker imagesREPOSITORY                                                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZEregistry.aliyuncs.com&#x2F;acs&#x2F;agent                                    0.7-dfb6816         37bb9c63c8b2        7 days ago          37.89 MB$ docker tag 37bb9c63c8b2 registry-vpc.cn-hangzhou.aliyuncs.com&#x2F;acs&#x2F;agent:0.7-dfb6816使用 &quot;docker push&quot; 命令将该镜像推送至远程。$ docker push registry-vpc.cn-hangzhou.aliyuncs.com&#x2F;acs&#x2F;agent:0.7-dfb6816</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619152906932.png" alt="image-20220619152906932"></p><p>2、将本地镜像推送到私服</p><p>在本地新建一个私有仓库供内部使用，Docker Registry是官方提供的工具，用于构建本地私有镜像仓库</p><pre class="language-java" data-language="java"><code class="language-java"># 拉取Docker Registry工具$ docker pull registry  # 查看拉取Docker Registry工具是否成功$ docker images  # 运行私有库Registry，相当于本地有一个Docker Hub;默认情况下会被容器会被创建在&#x2F;var&#x2F;lib&#x2F;registry下$ docker run -d -p 5000:5000 -v &#x2F;home&#x2F;techen&#x2F;docker_registry&#x2F;:tmp&#x2F;registry --privileged&#x3D;true registry    # 验证私服库上有什么镜像（相当于发送了一个Get请求）$ curl -XGET http:&#x2F;&#x2F;ip:port&#x2F;v2&#x2F;_catalog# 将新镜像改造成符合私服镜像的tag$ docker tag 镜像：Tag  IP：port&#x2F;Repository:Tag  # 推送$ docker push ip:port&#x2F;镜像:版本  # 拉取$ docker pull ip:port&#x2F;镜像:版本</code></pre><p>Docker默认不支持http方式推送镜像，要做如下处理</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619160634368.png" alt="image-20220619160634368"></p><h3 id="五、数据卷"><a href="#五、数据卷" class="headerlink" title="五、数据卷"></a>五、数据卷</h3><p>Docker挂载主机目录访问出现：cannot open directory.:Permission denied</p><p>解决办法；在挂载后面加上 –privileged &#x3D; true 参数即可</p><p>原理：Linux内部默认关掉了容器目录挂载的权限</p><p>数据卷主要的作用是映射(数据互相访问)，完成容器内数据的持久化</p><pre class="language-java" data-language="java"><code class="language-java"># 运行一个带有数据卷的容器（如果目录不存在，会自动创建）$ docker run -it --priviledged&#x3D;true -v 宿主机目录:&#x2F;容器目录  --name&#x3D;容器起名  镜像名    # 运行一个带有数据卷的容器（如果目录不存在，会自动创建）,容器可读可写(默认)$ docker run -it --priviledged&#x3D;true -v 宿主机目录:&#x2F;容器目录:rv  --name&#x3D;容器起名  镜像名  # 运行一个带有数据卷的容器（如果目录不存在，会自动创建）,容器可读不可写(容器内不能创建目录、编写文件)$ docker run -it --priviledged&#x3D;true -v 宿主机目录:&#x2F;容器目录:ro  --name&#x3D;容器起名  镜像名</code></pre><pre class="language-java" data-language="java"><code class="language-java"># 查看挂载信息(Mounts里面会有挂载信息)$ docker inspect 容器id</code></pre><p>数据卷的继承和共享</p><pre class="language-java" data-language="java"><code class="language-java"># 实现容器u1和u2之间的数据共享$ docker run -it --priviledged&#x3D;true --volumes-from 父类(容器名-u1)   --name&#x3D;u2  镜像名</code></pre><h3 id="六、DockerFile"><a href="#六、DockerFile" class="headerlink" title="六、DockerFile"></a>六、DockerFile</h3><p>1、DockerFile概念</p><p>DockerFile是用来构建<strong>Docker镜像</strong>的文本文件，是由一条条构建镜像所需的指令和参数构成的<strong>脚本</strong></p><p>DockerFile相当于是一个镜像文件，是可以正常打包运行的</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619170534907.png" alt="image-20220619170534907"></p><p>2、DockerFile构建过程</p><p>DockerFile内容基础知识</p><pre class="language-java" data-language="java"><code class="language-java">1、每条保留字指令都必须为大写字母且后面要跟随至少一个参数2、指令按照从上到下的顺序执行3、#表示注解4、每条指令都会创建一个新的镜像层，并对镜像层进行镜像提交</code></pre><p>3、Docker执行DockerFile的大致流程</p><pre class="language-java" data-language="java"><code class="language-java">1、Docker从基础镜像运行一个容器2、执行一条指令并对容器做出修改3、执行类似docker commit的操作提交一个新的镜像层4、docker基于刚刚提交的镜像运行一个新的容器5、执行DockerFile当中的下一条指令，直到所有的指令都执行完毕</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619172050676.png" alt="image-20220619172050676"></p><p>4、DockerFile保留字介绍</p><pre class="language-java" data-language="java"><code class="language-java">FROM:基础镜像，当前的新镜像是基于哪个镜像MAINTAINER：镜像维护者的姓名和邮箱RUN：容器构建是需要执行的指令，即build时就会执行DockerFile当中run里面的指令，一般有2种格式shell、exec格式(docker build时执行)EXPOSE：当前容器对外暴漏的端口WORKDIR：指定在创建容器后，终端默认登陆进来的目录，一个落脚点USER：指令该镜像已什么样的用户去执行，默认rootENV：设置环境变量，设置后后面可以使用     eg: ENV MY_PATH &#x2F;usr&#x2F;mytest         WORKDIR $MY_PATHADD:将宿主机目录下的文件拷贝进镜像，且会自动处理URL和解压tar压缩包(copy+解压)COPY：类似ADD，将文件拷贝到镜像VOLUME：数据卷CMD：指定容器启动后要做的操作，DockerFile当中可以有多个CMD指令，但是只有最后一个会生效，CMD会被docker run之后的参数替换掉     CMD是在docker run的时候运行     RUN是在docker build的时候运行ENTRYPOINT:也是用来指定一个**容器启动时要执行的指令**，类似于CMD，但是ENTRYPOINT不会被docker run之后的参数替换掉，而且这些命令行参数会被当中参数传递给ENTRYPOINT指定的程序     ENTRYPOINT[&quot;exec&quot;,&quot;parm1&quot;,&quot;parm2&quot;]     ENTRYPOINT、CMD可以一起使用，一般变参会使用CMD，这里的CMD相当于给ENTRYPOINT传递参数     eg:FROM nginx          ENTRYPOINT [&quot;nginx&quot;,&quot;-c&quot;] # 定参          CMD [&quot;&#x2F;etc&#x2F;ngnix&#x2F;nginx.conf&quot;]   #变参     ------》 nginx -c &#x2F;etc&#x2F;ngnix&#x2F;nginx.conf  </code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619175320535.png" alt="image-20220619175320535"></p><p>5、构建DockerFile文件</p><p>1、编写</p><pre class="language-java" data-language="java"><code class="language-java">FROM java:8   # java8作为基础镜像ENV PROJECT_HOME &#x2F;home&#x2F;project  #设置环境变量，设置后后面可以使用ENV FILE_NAME placeholderENV EXPOSE_PORT 8080ENV ACTIVE_ENV devENV JAVA_OPTS &quot;&quot;RUN ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtimeRUN echo &#39;Asia&#x2F;Shanghai&#39; &gt;&#x2F;etc&#x2F;timezoneRUN apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf &#x2F;var&#x2F;cache&#x2F;apk&#x2F;*RUN set -x &amp;&amp; \    mkdir -p &#x2F;root&#x2F;logs&#x2F;$FILE_NAME &amp;&amp; \    mkdir -p $PROJECT_HOMEWORKDIR $PROJECT_HOMEENTRYPOINT [ &quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom -jar $PROJECT_HOME&#x2F;$FILE_NAME.jar --spring.profiles.active&#x3D;$ACTIVE_ENV&quot; ]EXPOSE $EXPOSE_PORT</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619181857597.png" alt="image-20220619181857597"></p><p>2、构建</p><pre class="language-java" data-language="java"><code class="language-java"># 在dockerfile文件下执行下面的指令（注意tag后面有个空格和点）$ docker build -t 新镜像的名字：TAG .</code></pre><p>3、运行</p><pre class="language-java" data-language="java"><code class="language-java">docker run 镜像名  # 测试服务接口是否可用  $ curl  127.0.0.1:6001&#x2F;order&#x2F;test</code></pre><h3 id="七、Docker网络"><a href="#七、Docker网络" class="headerlink" title="七、Docker网络"></a>七、Docker网络</h3><p>docker安装之后会默认创建三个网络</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621003150868.png" alt="image-20220621003150868"></p><pre class="language-java" data-language="java"><code class="language-java"># 创建网络$ docker network create net1  # 删除网络$ docker network rm net1  # 查看网络源数据$ docker network inspect net1</code></pre><p>1、容器之间的互联通信以及端口映射</p><p>2、容器Ip发生变化时，可以通过服务名直接调用</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621003304909.png" alt="image-20220621003304909"></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619205257295.png" alt="image-20220619205257295"></p><p>Docker容器内部的IP时有可能变化的，所以一般相互通信的服务要设置在同一个网段下面，新建一个网络，它的驱动模式是bridge。</p><h3 id="八、Docker-compose"><a href="#八、Docker-compose" class="headerlink" title="八、Docker-compose"></a>八、Docker-compose</h3><p>用来做容器管理的，相当于一次启动所有容器</p><pre class="language-java" data-language="java"><code class="language-java">Docker-compose使用的流程1、编写DockerFile文件，定义各个微服务并构建成镜像2、使用Docker-componse定义完整的业务单元3、使用docker-compose up启动</code></pre><p>常用指令</p><pre class="language-java" data-language="java"><code class="language-java"># 查看帮助$ docker-compose -h   # 启动服务$ docker-compose up   # 后台启动服务$ docker-compose up -d  # 停止并删除所有容器、网络、卷、镜像$ docker-compose down  # 进入容器内部$ docker-compose exec yml里面服务的ID &#x2F;bin&#x2F;bash  # 展示所有当前docker-compose编排过且运行的容器$ docker-compose ps # 展示所有当前docker-compose编排过的容器的进程$ docker-compose top  # 查看容器的输出日志$ docker-compose logs yml里面服务的ID # 检查配置(检查语法)$ docker-compose config # 检查配置，有问题才输出$ docker-compose config -q  # 重启$ docker-compose restart  # 关闭$ docker-compose stop  # 开启$ docker-compose start</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark使用手册</title>
      <link href="/2022/05/11/wireshark-shi-yong-shou-ce/"/>
      <url>/2022/05/11/wireshark-shi-yong-shou-ce/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Wireshark-介绍"><a href="#一、Wireshark-介绍" class="headerlink" title="一、Wireshark 介绍"></a>一、Wireshark 介绍</h2><p>Wireshark是网络包分析工具，可以捕获多种网络接口类型的包，甚至包括无线局域网接口网络。包分析工具的主要作用是尝试分析捕获到的数据包，并尝试显示数据包尽可能详细的信息。</p><p>Wireshark是开源软件项目，用GPL（General Public License）协议发行。可以免费在任意数量的机器上使用，不用担心授权和付费问题，所有的源代码在GPL框架下都可以免费使用。因为以上原因，人们可以很容易在Wireshark上添加新的协议，或者将其作为插件整合到自己的程序里，这种应用十分广泛。</p><h2 id="二、Wireshark下载、安装"><a href="#二、Wireshark下载、安装" class="headerlink" title="二、Wireshark下载、安装"></a>二、Wireshark下载、安装</h2><p>官网下载,一路next即可：<a href="https://www.wireshark.org/">https://www.wireshark.org</a></p><h2 id="三、界面介绍"><a href="#三、界面介绍" class="headerlink" title="三、界面介绍"></a>三、界面介绍</h2><h3 id="3-1-打开Wireshark-2-6-5，主界面如下："><a href="#3-1-打开Wireshark-2-6-5，主界面如下：" class="headerlink" title="3.1 打开Wireshark 2.6.5，主界面如下："></a>3.1 打开Wireshark 2.6.5，主界面如下：</h3><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621192240599.png" alt="image-20220621192240599"></p><h3 id="3-2-选择要捕获的连接，双击打开"><a href="#3-2-选择要捕获的连接，双击打开" class="headerlink" title="3.2 选择要捕获的连接，双击打开"></a>3.2 选择要捕获的连接，双击打开</h3><p>此时会显示所有，需要进行筛选</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621192325257.png" alt="image-20220621192325257"></p><h3 id="3-3-按照条件刷选包"><a href="#3-3-按照条件刷选包" class="headerlink" title="3.3 按照条件刷选包"></a>3.3 按照条件刷选包</h3><p><a href="https://blog.csdn.net/qq_44275213/article/details/118873256">https://blog.csdn.net/qq_44275213/article/details/118873256</a></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621192356639.png" alt="image-20220621192356639"></p><h4 id="3-3-1-列表介绍"><a href="#3-3-1-列表介绍" class="headerlink" title="3.3.1 列表介绍"></a>3.3.1 列表介绍</h4><p>数据包列表窗格，显示捕获的数据包，每个数据包包含编号，时间戳，源地址，目标地址，协议，长度和数据包信息。不同的协议数据包使用不同的颜色区分</p><p>时间格式化：视图—&gt;显示时间格式化—&gt;格式化时间</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621192419204.png" alt="image-20220621192419204"></p><h2 id="四、重点分析："><a href="#四、重点分析：" class="headerlink" title="四、重点分析："></a>四、重点分析：</h2><p><a href="https://blog.csdn.net/itcodexy/article/details/122593288">https://blog.csdn.net/itcodexy/article/details/122593288</a></p><p>对于我们日常的分析有用的就是前面的五个字段。它们的含义是：SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有DATA数据传输，RST表示连接重置。</p>]]></content>
      
      
      <categories>
          
          <category> 网络工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> WireShark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/05/hello-world/"/>
      <url>/2022/05/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
