<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis 清空数据</title>
      <link href="/2022/08/21/redis-qing-kong-shu-ju/"/>
      <url>/2022/08/21/redis-qing-kong-shu-ju/</url>
      
        <content type="html"><![CDATA[<p>由于服务器上Redis端口未对外开放，所以清除缓存需要从服务器上清除，操作如下：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220821184616335.png" alt="image-20220821184616335"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连接PG数据库报错</title>
      <link href="/2022/08/21/lian-jie-pg-shu-ju-ku-bao-cuo/"/>
      <url>/2022/08/21/lian-jie-pg-shu-ju-ku-bao-cuo/</url>
      
        <content type="html"><![CDATA[<p><strong>连接PG数据库报错</strong></p><blockquote><p>org.postgresql.util.PSQLException: The authentication type 10 is not supported. Check that you have configured the pg_hba.conf file to include the client’s IP address or subnet, and that it is using an authentication scheme supported by the driver.</p></blockquote><p>***方法1:修改pg_hba.conf配置文件当中的ipv4如下 ***</p><pre class="language-java" data-language="java"><code class="language-java"># TYPE  DATABASE        USER            ADDRESS                 METHOD# &quot;local&quot; is for Unix domain socket connections onlylocal   all             all                                     trust# IPv4 local connections:#host   all             all             127.0.0.1&#x2F;32            trusthost    all             all             0.0.0.0&#x2F;0               trust# IP6 local connections:host    all             all             ::1&#x2F;128                 trust# Allow replication connections from localhost, by a user with the# replication privilege.local   replication     all                                     trusthost    replication     all             127.0.0.1&#x2F;32            trusthost    replication     all             ::1&#x2F;128                 trusthost all all all scram-sha-256</code></pre><p>*** 方法2:***</p><pre class="language-none"><code class="language-none">解决方法将pg_hba.conf由&quot;host all all all scram-sha-256&quot;改&quot;host all all all trust&quot;····</code></pre>]]></content>
      
      
      <categories>
          
          <category> PostgreSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装Mysql遇到的问题</title>
      <link href="/2022/08/21/docker-an-zhuang-mysql-yu-dao-de-wen-ti/"/>
      <url>/2022/08/21/docker-an-zhuang-mysql-yu-dao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>Docker安装Mysql遇到的问题</p><h3 id="1、查看mysql的日志，发现如下提示，步奏如下"><a href="#1、查看mysql的日志，发现如下提示，步奏如下" class="headerlink" title="1、查看mysql的日志，发现如下提示，步奏如下"></a>1、查看mysql的日志，发现如下提示，步奏如下</h3><pre class="language-java" data-language="java"><code class="language-java">mysqld: [Warning] World-writable config file &#39;&#x2F;etc&#x2F;mysql&#x2F;my.cnf&#39; is ignored.  mysqld: Error on realpath() on &#39;&#x2F;var&#x2F;lib&#x2F;mysql-files&#39; (Error 2 - No such file or directory)2022-06-24T07:26:45.507436Z 0 [ERROR] [MY-010095] [Server] Failed to access directory for --secure-file-priv. Please make sure that directory exists and is accessible by MySQL Server. Supplied value : &#x2F;var&#x2F;lib&#x2F;mysql-files</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220624154649340.png" alt="image-20220624154649340"></p><h4 id="1-1-可能是mysql-files"><a href="#1-1-可能是mysql-files" class="headerlink" title="1.1 可能是mysql-files"></a>1.1 可能是mysql-files</h4><pre class="language-JAVA" data-language="JAVA"><code class="language-JAVA">#造成这种情况可能是因为mysql-files文件夹不存在或权限错误，# 在宿主机挂载数据目录下touch &#x2F;var&#x2F;lib&#x2F;mysql-filesshell&gt; touch &#x2F;var&#x2F;lib&#x2F;mysql-files</code></pre><h4 id="1-2-linux下："><a href="#1-2-linux下：" class="headerlink" title="1.2 linux下："></a>1.2 linux下：</h4><p>修改my.cnf 在[mysqld]内加入secure_file_priv&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql</p><h4 id="1-3-赋予权限"><a href="#1-3-赋予权限" class="headerlink" title="1.3 赋予权限"></a>1.3 赋予权限</h4><p>先赋予777权限，但是还是报错，遂修改权限未644</p><pre class="language-java" data-language="java"><code class="language-java">权限777，任何一个用户都可以改my.cnf，存在很大的安全隐患.修改my.cnf文件的权限为644 设置为用户可读写，其他用户不可写.chmod 644 &#x2F;etc&#x2F;my.cnf</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker-MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 设置服务所占内存</title>
      <link href="/2022/08/12/docker-she-zhi-fu-wu-suo-zhan-nei-cun/"/>
      <url>/2022/08/12/docker-she-zhi-fu-wu-suo-zhan-nei-cun/</url>
      
        <content type="html"><![CDATA[<p>今天在跑定时任务时，发现程序崩溃了，在服务器上查看之后发现是内存满了，其他的服务占用的内存太多，所以想要限制服务所占的内存，做了如下的操作：</p><p>所以在docker-componse当中指定服务所占的内存，这样在访问内存较大时，服务会变慢，以防止占用内存太多导致其他服务无法正常运行；注意这种方式的前提是其他服务很少用到，不会出现内存溢出情况。</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220821190023076.png" alt="image-20220821190023076"></p><p>注意加了deploy之后，启动时需要使用docker-compose –compatibility up指令来启动,否则会warn：use the ‘deploy’ key, which will be ignored. Compose does not support ‘deploy’ configuration - use <code>docker stack deploy</code> to deploy to a swarm.</p><pre class="language-java" data-language="java"><code class="language-java">docker-compose --compatibility up -d</code></pre><p>效果如下：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220812215811472.png" alt="image-20220812215811472"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker-内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 常用指令(一)</title>
      <link href="/2022/08/12/linux-chang-yong-zhi-ling-yi/"/>
      <url>/2022/08/12/linux-chang-yong-zhi-ling-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="1、查询内存情况"><a href="#1、查询内存情况" class="headerlink" title="1、查询内存情况"></a>1、查询内存情况</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ free -h</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220730142019717.png" alt="image-20220730142019717"></p><h3 id="2、查询端口对应的进程"><a href="#2、查询端口对应的进程" class="headerlink" title="2、查询端口对应的进程"></a>2、查询端口对应的进程</h3><pre class="language-bash" data-language="bash"><code class="language-bash">[root@ecs-1773-3 fes-stress-test]# lsof -i:6379COMMAND    PID USER   FD   TYPE DEVICE SIZE&#x2F;OFF NODE NAMEdocker-pr 2683 root    4u  IPv4  31525      0t0  TCP *:6379 (LISTEN)docker-pr 2691 root    4u  IPv6  33606      0t0  TCP *:6379 (LISTEN)[root@ecs-1773-3 fes-stress-test]# netstat -tunlp|grep 6379tcp        0      0 0.0.0.0:6379            0.0.0.0:*               LISTEN      2683&#x2F;docker-proxy   tcp6       0      0 :::6379                 :::*                    LISTEN      2691&#x2F;docker-proxy   </code></pre><h3 id="3、java项目部署jar指定JVM内存启动"><a href="#3、java项目部署jar指定JVM内存启动" class="headerlink" title="3、java项目部署jar指定JVM内存启动"></a>3、java项目部署jar指定JVM内存启动</h3><p>项目启动报错： **java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread **</p><pre class="language-java" data-language="java"><code class="language-java">异常名称 : 内存溢出异常在启动tomcat的时候或者运行过程中抛出以下异常Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread &quot;http-bio-80-exec-31&quot;</code></pre><p><strong>解决办法：</strong></p><p>项目启动时，指定JVM内存</p><pre class="language-java" data-language="java"><code class="language-java">java -jar -Xms128M -Xmx256M -XX:PermSize&#x3D;128M -XX:MaxPermSize&#x3D;256M xxx.jarjava -jar -Xms1024M -Xmx1024M -XX:PermSize&#x3D;256M -XX:MaxNewSize&#x3D;256M -XX:MaxPermSize&#x3D;256M xxx.jar Xms : 堆内存初始大小Xmx : 堆内存最大值PermSize : 永久内存初始大小MaxPermSize ： 永久内存最大值</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程之CountDownLatch</title>
      <link href="/2022/07/30/java-bing-fa-bian-cheng-zhi-countdownlatch/"/>
      <url>/2022/07/30/java-bing-fa-bian-cheng-zhi-countdownlatch/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://blog.csdn.net/qq877728715/article/details/121857013">https://blog.csdn.net/qq877728715/article/details/121857013</a></p><h3 id="1、并发请求介绍"><a href="#1、并发请求介绍" class="headerlink" title="1、并发请求介绍"></a>1、并发请求介绍</h3><p>java中模拟并发请求，只要多开几个线程，发起请求就好了。但是，这种请求，一般会存在启动的先后顺序了，算不得真正的同时并发！怎么样才能做到真正的同时并发呢？java中提供了闭锁 CountDownLatch、信号量Semaphore、同步屏障CyclicBarrier, 刚好就用来做这种事就最合适了</p><p>本文主要记录CountDownLatch</p><pre class="language-java" data-language="java"><code class="language-java">1. 开启n个线程，加一个闭锁，开启所有线程；2. 待所有线程都准备好后，按下开启按钮，就可以真正的发起并发请求了。</code></pre><h3 id="2、CountDownLatch执行逻辑"><a href="#2、CountDownLatch执行逻辑" class="headerlink" title="2、CountDownLatch执行逻辑"></a>2、CountDownLatch执行逻辑</h3><p>CountDownLatch俗称：(同步计数器&#x2F;闭锁)，可以使一个线程等待其他线程全部执行完毕后再执行。 类似join()的效果。</p><ul><li>场景：主要用来解决一个线程等待 N 个线程的场景。通常用来汇总各个线程执行后的结果</li><li>CountDownLatch内部通过一个计数器来控制等待线程数，该计数器的操作是原子操作，即同时只能有一个线程去更新该计数器。<ul><li>调用await()方法的线程会一直处于阻塞状态，直到其他线程调用countDown()使当前计数器的值变为 0，每次调用countDown()方法计数器的值减1。</li><li>当计数器值减至0时，所有因调用await()方法而处于等待状态的线程就会被唤醒然后继续往下执行。</li><li>这种现象只会出现一次，因为计数器不能被重置。</li></ul></li></ul><p>并发请求流程示意图：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220730163123424.png" alt="image-20220730163123424"></p><blockquote><p>设置了一道门，以保证所有线程可以同时生效。但是，这里的同时启动，也只是语言层面的东西，也并非绝对的同时并发。具体的调用还要依赖于CPU个数，线程数及操作系统的线程调度功能等，不过咱们也无需纠结于这些了，重点在于理解原理！</p><p>与 CountDownLatch 有类似功能的，还有工具栅栏 CyclicBarrier, 也是提供一个等待所有线程到达某一点后，再一起开始某个动作，效果一致，不过栅栏的目的确实比较纯粹，就是等待所有线程到达，而前面说的闭锁 CountDownLatch 虽然实现的也是所有线程到达后再开始，但是他的触发点其实是 最后那一个开关，所以侧重点是不一样的。</p></blockquote><h3 id="3、实例代码"><a href="#3、实例代码" class="headerlink" title="3、实例代码"></a>3、实例代码</h3><p>示例代码：</p><blockquote><p>1、定义了一个开始门，一个结束门，开始门的线程数是1，结束门的线程数是1500，</p><p>2、开始门用来阻塞所有的线程，所有线程创建后，在开始门前阻塞;当countDown()&#x3D;&#x3D;0时，阻塞线程后续的逻辑开始执行</p><p>3、结束门用来统计所有线程的执行时间；当开始门开始时开始计时，每执行一个线程countDown，当countDown()&#x3D;&#x3D;0时，结束门的阻塞失效，程序开始向下执行，线程执行完成，统计执行时间</p></blockquote><pre class="language-java" data-language="java"><code class="language-java">package com.codesheep.terminaldemo.config;import com.codesheep.terminaldemo.service.TaskClient;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;&#x2F;** * @ClassName TerminalInfo * @description: * @author: codesheep * @Version 1.0.0 * @createTime: 2022-07-29 13:17:48 *&#x2F;@Componentpublic class TerminalInfo &#123;    private static final Logger logger &#x3D; LoggerFactory.getLogger(TerminalInfo.class);    private static int TERMINAL_COUNT &#x3D; 1500;    private static int COUNT &#x3D; 0;    &#x2F;&#x2F; 定义线程池    ExecutorService executorService &#x3D; Executors.newCachedThreadPool();    &#x2F;&#x2F;开始门    final CountDownLatch startGate &#x3D; new CountDownLatch(1);    &#x2F;&#x2F;结束门    final CountDownLatch endGate &#x3D; new CountDownLatch(TERMINAL_COUNT);        public void process1()&#123;        for (int i &#x3D; 0; i &lt; TERMINAL_COUNT; i++) &#123;            executorService.execute(() -&gt; &#123;                try &#123;                    &#x2F;&#x2F; 使线程在此等待，当开始门打开时，一起涌入门中                    startGate.await();                    try &#123;                        &#x2F;&#x2F; 执行业务逻辑:发起请求                        process2();                    &#125; finally &#123;                        &#x2F;&#x2F; 业务执行完毕:将结束门减1，减到0时，就可以开启结束门了                        endGate.countDown();                    &#125;                &#125; catch (InterruptedException ie) &#123;                    ie.printStackTrace();                &#125;            &#125;);        &#125;        long startTime &#x3D; System.nanoTime();        logger.info(startTime + &quot; [&quot; + Thread.currentThread() + &quot;] 所有线程都准备好了，准备并发运行...&quot;);        &#x2F;&#x2F; startGate为0,立马执行该startGate阻塞的线程(线程向后执行),因开始门只需一个开关，所以立马就开启开始门        startGate.countDown();        &#x2F;&#x2F; 阻塞线程不让向下执行(直到endGate为0,此处是所有线程执行完毕):等结束门开启(endGate为0,所有的任务执行完毕,统计执行时间)        try &#123;            endGate.await();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        &#x2F;&#x2F;返回并发执行耗时（纳秒）        long endTime &#x3D; System.nanoTime();        logger.info(endTime + &quot; [&quot; + Thread.currentThread() + &quot;] 所有的线程执行完成.&quot;+&quot;   耗时:&quot;+(endTime - startTime)+&quot; ns&quot;);    &#125;    private void process2() &#123;        TaskClient newTaskClient &#x3D; new TaskClient(&quot;1&quot;,&quot;119.167.1.112&quot;, 8888);        newTaskClient.connect();        COUNT++;        logger.info(&quot;٩(๑❛❛๑)۶ &#x3D;&#x3D;&#x3D;终端数&#x3D;&#x3D;&#x3D; &quot; + COUNT +&quot; &#x3D;&#x3D;&#x3D; &quot;+ LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> CountDownLatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux程序提示killed的原因</title>
      <link href="/2022/07/30/linux-cheng-xu-ti-shi-killed-de-yuan-yin/"/>
      <url>/2022/07/30/linux-cheng-xu-ti-shi-killed-de-yuan-yin/</url>
      
        <content type="html"><![CDATA[<p>运行程序时，Linux出现Killed,然后程序就被终止了</p><p>当系统资源不足时，Linux 内核也可以决定终止一个或多个进程。 一个非常常见的例子是<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>不足 (OOM) killer，会在系统的物理内存耗尽时触发。</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@ecs-1773-3 fes-stress-test]# sudo dmesg | tail -7[6229228.008634] [98387]     0 98387    18062      182      39        0             0 sftp-server[6229228.012426] [99129]     0 99129    39329      351      79        0             0 sshd[6229228.015908] [99132]     0 99132    18062      204      38        0             0 sftp-server[6229228.019624] [101710]     0 101710  2759959   382547    4202        0             0 java[6229228.023244] [106758]     0 106758      807        1       4        0             0 zabbix_server[6229228.027147] Out of memory: Kill process 101710 (java) score 187 or sacrifice child[6229228.031308] Killed process 101710 (java), UID 0, total-vm:11039836kB, anon-rss:1530188kB, file-rss:0kB, shmem-rss:0kB</code></pre><p>分析：</p><ul><li>Out of memory: Kill process 101710 (java) score 187 or sacrifice child，内存不够<ul><li>total_vm：总共使用的虚拟内存 Virtual memory use (in 4 kB pages)  11039836&#x2F;1024(得到MB)&#x2F;1024(得到GB)&#x3D;10.56GB</li><li>rss：常驻内存使用Resident memory use (in 4 kB pages)，1530188&#x2F;1024&#x2F;1024&#x3D;1.45GB</li></ul></li></ul><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220730135757686.png" alt="image-20220730135757686"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电表645协议升级流程分析</title>
      <link href="/2022/07/28/dian-biao-645-xie-yi-sheng-ji-liu-cheng-fen-xi/"/>
      <url>/2022/07/28/dian-biao-645-xie-yi-sheng-ji-liu-cheng-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>最近做了645电表的升级，记录一下基本流程</p><h4 id="1、升级初始帧"><a href="#1、升级初始帧" class="headerlink" title="1、升级初始帧"></a>1、升级初始帧</h4><p>升级初始帧也是升级帧，只是结构和升级帧有点区别，结构如下</p><pre class="language-java" data-language="java"><code class="language-java">68 00 00 00 00 00 00 68 14 5D 34 33 33 D3 &#x2F;&#x2F; DI33 33 33 33 &#x2F;&#x2F; passwordAB 89 67 45 &#x2F;&#x2F; operation33 33 81 45 36 48 &#x2F;&#x2F; 00 00(2字节包号) 81(81-33&#x3D;4E,1字节长度,即后面数据的长度) 12 03(两字节总包数,312&#x3D;786,要发786帧) 15(1字节文件类型,暂用15)    &#x2F;&#x2F; 升级数据35 FC CD C3 38 13 21 23 D6 22 23 C3 39 34 A7 3C 23 45 89 07 57 55 45 88 06 45 8D 70 45 89 41 45 8C B3 C3 38 17 45 88 F1 45 89 07 57 54 45 88 06 45 89 36 45 8C B3 C3 38 17 45 88 F1 45 89 07 57 53 45 88 06 45 89 36 45 8C B3 17 3A 16 </code></pre><h4 id="2、升级帧"><a href="#2、升级帧" class="headerlink" title="2、升级帧"></a>2、升级帧</h4><p>升级帧如下：</p><pre class="language-java" data-language="java"><code class="language-java">68 00 00 00 00 00 00 68 14 5A 34 33 33 D3 &#x2F;&#x2F; DI33 33 33 33 &#x2F;&#x2F; password AB 89 67 45 &#x2F;&#x2F; operation34 33 7E     &#x2F;&#x2F; 01 00(包序号) 7E(7E-33&#x3D;4B 1字节长度)         C3 38 15 23 D6 23 45 89 07 32 57 55 45 88 06 13 30 E7 38 3E 22 57 54 45 88 06 13 97 39 93 7A 20 E7 36 46 45 89 07 57 54 45 88 06 13 32 97 63 93 68 22 97 44 93 63 45 89 07 32 57 55 45 88 06 13 E7 4E 3E 22 57 54 45 88 06 13 97 77 16 </code></pre><h4 id="3、激活帧"><a href="#3、激活帧" class="headerlink" title="3、激活帧"></a>3、激活帧</h4><pre class="language-java" data-language="java"><code class="language-java">68 11 11 11 11 11 11 68 14 13 35 33 33 D3 33 33 33 33 AB 89 67 45 33 32 32 32 32 32 32 &#x2F;&#x2F;目前数据是固定的D6 16 </code></pre>]]></content>
      
      
      <categories>
          
          <category> 电表通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 645协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB-数据备份还原</title>
      <link href="/2022/07/28/mongodb-shu-ju-bei-fen-huan-yuan/"/>
      <url>/2022/07/28/mongodb-shu-ju-bei-fen-huan-yuan/</url>
      
        <content type="html"><![CDATA[<p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220630093148047.png" alt="image-20220630093148047"></p><pre class="language-java" data-language="java"><code class="language-java">注意！！！！： 数据库迁移需要使用备份(mongodump)与恢复(mongorestore)语法，如果数据库没有开启权限验证，则直接使用命令即可；如果开启了验证登录，是无法直接备份和恢复数据库的，报如下错误：error reading database: command listCollections requires authentication解决方案添加：-u &lt;username&gt; -p&#x3D;&lt;password&gt;添加：--authenticationDatabase admin</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220630093340591.png" alt="image-20220630093340591"></p><p>Mongo的账户是存储在数据库表里面的，比如这里创建的leanote用户，是存储在了leanote表当中的；管理员账户一般是存在在admin当中的</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220702163108158.png" alt="image-20220702163108158"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网穿透工具nps-npc</title>
      <link href="/2022/07/20/nei-wang-chuan-tou-gong-ju-nps-npc/"/>
      <url>/2022/07/20/nei-wang-chuan-tou-gong-ju-nps-npc/</url>
      
        <content type="html"><![CDATA[<h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>内网穿透:内网穿透就是客户端通过访问中转服务器间接性的去访问内网服务器中的东西</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20211120161858323.png" alt="image-20211120161858323"></p><pre class="language-java" data-language="java"><code class="language-java">nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持tcp、udp流量转发，可支持任何tcp、udp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析等等……），此外还支持内网http代理、内网socks5代理、p2p等，并带有功能强大的web管理端。</code></pre><p><strong>Github地址：</strong><a href="https://github.com/cnlh/nps">https://github.com/cnlh/nps</a>  </p><blockquote><ul><li>系统为Linux&#x2F;Windows&#x2F;Mac均可，本文服务端和客户端都是在Windows 下进行的</li><li>nps服务端：需要安装在一个有公网IP的服务器上，</li><li>npc客户端：安装在需要被访问的内网服务器或者个人电脑上。</li><li>注意nps和npc版本要保持一致</li></ul></blockquote><h2 id="2、NPS安装"><a href="#2、NPS安装" class="headerlink" title="2、NPS安装"></a>2、NPS安装</h2><pre class="language-java" data-language="java"><code class="language-java"># 下载wget https:&#x2F;&#x2F;github.com&#x2F;cnlh&#x2F;nps&#x2F;releases&#x2F;download&#x2F;v0.23.2&#x2F;linux_amd64_server.tar.gz# 解压tar xzvf linux_amd64_server.tar.gz    # 解压后，首先改一下conf文件夹下的npx.conf文件(conf&#x2F;nps.conf)</code></pre><h3 id="2-1-基本信息"><a href="#2-1-基本信息" class="headerlink" title="2.1  基本信息"></a>2.1  基本信息</h3><pre class="language-java" data-language="java"><code class="language-java">将 nps 运行到一个有公网 IP 的服务器上，关注配置文件中的 bridge_port 与 web_port。bridge_port 用来与 NPC 相连接，web_port 用来从浏览器访问，从而配置 NPS。sudo .&#x2F;nps 阻断模式运行，可以看到错误信息，如果有端口占用的问题，可以使用 lsof -i:port 的方式查询占用该端口的进程名，从而将该进程 kill 掉或者关掉。</code></pre><h3 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2  配置"></a>2.2  配置</h3><pre class="language-java" data-language="java"><code class="language-java">appname &#x3D; nps#Boot mode(dev|pro)runmode &#x3D; dev ##bridge,用来与 NPC 相连接# 底层通信协议，默认tcp，可选用kcpbridge_type&#x3D;tcp# 底层通信端口，默认8024，如已被占用请指定其他端口，若未开放，先开放端口bridge_port&#x3D;8024bridge_ip&#x3D;0.0.0.0 #web,用来从浏览器访问web_host&#x3D;116.62.49.243web_username&#x3D;adminweb_password&#x3D;666666web_port &#x3D; 8080web_ip&#x3D;0.0.0.0</code></pre><h3 id="2-3-安装、启动"><a href="#2-3-安装、启动" class="headerlink" title="2.3  安装、启动"></a>2.3  安装、启动</h3><h4 id="2-3-1-服务端"><a href="#2-3-1-服务端" class="headerlink" title="2.3.1 服务端"></a>2.3.1 服务端</h4><pre class="language-java" data-language="java"><code class="language-java"># 安装修改完配置文件之后，.&#x2F;nps install当前的配置文件和web静态文件拷贝到&#x2F;etc&#x2F;nps下，以后修改配置文件直接修改&#x2F;etc&#x2F;nps&#x2F;conf&#x2F;nps.conf    # 启动.&#x2F;nps start        # web 访问 web_host:web_port</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20211120165112869.png" alt="image-20211120165112869"></p><h4 id="2-3-1-客户端"><a href="#2-3-1-客户端" class="headerlink" title="2.3.1 客户端"></a>2.3.1 客户端</h4><pre class="language-java" data-language="java"><code class="language-java">npc.exe -server&#x3D;116.62.49.243:8024 -vkey&#x3D;0z9ogzrb6h8hmgqa这里的ip是你服务器ip端口是你nps.conf中#bridge设置的桥接端口-vkey是你控制面板客户端生成的唯一认证密钥</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20211120170931250.png" alt="image-20211120170931250"></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20211120171044364.png" alt="image-20211120171044364"></p><h3 id="2-4-内网穿透设置"><a href="#2-4-内网穿透设置" class="headerlink" title="2.4  内网穿透设置"></a>2.4  内网穿透设置</h3><pre class="language-java" data-language="java"><code class="language-java">1、服务端端口    服务器连接内网需要的端口，随便写一个，然后去开放安全组    2、目标：    内网要穿透的端口号</code></pre><p>点击“隧道之后”点击新增按钮，创建一个隧道，其中“服务端端口”为你穿透成功之后要访问的端口，“目标 (IP:端口)”为你要穿透的项目的启动端口，我这里项目的启动端口为9091，所以，“目标 (IP:端口)”写9091，服务端端口我写的是9099，如图</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20211120172936384.png" alt="image-20211120172936384"></p><p>此时，我们可以在公网通过访问服务端的ip+端口来访问我们本地的项目了</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20211120173933307.png" alt="image-20211120173933307"></p><p> 这样就可以访问到我们本地项目的test接口了</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NPS-NPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库版本控制工具FlyWay</title>
      <link href="/2022/07/19/shu-ju-ku-ban-ben-kong-zhi-gong-ju-flyway/"/>
      <url>/2022/07/19/shu-ju-ku-ban-ben-kong-zhi-gong-ju-flyway/</url>
      
        <content type="html"><![CDATA[<h3 id="一、概念解释"><a href="#一、概念解释" class="headerlink" title="一、概念解释"></a>一、概念解释</h3><blockquote><p>Flyway是一款开源的数据库迁移工具。可以相对简单的对数据库版本进行控制。</p><p>数据库版本文件：存放在版本文件目录下的sql脚本</p></blockquote><h3 id="二、工具使用"><a href="#二、工具使用" class="headerlink" title="二、工具使用"></a>二、工具使用</h3><h4 id="2-1-Springboot整合FlyWay"><a href="#2-1-Springboot整合FlyWay" class="headerlink" title="2.1 Springboot整合FlyWay"></a>2.1 Springboot整合FlyWay</h4><p>pom.xml文件引入依赖，将sql文件加入资源路径</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> flyway <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>dependency<span class="token operator">></span>   <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>flywaydb<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>   <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>flyway<span class="token operator">-</span>core<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span class="token operator">...</span><span class="token operator">&lt;</span>resource<span class="token operator">></span>    <span class="token operator">&lt;</span>directory<span class="token operator">></span>$<span class="token punctuation">&#123;</span>basedir<span class="token punctuation">&#125;</span><span class="token operator">/</span>src<span class="token operator">/</span>main<span class="token operator">/</span>resources<span class="token operator">&lt;</span><span class="token operator">/</span>directory<span class="token operator">></span>    <span class="token operator">&lt;</span>filtering<span class="token operator">></span><span class="token boolean">true</span><span class="token operator">&lt;</span><span class="token operator">/</span>filtering<span class="token operator">></span>    <span class="token operator">&lt;</span>includes<span class="token operator">></span>    <span class="token operator">&lt;</span>include<span class="token operator">></span><span class="token operator">**</span><span class="token comment">/*.*&lt;/include>    &lt;/includes>&lt;/resource>    </span></code></pre><h4 id="2-2-application-yml当中配置"><a href="#2-2-application-yml当中配置" class="headerlink" title="2.2 application.yml当中配置"></a>2.2 application.yml当中配置</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"># flyway 配置信息# 激活 flywayspring<span class="token punctuation">.</span>flyway<span class="token punctuation">.</span>enabled<span class="token operator">=</span><span class="token boolean">true</span># 禁止清除数据库表：这个属性非常关键，它表示是否要清除已有库下的表，如果执行的脚本是 V1__xxx<span class="token punctuation">.</span>sql，那么会先清除已有库下的表，然后再执行脚本，这在开发环境下还挺方便，但是在生产环境下就要命了，而且它默认就是要清除，生产环境一定要自己配置设置为 <span class="token boolean">true</span>。spring<span class="token punctuation">.</span>flyway<span class="token punctuation">.</span>clean<span class="token operator">-</span>disabled<span class="token operator">=</span><span class="token boolean">true</span># 如果指定 schema 包含了其他表<span class="token punctuation">,</span>但没有 flyway schema history 表的话<span class="token punctuation">,</span>设置为 <span class="token boolean">true</span> 后<span class="token punctuation">,</span> flyway 将在需要 baseline 的时候<span class="token punctuation">,</span> 自动执行一次 baselinespring<span class="token punctuation">.</span>flyway<span class="token punctuation">.</span>baseline<span class="token operator">-</span>on<span class="token operator">-</span>migrate<span class="token operator">=</span><span class="token boolean">true</span># 指定 baseline 的版本号<span class="token punctuation">,</span>缺省值为 <span class="token number">1</span><span class="token punctuation">,</span> 低于该版本号的 <span class="token constant">SQL</span> 文件<span class="token punctuation">,</span> migrate 的时候被忽略spring<span class="token punctuation">.</span>flyway<span class="token punctuation">.</span>baseline<span class="token operator">-</span>version<span class="token operator">=</span><span class="token number">1</span># sql文件目录<span class="token punctuation">,</span>默认是 classpath<span class="token operator">:</span>db<span class="token operator">/</span>migration，如果有多个，用 <span class="token punctuation">,</span> 隔开spring<span class="token punctuation">.</span>flyway<span class="token punctuation">.</span>locations<span class="token operator">=</span>classpath<span class="token operator">:</span>db<span class="token operator">/</span>migration</code></pre><blockquote><p>a. 配置好此二项后，在数据源配置无问题的情况下启动项目，数据库出现flyway_schema_history表即说明整合成功。</p><p><strong>b. 工程启动时会根据当前版本依次执行比当前版本高的sql文件。</strong></p><p>c. 可将数据库初始化数据库脚本作为基准版本，新项目第一次启动时执行，避免初始化数据库的额外工作。</p></blockquote><h3 id="三、分环境配置多套数据库版本文件示例"><a href="#三、分环境配置多套数据库版本文件示例" class="headerlink" title="三、分环境配置多套数据库版本文件示例"></a>三、分环境配置多套数据库版本文件示例</h3><p>为解决不同生产环境部分sql版本文件不通用的问题</p><p><strong>a. 配置文件目录结构</strong></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220719144029110.png" alt="image-20220719144029110">                               </p><p><strong>b. 主配置文件：application.properties</strong></p><p> <img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220719144037804.png" alt="image-20220719144037804"></p><p><strong>c. 生产环境1配置文件</strong></p><p> <img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220719144045083.png" alt="image-20220719144045083"></p><h3 id="四、FlyWay使用约定"><a href="#四、FlyWay使用约定" class="headerlink" title="四、FlyWay使用约定"></a>四、FlyWay使用约定</h3><h4 id="4-1-数据库版本文件整体约定"><a href="#4-1-数据库版本文件整体约定" class="headerlink" title="4.1 数据库版本文件整体约定"></a>4.1 数据库版本文件整体约定</h4><p>一份数据库版本文件可包含多条操作数据库的sql命令(在一个数据库版本sql文件当中，可以写多个建表，插入数据sql)。</p><blockquote><p>在一次提交中将所有需提交的数据库变更维护在同一个数据库版本文件中，无需也没有必要为每一条语句新增一个版本文件。如：在初始化的版本文件中包含了整套建表语句与初始化数据sql。</p></blockquote><p>数据库版本文件使用新增的方式进行管理，提交svn后不允许修改（数据库sql版本不允许修改，若想更新数据库结构，需要新建一个sql数据文件）</p><blockquote><p>该条约定的意思为若已添加某个数据库版本，此时又需要补充内容(或者纠错某些内容)，不允许修改之前的版本文件，只能通过新增一份版本文件对数据库进行操作。可以结合svn版本管理进行理解，文件在提交后版本即固定，再想修改文件需要提交新版而旧版本的记录不变。</p></blockquote><h4 id="4-2-数据库版本文件命名约定"><a href="#4-2-数据库版本文件命名约定" class="headerlink" title="4.2 数据库版本文件命名约定"></a>4.2 数据库版本文件命名约定</h4><p><strong>数据迁移文件相关注意事项：</strong></p><ul><li><p>文件存放位置：resources&#x2F;db&#x2F;migration</p></li><li><p>命名规则</p><ul><li>V[version]__[name].sql</li><li>名称中[version]和[name]之间是两个下划线</li><li>[version]部分使用时间戳-年月日时分秒(例：20190625143301)</li><li>[name]描述sql作用，使用“_”分隔</li><li>添加数据的sql文件版本[name]部分均需要加data_</li></ul></li><li><p>注意事项：</p><ul><li>每次对数据库表做出改动(通用改动，即所有部署环境都可变更的改动)均需要添加新版本的数据迁移文件</li><li>添加表字段只能用ALTER…ADD，绝不能删表重建！！！(删表重建会删除生产环境的所有表数据，严格禁止！！)</li><li>慎重执行删表，删数据相关sql</li><li>可将数据库初始化数据库脚本作为基准版本，新项目第一次启动时执行，避免初始化数据库的额外工作</li><li>服务启动时会根据当前版本依次执行比当前版本高的迁移文件</li></ul></li><li><p>单一功能的版本文件[name]部分规则</p><ul><li>纯数据操作的使用data_开头</li><li>新增数据使用_add结尾</li><li>修改数据使用_mod结尾</li><li>删除数据使用_del结尾</li></ul></li></ul><h4 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3 注意事项"></a>4.3 注意事项</h4><p>当我们使用FlyWay执行数据库脚本之后，Flyway 还给创建了一个 flyway_schema_history 表，这个表用来记录数据库的更新历史。</p><blockquote><p><strong>这个表当中有记录的脚本，在下次项目启动后就不会在执行了，因为系统知道这个脚本已经执行过了，如果你还想让该 脚本再执行一遍，需要手动删除 flyway_schema_history 表中的对应记录，那么项目启动时，这个脚本就会被执行了。</strong></p></blockquote><blockquote><p>所有的脚本，一旦执行了，就会在 flyway_schema_history 表中有记录，如果你不小心搞错了，可以手动从 flyway_schema_history 表中删除记录，然后修改 SQL 脚本后再重新启动（生产环境不建议）。</p></blockquote><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>flyway是用来做数据库版本管理的，一般主用用途是在运行程序的时候可以顺便生成表数据，</p><p>flyway管理的数据是哪些：一般我们将建表语句以及一些核心的数据通过flyway来管理</p><p>flyway运行的，对比的是flyway_schema_history 表记录和flyway的脚本文件，根据一定的算法进行对比</p><p><strong>项目运行之后流程</strong></p><blockquote><p><strong>在项目运行之后：</strong></p><ul><li>检测数据库当中的版本和项目当中版本是否一致<ul><li>不一致，执行新脚本</li><li>一致<ul><li>检测checksum是否一致<ul><li>一致，不更新</li><li>不一致,说明已执行的flyway脚本给改动过,报错</li></ul></li></ul></li></ul></li></ul></blockquote><p><strong>注意事项如下：</strong></p><blockquote><p>所以我们在进行开发的过程当中，如果要对核心字段、核心数据进行更新，要通过flyway去执行！</p><p>因为,如果我们直接没有通过flyway去修改，而是通过sql或者直接修改的,那么在项目在其他的服务器上运行时，该字段还是之前的，不会修改！</p><p>注意：对于其他的数据，不需要维护在flyway当中,因为fly只是对表当中的数据、结构进行修改，对于未维护在flyway当中的数据，不会进行修改。</p><p>如果有多个flyway文件，在运行时会一个一个执行；如果在下次执行时，发现某个文件被改过了，则会报错</p><p>所以原则是执行后的文件如果要进行修改，不能再源文件上进行修改，需要新建文件进行修改。</p><p>注意：如果新加的版本日期小于之前的版本日期，则会报错；所以要先拉取代码，在更新脚本</p></blockquote><p><strong>flyway的checksum</strong></p><blockquote><p>官网已经说的很清楚，flyway获取flyway_schema_history中最新成功记录的版本号（基准version），与项目中db&#x2F;migration文件夹中的文件version进行比对，当version大于基准version则执行。既然通过版本号就可以完成迁移前判断，那还需要checksum做什么呢？</p><p><strong>其实我们在使用flyway的时候，需要养成这样一个习惯，一旦执行过的sql脚本就不要去修改，如果需要对已有数据表进行增删改的操作，应该新建一个脚本执行</strong>。但是对于修改已经执行过的sql脚本，flyway也有预防，那就是checksum。</p><p>每个sql脚本在执行前会将基本信息写入flyway_schema_history中，flyway会把每个脚本作为输入，通过某算法（不清楚）输出一个整数，这个数就是checksum，flyway在工作之前，会先基于baseline逐个脚本比对其数据库中的checksum值，如果计算结果不同，则会报mismatch的错误.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flyway </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记</title>
      <link href="/2022/07/19/mongodb-xue-xi-bi-ji/"/>
      <url>/2022/07/19/mongodb-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>内存的特点：一旦重启，或者断电，数据全部不没了，故需要将数据存在磁盘上</p><p>RDAMS（关系型数据库）：全都是表，关系型数据库是由表组成的，所有的关系型数据库都是使用SQL操作的</p><p>NoSQL（非关系型数据库）：键值对数据库，文档数据库(MongoDB)</p><p>MongoDB是为了快速开发互联网web应用而开发的一款数据库，省了建表、改表的时间，而MongoDB是文档数据库，所以速度很快，想改就改，想删就删</p><p>MongoDB的数据模型是面向文档的，所谓文档是一种类似JSON的数据格式，简单理解为，MongoDB当中存储的是各种各样的JSON（BJSON），当然也可以存储一些二进制数据，但是我们把它当成是JSON格式的</p><p>指定数据库位置：</p><pre class="language-java" data-language="java"><code class="language-java">mongod --dbpath 数据库路径 --port 端口号</code></pre><h3 id="二、Docker-componse方式安装"><a href="#二、Docker-componse方式安装" class="headerlink" title="二、Docker-componse方式安装"></a>二、Docker-componse方式安装</h3><pre class="language-java" data-language="java"><code class="language-java">mongo:  image: mongo:4.4.6  container_name: tienChin-mongo  restart: always  privileged: true  ports:    - 27017:27017  volumes:    - &#x2F;home&#x2F;techen&#x2F;tienChin&#x2F;mongodb&#x2F;data:&#x2F;data&#x2F;db    - &#x2F;home&#x2F;techen&#x2F;tienChin&#x2F;mongodb&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mongodb    - &#x2F;home&#x2F;techen&#x2F;tienChin&#x2F;mongodb&#x2F;mongod.conf:&#x2F;etc&#x2F;mongod.conf  environment:     TZ: Asia&#x2F;Shanghai     MONGO_INITDB_ROOT_USERNAME: root # 自动开启权限认证     MONGO_INITDB_ROOT_PASSWORD: QAZqaz01  # 路径是容器的路径，不能指定宿主机的路径         command: &quot;mongod --config &#x2F;etc&#x2F;mongod.conf&quot;  networks:    tienChin:      aliases:        - tienChin-mongomongo-express:  image: mongo-express:latest  container_name: tienChin-mongo-express  restart: always  links:    - mongo:mongodb  depends_on:    - mongo  ports:    - 27018:8081  environment:    # 编辑主题    ME_CONFIG_OPTIONS_EDITORTHEME: tienChin-mongo-express    # mongo的服务地址，可以配置容器名也可以用ip    ME_CONFIG_MONGODB_SERVER: mongo    # mongo服务的端口    ME_CONFIG_MONGODB_PORT: 27017    # mongo的admin用户名    ME_CONFIG_MONGODB_ADMINUSERNAME: root    ME_CONFIG_MONGODB_ADMINPASSWORD: QAZqaz01    # 登陆页面时候的用户名    ME_CONFIG_BASICAUTH_USERNAME: admin    ME_CONFIG_BASICAUTH_PASSWORD: 666666  networks:    tienChin:      aliases:        - tienChi-mongo-express</code></pre><h3 id="三、基本概念"><a href="#三、基本概念" class="headerlink" title="三、基本概念"></a>三、基本概念</h3><h4 id="3-1数据库操作"><a href="#3-1数据库操作" class="headerlink" title="3.1数据库操作"></a>3.1数据库操作</h4><p>一个数据库当中有多个集合，类似于数据，数据当中可以存储文档，文档是数据库当中的最小单位，我们操作的都是文档</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20210105102350091.png" alt="image-20210105102350091"></p><p>注意：在MongoDB当中，集合与数据库都不需要手动创建，如果我们在创建文档时，如果文档所在的集合或者数据库不存在，会自动创建，只是，如果没有数据，不会显示，只有在第一次添加数据时会创建，显示</p><pre class="language-java" data-language="java"><code class="language-java">show dbs                     &#x2F;&#x2F;显示系统当中的数据库show databasesdb                           &#x2F;&#x2F;查看当前数据库use 数据库名                  &#x2F;&#x2F;数据库切换show collections             &#x2F;&#x2F;显示当前数据库当中的集合</code></pre><h4 id="3-2-库操作"><a href="#3-2-库操作" class="headerlink" title="3.2 库操作"></a>3.2 库操作</h4><pre class="language-java" data-language="java"><code class="language-java">使用用户名和密码连接到 MongoDB 服务器，你必须使用 &#39;username:password@hostname&#x2F;dbname&#39; 格式，&#39;username&#39;为用户名，&#39;password&#39; 为密码。mongodb:&#x2F;&#x2F;fred:foobar@localhost   &#x2F;&#x2F;使用用户名fred，密码foobar登录localhost的admin数据库。mongodb:&#x2F;&#x2F;fred:foobar@localhost&#x2F;baz  &#x2F;&#x2F;使用用户名fred，密码foobar登录localhost的baz数据库。mongodb:&#x2F;&#x2F;localhost,localhost:27018,localhost:27019  &#x2F;&#x2F;连接 replica set 三台服务器 (端口 27017, 27018, 和27019):MongoDB创建数据库语法：use DATABASE_NAME  &#x2F;&#x2F;如果数据库不存在，则创建数据库，否则切换到指定数据库。实例：</code></pre><h4 id="3-3CRUD"><a href="#3-3CRUD" class="headerlink" title="3.3CRUD"></a>3.3CRUD</h4><pre class="language-java" data-language="java"><code class="language-java">1、insert        db.collection.insert() &#x2F;&#x2F;首先切换到需要的数据库，然后插入文档到集合当中    db.stu.insert(&#123;name：&quot;古踏仙&quot;,age：36,gender：&quot;男&quot;&#125;)        db.stu.find()           &#x2F;&#x2F;查询db当中stu集合当中的所有文档        注意：如果我们给集合当中插入文档时，如果没有指定&quot;_id&quot;，那么会自动创建一个&quot;_id&quot;，作为该文档的唯一属性        可以通过ObjectId()来生成，不会重复，因为是使用时间戳生成的        db.collection.insertOne()   &#x2F;&#x2F;插入一个 ，插入单个    db.collection.insertMany()  &#x2F;&#x2F;插入多个 ，插入数据     2、find    db.stu.find()    &#x2F;db.stu.find(&#123;&#125;) &#x2F;&#x2F;查询集合当中所有符合条件的文档，如果没有传入条件，代表查询所有的文档，返回的是数组      db.stu.findOne()  &#x2F;&#x2F;查询集合当中符合条件的第一个文档，返回的是对象          db.stu.find().count()  &#x2F;&#x2F;查询集合当中符合条件的文档个数    3、update    db.student.update(&#123;query&#125;,&#123;set，unset&#125;)    db.student.update(&#123;&quot;_id&quot;:ObjectId(&quot;5ff3d22976f98c54752c019e&quot;)&#125;,&#123;$unset:&#123;address:&quot;龙符大陆&quot;&#125;&#125;);    update()默认情况下只修改第一个满足条件的判断,但是可以让改多个，加个参数就行，&#123;multil:ture&#125;    updateMany():修改多个    updateOne():修改一个            参数addToSet();    &#x2F;&#x2F;向数组当中添加一个元素push()            &#x2F;&#x2F;向数组当插入一个元素                4、delete    db.student.remove(&#123;id:&quot;sfdjhq2e124234b43534q24&quot;&#125;)  &#x2F;&#x2F;默认删除多个    db.student.remove(&#123;&#125;)    &#x2F;&#x2F;清空集合    db.student.drop()  &#x2F;&#x2F;删除集合</code></pre><pre class="language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 增加-向集合当中插入一个或者多个文档db.student.insert(&#123;name:&quot;王腾&quot;,age:24,gender:&quot;男&quot;&#125;);&#x2F;&#x2F;插入--插入多个db.student.insert([&#123;name:&quot;鲁智深&quot;,age:43,gender:&quot;男&quot;&#125;,&#123;name:&quot;阎婆惜&quot;,age:28,gender:&quot;女&quot;&#125;,&#123;name:&quot;潘金莲&quot;,age:26,gender:&quot;女&quot;&#125;]);db.student.find();ObjectId();db.student.find(&#123;age:5ff3d54ba62600002e003d72&#125;);db.student.find(&#123;&#39;name&#39;&#125;);&#x2F;&#x2F;update（查询条件，修改新信息），update默认情况下只修改第一个满足条件的db.student.update(&#123;&quot;_id&quot;:ObjectId(&quot;5ff3d22976f98c54752c019e&quot;)&#125;,&#123;$unset:&#123;address:&quot;龙符大陆&quot;&#125;&#125;);&#x2F;&#x2F;如果要对文档内的属性进行访问，要在双引号内部进行访问&#x2F;&#x2F;向number当中插入2000条数据for(var i&#x3D;0;i&lt;2000;i++)&#123;db.number.insert(&#123;num:i&#125;);&#125;db.number.find();db.number.remove(&#123;&#125;);var arr&#x3D;[];for(var i&#x3D;0;i&lt;2000;i++)&#123;arr.push(&#123;num:i&#125;);&#125;db.number.insert(arr)db.number.find(&#123;&#125;);&#x2F;&#x2F;查找大于500的db.number.find(&#123;num:&#123;$gt:500&#125;&#125;)&#x2F;&#x2F;查找40到5o的db.number.find(&#123;num:&#123;$gt:40,$lt:50&#125;&#125;);db.number.find().limit(10);&#x2F;&#x2F;skip用于跳过指定的条数，limit用于指定显示的条数，MongoDB会自动调整skip、limit的位置db.number.find().skip(10).limit(10);&#x2F;&#x2F;文档之间的关系&#x2F;&#x2F;sort()用来指定排序的顺序，正数标识升序表，负数表示降序表db.number.find(&#123;&#125;).sort(sal:1);&#x2F;&#x2F;查询时，可以在第二个参数的位置指定查询结果的投影db.number.find(&#123;&#125;,&#123;ename:1,_id:0,age:1&#125;).</code></pre><h3 id="四、备份会还原"><a href="#四、备份会还原" class="headerlink" title="四、备份会还原"></a>四、备份会还原</h3><blockquote><p>数据导入：<br> mongorestore -h 127.0.0.1:27017 -d leanote –dir &#x2F;mongodb_backup&#x2F;leanote_install_data&#x2F;<br> – –h ：服务器ip</p><p>​    —–d ：服务器上数据库<br>​    – –dir导入文件所在目录</p><p>数据导出:</p><p>​mongodump -h 192.168.17.129:27017 -d leanote -o &#x2F;home&#x2F;mongodump&#x2F;</p><p>​    – —o:导出到本地的某个位置<br>​    ——-: 将192.168.17.129服务器上的，leanote库，导出到&#x2F;home&#x2F;mongodump&#x2F;目录下</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mina基础(二):客户端、服务端实现</title>
      <link href="/2022/07/19/mina-ji-chu-er-ke-hu-duan-fu-wu-duan-shi-xian/"/>
      <url>/2022/07/19/mina-ji-chu-er-ke-hu-duan-fu-wu-duan-shi-xian/</url>
      
        <content type="html"><![CDATA[<h3 id="一、服务端"><a href="#一、服务端" class="headerlink" title="一、服务端"></a>一、服务端</h3><p>本次示例当中服务端由一下几部分构成</p><blockquote><p>1、服务端Socket</p><p>2、服务端Socket封装类</p><p>3、DataHandler数据处理</p><p>4、项目启动后调用</p></blockquote><h4 id="1-1、创建Session服务端"><a href="#1-1、创建Session服务端" class="headerlink" title="1.1、创建Session服务端"></a>1.1、创建Session服务端</h4><pre class="language-java" data-language="java"><code class="language-java">package com.test.mina.server;import org.apache.mina.core.filterchain.IoFilter;import org.apache.mina.core.service.IoAcceptor;import org.apache.mina.core.service.IoHandler;import org.apache.mina.core.session.IdleStatus;import org.apache.mina.filter.codec.ProtocolCodecFilter;import org.apache.mina.filter.codec.textline.TextLineCodecFactory;import org.apache.mina.transport.socket.nio.NioSocketAcceptor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.net.InetSocketAddress;&#x2F;** * @ClassName SocketServer * @description: Mina服务端,提供socket端口侦听服务:用于监听客户端连接，并接受客户端发送过来的数据 * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-08 13:49:19 *&#x2F;public class SocketServer &#123;    private final static Logger logger &#x3D; LoggerFactory.getLogger(SocketServer.class);    &#x2F;**     * 1、创建一个非阻塞的server端的Socket     * 2、设置编码过滤器（使用Mina提供的文本换行符编解码器）     * 3、设置读取数据的缓冲区大小     * 4、设置读写通道无操作进入空闲状态的时间 10ms     * 5、绑定真正的逻辑处理     * 6、绑定端口     *&#x2F;    &#x2F;&#x2F; 绑定的端口    private int port;    private String name;    &#x2F;&#x2F; 服务启动标志    private boolean started&#x3D;false;    &#x2F;&#x2F; 设置读取、设置数据的缓冲区大小    private int readerIndleTime&#x3D;60; &#x2F;&#x2F;s    private int writerIndleTime&#x3D;900; &#x2F;&#x2F;s    private IoHandler dataHandler;    private IoAcceptor acceptorServer;    public SocketServer(String name,int port)&#123;        this.name &#x3D; name;        this.port &#x3D; port;    &#125;    public boolean start()&#123;        if(started)&#123;            return true;        &#125;        try &#123;            &#x2F;&#x2F; 创建一个非阻塞的server端的Socket            acceptorServer &#x3D; new NioSocketAcceptor();            acceptorServer.getSessionConfig().setReaderIdleTime(getReaderIndleTime());            acceptorServer.getSessionConfig().setWriterIdleTime(getWriterIndleTime());            &#x2F;&#x2F; 设置读写通道无操作进入空闲状态的时间 10ms            acceptorServer.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);            &#x2F;&#x2F; 设置过滤链            acceptorServer.getFilterChain().addLast(&quot;codec&quot;, new ProtocolCodecFilter(new TextLineCodecFactory()));            acceptorServer.setHandler(getDataHandler());            acceptorServer.bind(new InetSocketAddress(port));            logger.info(&quot;&#123;&#125; listening port:&#123;&#125;&quot;,name,port);            started &#x3D; true;            return true;        &#125; catch (IOException e) &#123;            logger.error(&quot;start&quot;,e);            return false;        &#125;    &#125;    public void close() &#123;        this.acceptorServer.dispose();    &#125;    public int getReaderIndleTime() &#123;        return readerIndleTime;    &#125;    public void setReaderIndleTime(int readerIndleTime) &#123;        this.readerIndleTime &#x3D; readerIndleTime;    &#125;    public int getWriterIndleTime() &#123;        return writerIndleTime;    &#125;    public void setWriterIndleTime(int writerIndleTime) &#123;        this.writerIndleTime &#x3D; writerIndleTime;    &#125;    public IoHandler getDataHandler() &#123;        return dataHandler;    &#125;    public void setDataHandler(IoHandler dataHandler) &#123;        this.dataHandler &#x3D; dataHandler;    &#125;&#125;</code></pre><h4 id="1-2、创建服务端封装类"><a href="#1-2、创建服务端封装类" class="headerlink" title="1.2、创建服务端封装类"></a>1.2、创建服务端封装类</h4><pre class="language-java" data-language="java"><code class="language-java">package com.techen.mina.server;import com.techen.mina.utils.Config;import org.slf4j.Logger;import org.slf4j.LoggerFactory;&#x2F;** * @ClassName Fes * @description: * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-15 10:22:26 *&#x2F;public class Fes &#123;    private static final Logger logger&#x3D; LoggerFactory.getLogger(Fes.class);    &#x2F;&#x2F; 终端上线端口服务    private SocketServer terminalServer;    &#x2F;&#x2F; 主站侧端口服务    private SocketServer clientServer;    &#x2F;&#x2F; 终端上线端口    private int terminalPort;    &#x2F;&#x2F; 主站连接端口    private int clientPort;    private Config config;    &#x2F;&#x2F; 终端数据处理器    private DataHandler terminalDataHandler;    &#x2F;&#x2F; 主站连接数据处理器    private DataHandler clientDataHandler;    public Fes(Config config) &#123;        this.config &#x3D; config;    &#125;    public void start() &#123;        &#x2F;&#x2F; 启动终端通信监听        terminalPort &#x3D; config.getIntValue(&quot;terminal_port&quot;, 12000);        terminalServer &#x3D; new SocketServer(&quot;Terminal Service&quot;, terminalPort);        terminalServer.setReaderIndleTime(config.getIntValue(&quot;terminal_idle&quot;, 300));        terminalServer.setWriterIndleTime(config.getIntValue(&quot;terminal_idle&quot;, 300));        terminalServer.setDataHandler(terminalDataHandler);        terminalServer.start();        &#x2F;&#x2F; 启动主站通信监听        clientPort &#x3D; config.getIntValue(&quot;client_port&quot;, 12001);        clientServer &#x3D; new SocketServer(&quot;Client Service&quot;, clientPort);        clientServer.setReaderIndleTime(config.getIntValue(&quot;client_idle&quot;, 60));        clientServer.setDataHandler(clientDataHandler);        clientServer.start();        logger.info(&quot;fes started.&quot;);    &#125;    public void close() &#123;        terminalServer.close();        clientServer.close();    &#125;    public void setTerminalDataHandler(DataHandler terminalDataHandler) &#123;        this.terminalDataHandler &#x3D; terminalDataHandler;    &#125;    public DataHandler getClientDataHandler() &#123;        return clientDataHandler;    &#125;    public DataHandler getTerminalDataHandler() &#123;        return terminalDataHandler;    &#125;    public void setClientDataHandler(DataHandler clientDataHandler) &#123;        this.clientDataHandler &#x3D; clientDataHandler;    &#125;&#125;</code></pre><h4 id="1-3、数据处理"><a href="#1-3、数据处理" class="headerlink" title="1.3、数据处理"></a>1.3、数据处理</h4><pre class="language-java" data-language="java"><code class="language-java">package com.techen.mina.server;import org.apache.mina.core.buffer.IoBuffer;import org.apache.mina.core.service.IoHandlerAdapter;import org.apache.mina.core.session.IdleStatus;import org.apache.mina.core.session.IoSession;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import java.nio.charset.StandardCharsets;&#x2F;** * @ClassName DataHandler * @description: * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-15 09:59:56 *&#x2F;@Componentpublic abstract class DataHandler extends IoHandlerAdapter &#123;    private static final Logger logger &#x3D; LoggerFactory.getLogger(DataHandler.class);    public DataHandler() &#123;        super();    &#125;    @Override    public void sessionCreated(IoSession session) throws Exception &#123;        logger.info(&quot;连接成功&quot;);    &#125;    @Override    public void sessionOpened(IoSession session) throws Exception &#123;        logger.info(&quot;服务端与客户端连接打开&quot;);    &#125;    @Override    public void sessionClosed(IoSession session) throws Exception &#123;        logger.info(&quot;服务端与客户端连接关闭&quot;);    &#125;    @Override    public void sessionIdle(IoSession session, IdleStatus status) throws Exception &#123;        logger.info(&quot;服务端进入空闲状态&quot;);    &#125;    @Override    public void exceptionCaught(IoSession session, Throwable cause) throws Exception &#123;        logger.error(&quot;服务端发生异常&quot;, cause);    &#125;    @Override    public void messageReceived(IoSession session, Object message) throws Exception &#123;        &#x2F;&#x2F; 收到的是字符串(传输之前的数据类型)        byte[] msgBytes &#x3D; message.toString().getBytes(StandardCharsets.UTF_8);        try &#123;            this.messageReceived(session, msgBytes);        &#125; catch (Exception var6) &#123;            logger.error(var6.getMessage(), var6);        &#125;    &#125;    public abstract void messageReceived(IoSession var1, byte[] var2);    @Override    public void messageSent(IoSession session, Object message) throws Exception &#123;        logger.info(&quot;服务端发送消息成功&quot;);    &#125;    @Override    public void inputClosed(IoSession session) throws Exception &#123;        logger.info(&quot;输入关闭&quot;);    &#125;&#125;&#x2F;**-----------------------------------------------------------------------------------------------------**&#x2F;package com.techen.mina.server;import org.apache.mina.core.session.IoSession;&#x2F;** * @ClassName ClientDataHandler * @description: * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-15 13:16:44 *&#x2F;public class ClientDataHandler extends DataHandler&#123;    @Override    public void messageReceived(IoSession session, byte[] msgBytes) &#123;        System.out.println(&quot;收到客户端信息：&quot;+new String(msgBytes));    &#125;&#125;&#x2F;**---------------------------------------------------------------------------------------------------**&#x2F;package com.techen.mina.server;import org.apache.mina.core.session.IoSession;&#x2F;** * @ClassName TerminalDataHandler * @description: * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-15 16:18:34 *&#x2F;public class TerminalDataHandler extends DataHandler&#123;    @Override    public void messageReceived(IoSession session, byte[] msgBytes) &#123;        System.out.println(&quot;收到设备端信息：&quot;+new String(msgBytes));    &#125;&#125;    </code></pre><h4 id="1-4、项目启动后调用"><a href="#1-4、项目启动后调用" class="headerlink" title="1.4、项目启动后调用"></a>1.4、项目启动后调用</h4><pre class="language-java" data-language="java"><code class="language-java">package com.techen.mina;import com.techen.mina.server.ClientDataHandler;import com.techen.mina.server.Fes;import com.techen.mina.server.TerminalDataHandler;import com.techen.mina.utils.Configs;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SocketMinaApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SocketMinaApplication.class, args);        Fes fes &#x3D; new Fes(Configs.getConfig(&quot;&#x2F;config&#x2F;serverconfig.properties&quot;));        fes.setClientDataHandler(new ClientDataHandler());        fes.setTerminalDataHandler(new TerminalDataHandler());        fes.start();    &#125;&#125;</code></pre><h3 id="二、客户端"><a href="#二、客户端" class="headerlink" title="二、客户端"></a>二、客户端</h3><p>本次示例当中客户端由一下几部分构成</p><blockquote><p>1、客户端Socket</p><p>2、客户端Socket封装类</p><p>3、DataHandler数据处理</p><p>4、项目启动后调用</p><p>5、测试</p></blockquote><h4 id="2-1-客户端Socket"><a href="#2-1-客户端Socket" class="headerlink" title="2.1 客户端Socket"></a>2.1 客户端Socket</h4><p>该类当中有一个主要的方法init,在该方法当中，添加监听端口connect.addListener()时,监听端口类可以实现IoServiceListener，去实现自动重连功能；connect方法用于连接服务端；sendMessage方法用于发送报文</p><pre class="language-java" data-language="java"><code class="language-java">package com.techen.mina.client;import com.techen.mina.utils.CommUtils;import com.techen.mina.utils.Configs;import com.techen.mina.utils.SimpleThreadFactory;import org.apache.mina.core.future.ConnectFuture;import org.apache.mina.core.service.IoConnector;import org.apache.mina.core.service.IoHandler;import org.apache.mina.core.service.IoService;import org.apache.mina.core.service.IoServiceListener;import org.apache.mina.core.session.IdleStatus;import org.apache.mina.core.session.IoSession;import org.apache.mina.filter.codec.ProtocolCodecFactory;import org.apache.mina.filter.codec.ProtocolCodecFilter;import org.apache.mina.filter.codec.textline.TextLineCodecFactory;import org.apache.mina.filter.executor.ExecutorFilter;import org.apache.mina.transport.socket.nio.NioSocketConnector;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.net.InetSocketAddress;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicBoolean;&#x2F;** * @ClassName ClientServer：mina socket客户端封装。提供连接建立，自动重连等功能。 * @description: IoSession是最重要的一个接口：当连接建立之后，不同的客户端会单独建立一个Session，在Session当中进行数据传输 * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-18 17:39:39 *&#x2F;public class SocketClient &#123;    &#x2F;**     * 1、创建一个非阻塞的客户端     * 2、设置超时时间     * 3、设置编码解码器     * 4、绑定逻辑处理类     * 5、创建连接     * 6、等待连接创建完成     * 7、获取连接session     * 8、发送数据     * 9、等待关闭连接     *&#x2F;    private final static Logger logger &#x3D; LoggerFactory.getLogger(SocketClient.class);    private IoConnector connector;    private IoSession ioSession;    private AtomicBoolean beKilled&#x3D;new AtomicBoolean(false);    private AtomicBoolean isConnecting&#x3D;new AtomicBoolean(false);    private ProtocolCodecFactory codecFactory;    &#x2F;&#x2F; 延时连接 s    private int delayConnect &#x3D; Configs.getConfig().getIntValue(&quot;SOCKET_DELAY_CONNECT&quot;,5);    &#x2F;&#x2F; 重连间隔 s    private int reConnectInterval &#x3D; Configs.getConfig().getIntValue(&quot;SOCKET_RECONNECT_INTERVAL&quot;,10);    &#x2F;&#x2F; 连接超时时间 s    private int connectTimeout &#x3D; Configs.getConfig().getIntValue(&quot;SOCKET_CONNECT_TIMEOUT&quot;,20);    &#x2F;&#x2F; read idle time s    private int readIdleTime &#x3D; Configs.getConfig().getIntValue(&quot;SOCKET_READIDLE_TIME&quot;,30);    &#x2F;**     * 自动重连     *&#x2F;    private boolean autoReconnect&#x3D;true;    private String ip;    private int port;    public SocketClient(String ip, int port) &#123;        init(ip,port,connectTimeout, readIdleTime);    &#125;    public SocketClient(String ip, int port, int conTimeOut, int idleTime) &#123;        init(ip,port,conTimeOut, idleTime);    &#125;    &#x2F;**     * @description: 初始化连接参数     * @author: bozhiqiang     * @updateTime: 2022&#x2F;7&#x2F;18 18:59     *&#x2F;    private void init(String ip, int port,int conTimeOut, int idleTime) &#123;        this.ip &#x3D; ip;        this.port &#x3D; port;        &#x2F;&#x2F; 创建一个非阻塞的客户端        connector &#x3D; new NioSocketConnector();        connector.setConnectTimeoutMillis(conTimeOut * 1000);        connector.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE,idleTime);        &#x2F;&#x2F;设置过滤链        connector.getFilterChain().addLast(&quot;codec&quot;, new ProtocolCodecFilter(new TextLineCodecFactory()));        connector.getFilterChain().addLast(&quot;executor&quot;, new ExecutorFilter());        connector.addListener(new ClientIoServiceListener());    &#125;    &#x2F;**     * @description: mina socket连接状态监听类：mina socket连接状态监听类，在连接session失效后，自动重连     * @author: bozhiqiang     * @updateTime: 2022&#x2F;7&#x2F;18 19:02     *&#x2F;    private class ClientIoServiceListener implements IoServiceListener &#123;        @Override        public void serviceActivated(IoService service) throws Exception &#123;            &#x2F;&#x2F;logger.debug(&quot;socketClient serviceActivated&quot;);        &#125;        @Override        public void serviceDeactivated(IoService service) throws Exception &#123;            &#x2F;&#x2F;logger.debug(&quot;socketClient serviceDeactivated&quot;);        &#125;        @Override        public void serviceIdle(IoService service, IdleStatus idleStatus)                throws Exception &#123;            logger.debug(&quot;socketClient serviceIdle&quot;);        &#125;        @Override        public void sessionClosed(IoSession session) throws Exception &#123;            logger.debug(&quot;socketClient sessionClosed&quot;);        &#125;        @Override        public void sessionCreated(IoSession session) throws Exception &#123;            logger.debug(&quot;socketClient sessionCreated&quot;);        &#125;        @Override        public void sessionDestroyed(IoSession session) throws Exception &#123;            logger.debug(&quot;socketClient sessionDestroyed! &quot;);            if(autoReconnect)&#123;                delayConnect(delayConnect, TimeUnit.SECONDS);            &#125;        &#125;    &#125;    &#x2F;**     * socket连接断开后，延时重连     * @Description: 在侦听到连接断开事件后，延时重连     * @param delay延时时间     * @param timeUnit延时时间单位     * @return: void     * @Modify:     *&#x2F;    private void delayConnect(long delay, TimeUnit timeUnit) &#123;        logger.debug(&quot;delay &quot; + delay+&quot; &quot;+timeUnit  +&quot; to reconnect&quot;);        scheduleExecutor.schedule(new Runnable() &#123;            public void run() &#123;                try &#123;                    SocketClient.this.connect();                &#125; catch (Exception e) &#123;                    logger.error(&quot;error&quot;, e);                &#125;            &#125;        &#125;, delay, timeUnit);    &#125;    &#x2F;**     * 连接建立线程池，目前只是内部自动重连采用该线程池，外部调用connect方法，还是通过调用线程     *&#x2F;    private static ScheduledExecutorService scheduleExecutor &#x3D; Executors.newScheduledThreadPool(6, new SimpleThreadFactory(&quot;SocketClientConManager&quot;));    &#x2F;**     * 连接服务器     * @Description: SocketClient实例创建后，根据连接参数与服务器建立连接。建立连接为阻塞过程，如连接无法建立当前线程将一直阻塞     * @return: void     * @Modify:     *&#x2F;    public void connect() &#123;        if (isConnecting.get() ||( ioSession !&#x3D; null &amp;&amp;  ioSession.isConnected())) &#123;            return;        &#125;        isConnecting.set(true);        beKilled.set(false);        logger.info(&quot;connecting to &#123;&#125;:&#123;&#125;  &quot;,ip,port );        while(true)&#123;            try&#123;                if(beKilled.get()&#x3D;&#x3D;true)&#123;                    logger.warn(&quot;socketClient was killed, break connect(). &quot;);                    break;                &#125;                &#x2F;&#x2F; 创建连接                ConnectFuture cf &#x3D; connector.connect(new InetSocketAddress(ip, port));                &#x2F;&#x2F; 等待连接创建完成:阻塞直到连接建立,因为我们后面要使用连接成功之后创建的Session对象来进行写数据的操作                cf.awaitUninterruptibly();                &#x2F;&#x2F; 获取连接session                ioSession &#x3D; cf.getSession();                if(ioSession.isConnected())&#123;                    logger.info(&quot;connected to &#123;&#125;:&#123;&#125;&quot;,ip,port);                &#125;                isConnecting.set(false);                break;            &#125; catch(Exception e)&#123;                logger.error(e.getMessage(),e);                if(autoReconnect)&#123;                    logger.warn(&quot;connect to &#123;&#125;:&#123;&#125; failed! reconnect after &#123;&#125; s&quot;,ip,port,reConnectInterval);                    try &#123;                        Thread.sleep(reConnectInterval*1000);                    &#125; catch (InterruptedException e1) &#123;                        e1.printStackTrace();                    &#125;                &#125;                else&#123;                    break;                &#125;            &#125;        &#125;    &#125;    &#x2F;&#x2F; 当前连接是否可用    public boolean isConnected()&#123;        return (ioSession !&#x3D; null &amp;&amp; ioSession.isConnected());    &#125;    &#x2F;**     * 关闭连接     * @Description: 关闭socket连接，如close前，SocketClient实例正在进行连接建立（或重连）操作，则关闭后，连接建立或重连操作也将取消     * @return: void     * @Modify:     *&#x2F;    public void close() &#123;        if (ioSession !&#x3D; null &amp;&amp; ioSession.isConnected()) &#123;            ioSession.closeNow();        &#125;        if(connector!&#x3D;null)&#123;            connector.dispose();        &#125;        beKilled.set(true);    &#125;    &#x2F;**     * 发送报文     * @Description: 通过ioSession.write发送报文到服务端     * @param messagesbyte[] 报文，AMR自定义报文格式     * @return: void     * @Modify:     *&#x2F;    public boolean sendMessage(byte[] messages) &#123;        if (ioSession !&#x3D; null &amp;&amp; ioSession.isConnected()) &#123;            try &#123;                ioSession.write(messages);                logger.debug(&quot;forward to server:&quot; + CommUtils.byteToHexString(messages));            &#125; catch (Exception e) &#123;                logger.error(&quot;&quot;,e);                return false;            &#125;        &#125; else &#123;            logger.info(&quot;IoSession is not connected! &quot; + ioSession);            return false;        &#125;        return true;    &#125;    public String getIp() &#123;        return ip;    &#125;    public void setIp(String ip) &#123;        this.ip &#x3D; ip;    &#125;    public int getPort() &#123;        return port;    &#125;    public void setPort(int port) &#123;        this.port &#x3D; port;    &#125;    public void setDataHandler(IoHandler dataHandler) &#123;        connector.setHandler(dataHandler);    &#125;    public void setCodecFactory(ProtocolCodecFactory codecFactory) &#123;        this.codecFactory &#x3D; codecFactory;    &#125;    public IoSession getIoSession() &#123;        return ioSession;    &#125;    public AtomicBoolean getBeKilled() &#123;        return beKilled;    &#125;    public void setBeKilled(AtomicBoolean beKilled) &#123;        this.beKilled &#x3D; beKilled;    &#125;    public int getDelayConnect() &#123;        return delayConnect;    &#125;    public void setDelayConnect(int delayConnect) &#123;        this.delayConnect &#x3D; delayConnect;    &#125;    public int getReConnectInterval() &#123;        return reConnectInterval;    &#125;    public void setReConnectInterval(int reConnectInterval) &#123;        this.reConnectInterval &#x3D; reConnectInterval;    &#125;    public int getConnectTimeout() &#123;        return connectTimeout;    &#125;    public void setConnectTimeout(int connectTimeout) &#123;        this.connectTimeout &#x3D; connectTimeout;    &#125;    public int getReadIdleTime() &#123;        return readIdleTime;    &#125;    public void setReadIdleTime(int readIdleTime) &#123;        this.readIdleTime &#x3D; readIdleTime;    &#125;    public boolean isAutoReconnect() &#123;        return autoReconnect;    &#125;    public void setAutoReconnect(boolean autoReconnect) &#123;        this.autoReconnect &#x3D; autoReconnect;    &#125;&#125;</code></pre><h4 id="2-2-客户端Socket封装"><a href="#2-2-客户端Socket封装" class="headerlink" title="2.2 客户端Socket封装"></a>2.2 客户端Socket封装</h4><pre class="language-java" data-language="java"><code class="language-java">package com.techen.mina.client;import com.techen.mina.utils.Configs;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;&#x2F;** * @ClassName JobServer * @description: * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-18 19:50:26 *&#x2F;public class JobServer &#123;    String ip;    int port;    &#x2F;&#x2F; 终端数据处理器    private DataHandler clientTaskDataHandler;    &#x2F;&#x2F; 终端上线端口服务    private SocketClient socketClient;    &#x2F;**     * 任务服务器、前置机连接集合，key为前置机的serverId     *&#x2F;    public static Map&lt;String,SocketClient&gt; onlineClients;    public JobServer()&#123;        onlineClients &#x3D; new ConcurrentHashMap&lt;&gt;();    &#125;    &#x2F;&#x2F; 服务启动时调用即可    public void start() &#123;        &#x2F;&#x2F; 启动终端通信监听        ip &#x3D; Configs.getConfig().getValue(&quot;server_ip&quot;, &quot;127.0.0.1&quot;);        port &#x3D; Configs.getConfig().getIntValue(&quot;server_port&quot;, 7950);        &#x2F;&#x2F; 初始化ip、port、创建创建一个非阻塞的客户端(connect)        socketClient &#x3D; new SocketClient(ip,port);        &#x2F;&#x2F; 设置处理器        socketClient.setDataHandler(getClientTaskDataHandler());        &#x2F;&#x2F; 将连接加入到容器当中        onlineClients.put(&quot;1&quot;,socketClient);        &#x2F;&#x2F; 创建连接、获取IoSession        socketClient.connect();    &#125;    public DataHandler getClientTaskDataHandler() &#123;        return clientTaskDataHandler;    &#125;    public void setClientTaskDataHandler(DataHandler clientTaskDataHandler) &#123;        this.clientTaskDataHandler &#x3D; clientTaskDataHandler;    &#125;    public static Map&lt;String, SocketClient&gt; getOnlineClients() &#123;        return onlineClients;    &#125;&#125;</code></pre><h4 id="2-3-DataHandler数据处理"><a href="#2-3-DataHandler数据处理" class="headerlink" title="2.3 DataHandler数据处理"></a>2.3 DataHandler数据处理</h4><pre class="language-java" data-language="java"><code class="language-java">package com.techen.mina.client;import org.apache.mina.core.service.IoHandlerAdapter;import org.apache.mina.core.session.IdleStatus;import org.apache.mina.core.session.IoSession;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import java.nio.charset.StandardCharsets;&#x2F;** * @ClassName DataHandler * @description: * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-15 09:59:56 *&#x2F;@Componentpublic abstract class DataHandler extends IoHandlerAdapter &#123;    private static final Logger logger &#x3D; LoggerFactory.getLogger(DataHandler.class);    public DataHandler() &#123;        super();    &#125;    @Override    public void sessionCreated(IoSession session) throws Exception &#123;        logger.info(&quot;客端登录成功&quot;);    &#125;    @Override    public void sessionOpened(IoSession session) throws Exception &#123;        logger.info(&quot;服务端与客户端连接打开&quot;);    &#125;    @Override    public void sessionClosed(IoSession session) throws Exception &#123;        logger.info(&quot;客户端登录关闭&quot;);    &#125;    @Override    public void sessionIdle(IoSession session, IdleStatus status) throws Exception &#123;        logger.info(&quot;服务端进入空闲状态&quot;);    &#125;    @Override    public void exceptionCaught(IoSession session, Throwable cause) throws Exception &#123;        logger.error(&quot;服务端发生异常&quot;, cause);    &#125;    @Override    public void messageReceived(IoSession session, Object message) throws Exception &#123;        byte[] msgBytes &#x3D; message.toString().getBytes(StandardCharsets.UTF_8);        try &#123;            this.messageReceived(session, msgBytes);        &#125; catch (Exception var6) &#123;            logger.error(var6.getMessage(), var6);        &#125;    &#125;    public abstract void messageReceived(IoSession var1, byte[] var2);    @Override    public void messageSent(IoSession session, Object message) throws Exception &#123;    &#125;    @Override    public void inputClosed(IoSession session) throws Exception &#123;        logger.info(&quot;输入关闭&quot;);    &#125;&#125;&#x2F;**-----------------------------------------------------------------------------------------------------**&#x2F;    package com.techen.mina.client;import com.techen.mina.utils.CommUtils;import com.techen.mina.utils.Configs;import org.apache.mina.core.session.IdleStatus;import org.apache.mina.core.session.IoSession;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.net.InetSocketAddress;&#x2F;** * @ClassName ClientTaskDataHandler * @description: 该处理器的作用主要是接收信息,并维持心跳 * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-18 19:43:00 *&#x2F;public class ClientTaskDataHandler extends DataHandler &#123;    private static final Logger logger &#x3D; LoggerFactory.getLogger(ClientTaskDataHandler.class);    @Override    public void messageReceived(IoSession session, byte[] message) &#123;        logger.info(&quot;客户端收到消息:&#123;&#125;&quot;, CommUtils.byteToHexString(message));    &#125;    @Override    public void sessionIdle(IoSession session, IdleStatus status) throws Exception &#123;        InetSocketAddress remoteSocketAddress &#x3D; (InetSocketAddress)session.getRemoteAddress();        &#x2F;&#x2F;超过2个心跳周期未收到前置机报文，断开连接        if(session.getIdleCount(IdleStatus.READER_IDLE) &gt;Integer.parseInt(Configs.getConfig().getValue(&quot;max_heart_count&quot;, &quot;2&quot;)))&#123;            logger.info(&quot;taskclient readidle count&gt;&#x3D;2, close now. &#123;&#125;&quot;,remoteSocketAddress);            session.closeNow();            return;        &#125;        &#x2F;&#x2F;发送心跳报文        if(status&#x3D;&#x3D;IdleStatus.READER_IDLE)&#123;            logger.debug(&quot;send heart bytes to:&#123;&#125;&quot;,remoteSocketAddress);            session.write(&quot;心跳报文&quot;);        &#125;    &#125;    @Override    public void sessionOpened(IoSession session) throws Exception &#123;        &#x2F;&#x2F;发送登录报文        InetSocketAddress remoteSocketAddress &#x3D; (InetSocketAddress)session.getRemoteAddress();        logger.info(&quot;send login bytes to:&#123;&#125;&quot;,remoteSocketAddress);        session.write(&quot;登录报文&quot;);    &#125;&#125;</code></pre><h4 id="2-4-容器启动时创建"><a href="#2-4-容器启动时创建" class="headerlink" title="2.4 容器启动时创建"></a>2.4 容器启动时创建</h4><pre class="language-java" data-language="java"><code class="language-java">package com.techen.mina;import com.techen.mina.client.ClientTaskDataHandler;import com.techen.mina.client.JobServer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SocketMinaApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SocketMinaApplication.class, args);        JobServer jobServer &#x3D; new JobServer();        jobServer.setClientTaskDataHandler(new ClientTaskDataHandler());        jobServer.start();    &#125;&#125;</code></pre><h4 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h4><pre class="language-java" data-language="java"><code class="language-java">package com.techen.mina.controller;import com.techen.mina.client.JobServer;import com.techen.mina.client.SocketClient;import com.techen.mina.utils.CommUtils;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;&#x2F;** * @ClassName ClientController * @description: * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-19 10:06:19 *&#x2F;@RestControllerpublic class ClientController &#123;    @GetMapping(&quot;&#x2F;test1&quot;)    public void test1()&#123;        SocketClient socketClient &#x3D; JobServer.getOnlineClients().get(&quot;1&quot;);        &#x2F;&#x2F; 发送报文到服务端        socketClient.sendMessage(CommUtils.hex2BinaryLH(&quot;168e200e200684b000586000210f70000010002cbbc0a100068562113000000681104333334333c1600000000000000000000000000000000574010090800c916&quot;));    &#125;    @GetMapping(&quot;&#x2F;test2&quot;)    public void test2()&#123;        SocketClient socketClient &#x3D; JobServer.getOnlineClients().get(&quot;1&quot;);        &#x2F;&#x2F; 发送报文到服务端        socketClient.sendMessage(CommUtils.hex2BinaryLH(&quot;268e200e200684b000586000210f70000010002cbbc0a100068562113000000681104333334333c1600000000000000000000000000000000574010090800c916&quot;));    &#125;    @GetMapping(&quot;&#x2F;test3&quot;)    public void test3()&#123;        SocketClient socketClient &#x3D; JobServer.getOnlineClients().get(&quot;1&quot;);        &#x2F;&#x2F; 发送报文到服务端        socketClient.sendMessage(CommUtils.hex2BinaryLH(&quot;368e200e200684b000586000210f70000010002cbbc0a100068562113000000681104333334333c1600000000000000000000000000000000574010090800c916&quot;));    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
            <tag> 网络通信 </tag>
            
            <tag> 长链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java调用C动态库</title>
      <link href="/2022/07/18/java-diao-yong-c-dong-tai-ku/"/>
      <url>/2022/07/18/java-diao-yong-c-dong-tai-ku/</url>
      
        <content type="html"><![CDATA[<p>java调用C++动态库</p><p>由于项目，需要调用明华IC卡读卡器接口，项目使用的语言是java，所以需要用到java的JNA技术，去调用C的DLL动态库</p><h3 id="一、JNI、JNA介绍"><a href="#一、JNI、JNA介绍" class="headerlink" title="一、JNI、JNA介绍"></a>一、JNI、JNA介绍</h3><blockquote><p>java调用C的方式有两种JNA、JNI</p><p>JNI(Java Native Interface):通过使用 Java本地接口书写程序，可以确保代码在不同的平台上方便移植</p><p>JNA（Java Native Access）：提供一组Java工具类用于在运行期间动态访问系统本地库（native library：如Window的dll）而不需要编写任何Native&#x2F;JNI代码。开发人员只要在一个java接口中描述目标native library的函数与结构，JNA将自动实现Java接口到native function的映射。<br>简而言之，就是jna基于jni的方式封装了很多api，在使用上面相对于jni来说简化了很多。</p><p>JNA全称Java  Access，是一个建立在经典的JNI技术之上的Java开源框架。JNA提供一组Java工具类用于在运行期动态访问系统本地库（native library：如Window的dll）而不需要编写任何Native&#x2F;JNI代码。开发人员只要在一个java接口中描述目标native library的函数与结构，JNA将自动实现Java接口到native function的映射。</p><p>需要注意的是：在使用JNI技术调用dll动态链接库时，32位dll只能是32位JDK去调用，64位dll只能是64位JDK去调用。这个必须是这样的，如果发现无法调用或者提示版本错误，首先要检查下JDK的位数和dll的位数是否是对应的。</p></blockquote><h3 id="二、代码演示"><a href="#二、代码演示" class="headerlink" title="二、代码演示"></a>二、代码演示</h3><h4 id="1、引入jar包"><a href="#1、引入jar包" class="headerlink" title="1、引入jar包"></a>1、引入jar包</h4><pre class="language-java" data-language="java"><code class="language-java">&lt;dependency&gt;    &lt;groupId&gt;net.java.dev.jna&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;jna&lt;&#x2F;artifactId&gt;    &lt;version&gt;5.12.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><h4 id="2、定义接口，创建动态库实例和动态库接口"><a href="#2、定义接口，创建动态库实例和动态库接口" class="headerlink" title="2、定义接口，创建动态库实例和动态库接口"></a>2、定义接口，创建动态库实例和动态库接口</h4><blockquote><p>1、接口需要继承Library类</p><p>2、定义动态库接口</p><p>3、定义动态库实例</p></blockquote><pre class="language-java" data-language="java"><code class="language-java">package com.test.jnademo.utils;import com.sun.jna.Library;import com.sun.jna.Native;import com.sun.jna.ptr.IntByReference;import java.io.File;&#x2F;** * @ClassName JnaUtils * @description: * @author: codesheep * @Version 1.0.0 * @createTime: 2022-07-18 09:10:47 *&#x2F;public class JnaInterface &#123;    &#x2F;**     * @description:  明华IC卡读卡器接口:IC（Integrated Circuit）卡，也被称作智能卡（Smart Card），具有写入数据和存储数据的功能，IC卡内存储器的内容可以根据需要有条件地供外部读取，完成信息处理和判定。     * IC卡是携带应用信息和数据的媒体，空白IC卡是不能立即使用的，必须对IC卡应用系统进行初始化，写入系统IC卡和个人密码，个人专用信息和应用数据,所以需要用到读卡器进行操作     * @author: bozhiqiang     * @updateTime: 2022&#x2F;7&#x2F;18 10:33     *&#x2F;    public interface MwIc extends Library &#123;        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;  动态库实例 &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;        &#x2F;&#x2F; load需要指定绝对路径        File file &#x3D; new File(&quot;src&#x2F;main&#x2F;resources&#x2F;lib&#x2F;Mwic_32.dll&quot;);        MwIc INSTANCE  &#x3D;  Native.load(file.getAbsolutePath(),MwIc.class);        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;  动态库接口 &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;        &#x2F;**         * 说明：初始化通讯接口         * 调用：Port: 通讯口号 0、1、2、3 分别代表串口 1、2、3、4 ; baud: 通讯口为串口时代表波特率，其值可为 1200-115200         * 返回：   &lt;0 错误 ; &gt;0 通讯设备标识符         * 举例： icdev&#x3D;ic_init(0,9600);初始化串口 1，波特率为 9600         *&#x2F;        public int ic_init(int port,long baud);        &#x2F;**         * 说明： 关闭通讯口,串口、USB 接口都使用这个函数         * 调用： icdev: 通讯设备标识符         * 返回： &lt;0 错误;&#x3D;0 正确         * 举例： st&#x3D;ic_exit(icdev);         *&#x2F;        public short ic_exit(int icdev);        &#x2F;**         * 说明： 读写器蜂鸣（RD 读写器专用函数）         * 调用： icdev: 通讯设备标识符;time: 蜂鸣时间，值范围 0-255（单位 10ms）         * 返回： &lt;0 错误;&#x3D;0 正确         * 举例： st&#x3D;ic_beep(icdev,100);         *&#x2F;        public short dv_beep(int icdev,short time);        &#x2F;**         * 说明： 读取设备版本号         * 调用： icdev: 通讯设备标识符,len: 版本号字符串长度，其值为 18,databuff: 存放读取的版本号字符串         * 返回： &lt;0 错误,&#x3D;0 正确         * 举例： unsigned char databuff[18];st&#x3D;srd_ver(icdev,18,databuff);         *&#x2F;        public short srd_ver(int icdev,short len,byte[] databuff);        &#x2F;**         * 说明： 检查卡型是否正确         * 调用： icdev: 通讯设备标识符         * 返回： &lt;0 错误,&#x3D;0 正确         * 举例： st&#x3D;chk_4442(icdev)         *&#x2F;        public short chk_4442(int icdev);        &#x2F;**         * 说明： 返回设备当前状态         * 调用： icdev: 通讯设备标识符         * state: 插卡状态         *          1)有检测脚的卡座，读写器返回 4 种插卡状态：         *          00——无卡         *          01——有用户卡         * 返回： &lt;0 错误;&#x3D;0 正确，         * 举例： int status;st&#x3D;get_status(icdev,&amp;status);         *&#x2F;        public short get_status(int icdev, IntByReference statu);        public short srd_4442(int icdev,short offset,short len,byte[] data_buffer);        public short swr_4442(int icdev,short offset,short len,byte[] data_buffer);        public short prd_4442(int icdev,short len,byte[] data_buffer);        public short pwr_4442(int icdev,short offset,short len,byte[] data_buffer);        public short csc_4442(int icdev,short len,byte[] data_buffer);        public short wsc_4442(int icdev,short len,byte[] data_buffer);        public short rsc_4442(int icdev,short len,byte[] data_buffer);        public short rsct_4442(int icdev,IntByReference counter);        public short hex_asc(byte[] hex,byte[] asc,short len);        public short asc_hex(byte[] asc,byte[] hex,short len);    &#125;&#125;</code></pre><h4 id="3、工具类封装"><a href="#3、工具类封装" class="headerlink" title="3、工具类封装"></a>3、工具类封装</h4><pre class="language-java" data-language="java"><code class="language-java">package com.test.jnademo.utils;import com.sun.jna.ptr.IntByReference;&#x2F;** * @ClassName JnaUtils * @description: * @author: bozhiqiang * @Version 1.0.0 * @createTime: 2022-07-18 10:38:25 *&#x2F;public class JnaUtils &#123;    public static class MwIc&#123;        &#x2F;**         * @param args         *&#x2F;        int icdev&#x3D;0;        short st&#x3D;1;        byte[] ver&#x3D;new byte[20];        public void DevConnect(JnaInterface.MwIc epen) &#123;            icdev&#x3D;epen.ic_init(0, 9600);            st&#x3D;epen.srd_ver(icdev, (short)18, ver);            if(st!&#x3D;0) &#123;                System.out.println(&quot;ic_init error!&quot;);            &#125;            else &#123;                String str&#x3D;new String(ver,0,18);                System.out.println(str);            &#125;            epen.dv_beep(icdev, (short)30);        &#125;        public void disconnectDev(JnaInterface.MwIc epen) &#123;            epen.ic_exit(icdev);            &#x2F;&#x2F;System.out.println(&quot;ceshi&quot;);        &#125;        public void Card4442(JnaInterface.MwIc epen) &#123;            IntByReference ret &#x3D; new IntByReference();            st&#x3D;epen.get_status(icdev,  ret);            if(st!&#x3D;0) &#123;                System.out.println(&quot;get_status error!&quot;);            &#125;            else &#123;                System.out.println(&quot;ret is &quot;+ ret.getValue());            &#125;            st&#x3D;epen.chk_4442(icdev);            if(st!&#x3D;0) &#123;                System.out.println(&quot;chk_4442 error!&quot;);            &#125;            IntByReference counter&#x3D;new IntByReference();            st&#x3D;epen.rsct_4442(icdev, counter);            if(st!&#x3D;0) &#123;                System.out.println(&quot;rsct_4442 error!&quot;);            &#125;            else &#123;                System.out.println(counter.getValue());            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="4、调用"><a href="#4、调用" class="headerlink" title="4、调用"></a>4、调用</h4><pre class="language-java" data-language="java"><code class="language-java">package com.test.jnademo;import com.test.jnademo.utils.JnaInterface;import com.test.jnademo.utils.JnaUtils;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass JnaDemoApplicationTests &#123;    @Test    void contextLoads() &#123;        JnaInterface.MwIc epen &#x3D; JnaInterface.MwIc.INSTANCE;        if (epen !&#x3D; null)&#123;            System.out.println(&quot;DLL连接成功!&quot;);        &#125; else&#123;            System.out.println(&quot;DLL连接失败!&quot;);        &#125;        JnaUtils.MwIc con&#x3D;new JnaUtils.MwIc();        con.DevConnect(epen);        con.Card4442(epen);        con.disconnectDev(epen);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JNA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mina基础(一):基础介绍</title>
      <link href="/2022/07/17/mina-ji-chu-yi-ji-chu-jie-shao/"/>
      <url>/2022/07/17/mina-ji-chu-yi-ji-chu-jie-shao/</url>
      
        <content type="html"><![CDATA[<p><strong>1、在应用程序中的地位</strong></p><pre class="language-none"><code class="language-none">主要屏蔽了网络通信的一些细节，对Socket进行封装，并且是NIO的一个实现架构，可以帮助我们快速的开发网络通信，常用于游戏的开发、中间件服务端的程序中。Mina最主要的工作就是把底层传输的字节码转换为Java对象，提供给应用程序；或者把应用程序返回的结果转换为字节码，交给底层传输。</code></pre><p><strong>2、长短链接</strong></p><blockquote><p>长链接和短链接<br>长链接：通信双方长期保持一个链接状态不断开，比如QQ，当我们登陆QQ的时候，就会链接腾讯的服务器建立一个链接，链接一旦建立就一会断开，除非发生异常<br>短链接：通信双方不是保持一个长链接状态，比如http协议，请求数据响应完成之后，链接就会断开</p></blockquote><p><strong>3、IOService接口</strong></p><p>*<strong>实现了对网络通信的客户端和服务端之间的抽象，子接口IOConnector用于描述客户端，子接口IOAcceptor用于描述服务端。*</strong></p><p>  <strong>作用：</strong>IOService可以管理我们网络通信的客户端和服务端，并且可以管理连接双方的会话session，同样可以添加过滤器。</p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220717174143094.png" alt="image-20220717174143094" style="zoom:50%;" /><blockquote><p>IoService接口声明了服务端的共有属性和行为；</p><p>IoAcceptor接口继承了IoService接口，并添加了服务端特有的接口属性及方法，比如bind（）方法，成为典型的服务端接口；</p><p>IoConnector接口同样继承了IoService接口，并添加了客户端特有的接口属性及方法，比如connect（）方法，成为典型的客户端接口；</p><p>AbstractIoService实现了IoService中管理服务的方法，比如getFilterChainBuilder方法—获得过滤器链；</p><p>AbstractIoService抽象类继承了AbstractIoService抽象类并实现了IoAcceptor接口，成为了拥有管理服务端实现功能的服务端类；我们常用的NioSocketAcceptor就是它的子类；</p><p>AbstractIoConnector抽象类继承了AbstractIoService抽象类并实现了IoConnector接口，成为了拥有管理客户端实现功能的客户端类；我们常用的NioSocketConnector就是它的子类；</p></blockquote><p><strong>4、编码解码</strong></p><p>前面提到Mina最主要的工作就是把底层传输的字节码转换为Java对象，提供给应用程序；或者把应用程序返回的结果转换为字节码，交给底层传输。</p><blockquote><p>应用程序         网络<br>java对象或者基本数据类型   二进制</p><p>对象输出到网络———————编码—————————-&gt;需要编码成二进制</p><p>网络传入的应用程序&lt;—————————解码—————-需要解码成java对象或者基本数据类型</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
            <tag> 网络通信 </tag>
            
            <tag> 长链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis分页</title>
      <link href="/2022/07/14/mybatis-fen-ye/"/>
      <url>/2022/07/14/mybatis-fen-ye/</url>
      
        <content type="html"><![CDATA[<p>mybatis分页查询</p><pre class="language-none"><code class="language-none">1、分页类定义    package com.techen.tap.vo;import java.io.Serializable;import java.util.Map;import lombok.Getter;import lombok.Setter;&#x2F;** * 分页查询参数 * @author sunmingzhi * @date 2019年11月22日 下午7:23:57   * @Modify *&#x2F;@Getter@Setterpublic class PageQuery implements Serializable &#123;    private static final long serialVersionUID &#x3D; 1L;    &#x2F;&#x2F; 当前页码    private int currentPage;    &#x2F;&#x2F; 每页条数    private int pageSize;    &#x2F;&#x2F; 排序字段    private String sidx;    &#x2F;&#x2F; 顺序    private String sord;    &#x2F;**     * 构造函数     * @Title:Query     * @Description:     * @param params     *&#x2F;    public PageQuery(Map&lt;String, Object&gt; params) &#123;        this.currentPage &#x3D; Integer.parseInt(params.get(&quot;currentPage&quot;).toString());        this.pageSize &#x3D; Integer.parseInt(params.get(&quot;pageSize&quot;).toString());        this.sidx &#x3D; params.get(&quot;sidx&quot;).toString();        this.sord &#x3D; params.get(&quot;sord&quot;).toString();    &#125;&#125;2、分页查询结果package com.techen.tap.vo;import java.io.Serializable;import java.util.List;import lombok.Data;&#x2F;** * @description:分页查询结果 * @author: zs * @date: 2019年8月17日上午9:52:48 * @modify: *&#x2F;@Datapublic class Page implements Serializable &#123;    private static final long serialVersionUID &#x3D; 1L;    &#x2F;&#x2F; 总记录数    private int totalCount;    &#x2F;&#x2F; 每页记录数    private int pageSize;    &#x2F;&#x2F; 总页数    private int totalPage;    &#x2F;&#x2F; 当前页数    private int currentPage;    &#x2F;&#x2F; 列表数据    private List&lt;?&gt; dataList;    public Page(List&lt;?&gt; dataList, int totalCount, int pageSize, int currentPage) &#123;        this.dataList &#x3D; dataList;        this.totalCount &#x3D; totalCount;        this.pageSize &#x3D; pageSize;        this.currentPage &#x3D; currentPage;        this.totalPage &#x3D; (int) Math.ceil((double) totalCount &#x2F; pageSize);    &#125;&#125;3、分页逻辑@GetMapping(value &#x3D; &quot;&#x2F;meterlist&quot;)public ResponseResult&lt;Object&gt; meterlist(@RequestParam(required &#x3D; false) Map&lt;String, Object&gt; paraMap) &#123;    PageQuery query &#x3D; new PageQuery(paraMap);    &#x2F;&#x2F;拼接查询语句---sql语句(拼接前台选择的查询条件)    &#x2F;**    String sqlWhere &#x3D; this.spellListSql(paraMap);    sqlWhere +&#x3D; &quot; and c_meter.run_status_code&lt;&gt;&#39;9&#39;&quot;;    **&#x2F;    paraMap.put(&quot;whereSql&quot;, sqlWhere);    &#x2F;&#x2F;查询符合条件的总数量    int totalCount &#x3D; service.count(paraMap);    List&lt;Map&lt;String, Object&gt;&gt; tempList &#x3D; new ArrayList&lt;Map&lt;String, Object&gt;&gt;();    if (totalCount &gt; 0) &#123;       &#x2F;&#x2F;进行分页查询---查询结果是List       tempList &#x3D; service.queryMapForPage(sqlWhere, query.getCurrentPage(), query.getPageSize(),                                                                           query.getSidx(),query.getSord());       service.setDispFields(tempList);    &#125;    &#x2F;&#x2F;组装分页查询到的分页类    Page page &#x3D; new Page(tempList, totalCount, query.getPageSize(), query.getCurrentPage());    &#x2F;&#x2F;返回分页信息    return ResponseResult.ok(page);&#125;4、分页sql  &lt;select id&#x3D;&quot;queryMapForPage&quot; resultType&#x3D;&quot;com.techen.tap.base.BasicLowerMap&quot; parameterType&#x3D;&quot;map&quot;&gt;        &lt;![CDATA[            SELECT * FROM file_upload_details             WHERE $&#123;whereSql&#125;            order by $&#123;sidx&#125; $&#123;sord&#125;,id asc             &lt;!-- 查询pagesize条语句，从begincount开始 --&gt;            limit #&#123;pagesize&#125; offset #&#123;begincount&#125;          ]]&gt;   &lt;&#x2F;select&gt;    &#x2F;&#x2F;注意  public List&lt;Map&lt;String, Object&gt;&gt; queryMapForPage(String whereSql, int curPageIndex, int pageSize, String                                                                                        sidx, String sord) &#123;    int beginCount &#x3D; curPageIndex * pageSize - pageSize;    Map&lt;String, Object&gt; paraMap &#x3D; new HashMap&lt;String, Object&gt;();    paraMap.put(&quot;begincount&quot;, beginCount);    paraMap.put(&quot;pagesize&quot;, pageSize);    paraMap.put(&quot;whereSql&quot;, whereSql);    paraMap.put(&quot;sidx&quot;, sidx);    paraMap.put(&quot;sord&quot;, sord);    return this.getSqlSessionTemplate().selectList(entityClass.getName() + &quot;.queryMapForPage&quot; , paraMap);&#125;  5、拼接sqlprotected String convertSql(Map&lt;String, Object&gt; paraMap) &#123;        StringBufferProxy sql &#x3D; new StringBufferProxy();        sql.appendSingle(&quot; 1&#x3D;1 &quot;);        if (paraMap.containsKey(&quot;file_name&quot;) &amp;&amp; !StringUtils.isEmpty(paraMap.get(&quot;file_name&quot;))) &#123;            String value &#x3D; paraMap.get(&quot;file_name&quot;).toString();            if (!StringUtil.isEmpty(value)) &#123;                sql.appendSingle(&quot; and file_name like &#39;%&#123;0&#125;%&#39; &quot;, value);            &#125;        &#125;        if (paraMap.containsKey(&quot;data_date&quot;) &amp;&amp; !StringUtils.isEmpty(paraMap.get(&quot;data_date&quot;))) &#123;            String value &#x3D; paraMap.get(&quot;data_date&quot;).toString();            String getLastDayOfMonth&#x3D;DateUtil.getLastDayOfMonth(value);            String date1&#x3D;value+&quot; 00:00:00&quot;;            String date2&#x3D;getLastDayOfMonth+&quot; 00:00:00&quot;;            if (!StringUtil.isEmpty(value)) &#123;                sql.appendSingle(&quot; and createon between &#39;&#123;0&#125;&#39; and &#39;&#123;1&#125;&#39;&quot;, date1, date2);            &#125;        &#125;        if (paraMap.containsKey(&quot;createuser&quot;) &amp;&amp; !StringUtils.isEmpty(paraMap.get(&quot;createuser&quot;))) &#123;            String createuser &#x3D; paraMap.get(&quot;createuser&quot;).toString();            List&lt;CboUser&gt; cboUsers &#x3D; cboUserService.queryByWhere(&quot; cbo_user.name like &#39;%&quot; + createuser + &quot;%&#39;&quot;);            Long[] idArray &#x3D; new Long[cboUsers.size()];            for (int i &#x3D; 0; i &lt; cboUsers.size(); i++) &#123;                idArray[i] &#x3D; cboUsers.get(i).getId();            &#125;            String substring &#x3D; Arrays.toString(idArray);            substring &#x3D; substring.substring(1, substring.length() - 1);            sql.appendSingle(&quot; and createuser  in (&quot; + substring + &quot;)&quot;);        &#125;        if (paraMap.containsKey(&quot;upload_status&quot;)) &#123;            String value &#x3D; paraMap.get(&quot;upload_status&quot;).toString();            if (!StringUtil.isEmpty(value)) &#123;                sql.appendSingle(&quot; and upload_status &#x3D; &#39;&#123;0&#125;&#39;&quot;, value);            &#125;        &#125;        return sql.toString();    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows下查找java应用内存情况分析</title>
      <link href="/2022/07/14/windows-xia-cha-zhao-java-ying-yong-nei-cun-qing-kuang-fen-xi/"/>
      <url>/2022/07/14/windows-xia-cha-zhao-java-ying-yong-nei-cun-qing-kuang-fen-xi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_14996421/article/details/115726673?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-115726673-blog-105843937.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/qq_14996421/article/details/115726673?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-115726673-blog-105843937.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p><p>在65服务器上查看各java应用的内存占用情况，大多数应用的CPU占用都在1%-5%之间，但是nb-hes的内存占用长期达到了13%左右，遂开始排查nb-hes占用内存过分高的原因，具体步奏如下。</p><h2 id="一、JConsole"><a href="#一、JConsole" class="headerlink" title="一、JConsole"></a>一、JConsole</h2><p>排查65服务器上个java应用的内存占用情况</p><p>JConsole是JDK自带的一个工具，也是 一个图形界面的工具，只要装了JDK就有这个工具；可以直接在服务器上连接本地的java进程，也可以从本机去跟踪远程服务器上的一个进程，如下图所示：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615194250948.png" alt="image-20220615194250948"></p><p>点击连接即可</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615194903776.png" alt="image-20220615194903776"></p><p>确认连接</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615195009791.png" alt="image-20220615195009791"></p><p>服务器上面的基本情况如下：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615195315959.png" alt="image-20220615195315959"></p><p>可以看到CPU占用比较高</p><h2 id="二、使用任务管理器查询应用所在详情-PID、安装位置"><a href="#二、使用任务管理器查询应用所在详情-PID、安装位置" class="headerlink" title="二、使用任务管理器查询应用所在详情(PID、安装位置)"></a>二、使用任务管理器查询应用所在详情(PID、安装位置)</h2><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615200142459.png" alt="image-20220615200142459"></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615200343473.png" alt="image-20220615200343473"></p><h2 id="三、使用Jstack下载stack信息到某个位置"><a href="#三、使用Jstack下载stack信息到某个位置" class="headerlink" title="三、使用Jstack下载stack信息到某个位置"></a>三、使用Jstack下载stack信息到某个位置</h2><p>使用Jstack将第二步查询到的PID对应的应用的stack信息下载下来</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615195812485.png" alt="image-20220615195812485"></p><h2 id="四、-Process-Explorer"><a href="#四、-Process-Explorer" class="headerlink" title="四、 Process Explorer"></a>四、 Process Explorer</h2><p>用的是微软提供的 Process Explorer工具，排查上一步查询的进程当中，那个线程所占用的内存最多。</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615201109069.png" alt="image-20220615201109069"></p><h2 id="五、找到占用内存多的那段代码"><a href="#五、找到占用内存多的那段代码" class="headerlink" title="五、找到占用内存多的那段代码"></a>五、找到占用内存多的那段代码</h2><p>由于stack导出的信息里面线程对应的tid是16进制的，所以要把前面的线程的TID转成16进制的，再在stack导出的文件当中全局搜索该PID(9726—&gt;25FC)</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615201211363.png" alt="image-20220615201211363"></p><h2 id="六、分析"><a href="#六、分析" class="headerlink" title="六、分析"></a>六、分析</h2><p>在代码当中查找该段代码，发现是由于引入的第三方的这个Jar包里面写了一个死循环，去一直监听设备的上线下</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220615201654127.png" alt="image-20220615201654127"></p><p>为了验证是否是死循环引起的，现在修改代码不做成死循环</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220616093046466.png" alt="image-20220616093046466"></p><p>打包后重新运行程序，再次测试内存占比，情况如下</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220702135156318.png" alt="image-20220702135156318"></p><p>由此确定，确实是由于这段代码引起的！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存分析 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSql数组及JSON类型数据在Mybatis项目中的使用</title>
      <link href="/2022/07/12/postgresql-shu-zu-ji-json-lei-xing-shu-ju-zai-mybatis-xiang-mu-zhong-de-shi-yong/"/>
      <url>/2022/07/12/postgresql-shu-zu-ji-json-lei-xing-shu-ju-zai-mybatis-xiang-mu-zhong-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>postgresql提供了很多数据类型，某些特殊的类型无法同java数据类型映射。Mybatis提供了一些默认的TypeHandler，但不包含诸如数组、json这些类型在内。为了使用pgsql的这些类型，我们可以自己添加一些特定的typehandler，注册后就可以标注使用了。</p><p><strong>基本操作流程如下：</strong></p><pre class="language-java" data-language="java"><code class="language-java">1、定义实体类，继承BaseTypeHandler  2、在映射文件当中指明typeHandler是这个实体类  3、字符赋值为JSONObject类型</code></pre><p><strong>实体类代码块：</strong></p><pre class="language-java" data-language="java"><code class="language-java">package com.techen.ami.hes.jobserver.entity;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import com.alibaba.fastjson.JSON;import org.apache.ibatis.type.BaseTypeHandler;import org.apache.ibatis.type.JdbcType;import org.postgresql.util.PGobject;&#x2F;** * @description: postgresql提供了很多数据类型，某些特殊的类型无法同java数据类型映射。Mybatis提供了一些默认的TypeHandler，但不包含诸如数组、json这些类型在内。为了使用pgsql的这些类型，我们可以自己添加一些特定的typehandler，注册后就可以标注使用了。 * @author: bozhiqiang * @updateTime: 2022&#x2F;7&#x2F;12 17:07 * @Param:  * @return:  * @throw: *&#x2F;public class JsonTypeHandler extends BaseTypeHandler&lt;Object&gt; &#123;    private static final PGobject pgObject &#x3D; new PGobject();    @Override    public Object getNullableResult(ResultSet resultSet, String columnLabel) throws SQLException &#123;        return resultSet.getString(columnLabel);    &#125;    @Override    public Object getNullableResult(ResultSet resultSet, int columnIndex) throws SQLException &#123;        return resultSet.getString(columnIndex);    &#125;    @Override    public Object getNullableResult(CallableStatement callableStatement, int parameterIndex) throws SQLException &#123;        return callableStatement.getString(parameterIndex);    &#125;    @Override    public void setNonNullParameter(PreparedStatement preparedStatement, int i, Object object, JdbcType jdbcType) throws SQLException &#123;        pgObject.setType(&quot;json&quot;);        pgObject.setValue(JSON.toJSONString(object));        preparedStatement.setObject(i, pgObject);    &#125;&#125;</code></pre><p><strong>JSONObject类型数据</strong></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220712214436903.png" alt="image-20220712214436903"></p><p><strong>映射文件</strong></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220712214502296.png" alt="image-20220712214502296"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo部署到服务器</title>
      <link href="/2022/07/10/hexo-bu-shu-dao-fu-wu-qi/"/>
      <url>/2022/07/10/hexo-bu-shu-dao-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、服务器配置"><a href="#一、服务器配置" class="headerlink" title="一、服务器配置"></a>一、服务器配置</h2><h3 id="1-1-新建用户作为git登陆用户"><a href="#1-1-新建用户作为git登陆用户" class="headerlink" title="1.1 新建用户作为git登陆用户"></a>1.1 新建用户作为git登陆用户</h3><pre class="language-markup" data-language="markup"><code class="language-markup">[root@VM-12-10-centos superzqbo]# sudo adduser git[root@VM-12-10-centos superzqbo]# sudo passwd git更改用户 git 的密码 。新的 密码：重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。</code></pre><h3 id="1-2-修改新建用户的权限为git权限"><a href="#1-2-修改新建用户的权限为git权限" class="headerlink" title="1.2 修改新建用户的权限为git权限"></a>1.2 修改新建用户的权限为git权限</h3><p>现在这个用户是具备 SSH 权限的，我们需将其切换为仅具有 git 权限。</p><pre class="language-markup" data-language="markup"><code class="language-markup">$ vi /etc/passwd# git:x:1001:1001::/home/git:/bin/bash 修改为下面的$ git:x:1001:1001::/home/git:/bin/git-shell</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220707235803442.png" alt="image-20220707235803442"></p><h3 id="1-3-安装git"><a href="#1-3-安装git" class="headerlink" title="1.3 安装git"></a>1.3 安装git</h3><pre class="language-markup" data-language="markup"><code class="language-markup">[root@VM-12-10-centos superzqbo]# sudo yum install -y git</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220707210450899.png" alt="image-20220707210450899"></p><h3 id="1-4-生成git密钥"><a href="#1-4-生成git密钥" class="headerlink" title="1.4 生成git密钥"></a>1.4 生成git密钥</h3><p><code>ssh</code>，简单来讲，就是一个秘钥，其中，<code>id_rsa</code>是你这台电脑的私人秘钥，不能给别人看的，<code>id_rsa.pub</code>是公共秘钥，可以随便给别人看。把这个公钥放在<code>git仓库</code>上，这样当你链接<code>git仓库</code>自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过<code>git</code>上传你的文件到<code>git仓库</code>上。</p><p>如果有生成过git密钥，直接去~&#x2F;.ssh&#x2F;目录下查找即可，该目录下有两个文件</p><pre class="language-markup" data-language="markup"><code class="language-markup">公钥：id_rsa.pub私钥：id_rsa</code></pre><p>如果之前没有生成过，就需要使用下面指令生成一个</p><pre class="language-markup" data-language="markup"><code class="language-markup">ssh-keygen -t rsa -C "superzqbo@163.com"</code></pre><h3 id="1-5-将密钥保存在服务器"><a href="#1-5-将密钥保存在服务器" class="headerlink" title="1.5 将密钥保存在服务器"></a>1.5 将密钥保存在服务器</h3><pre class="language-markup" data-language="markup"><code class="language-markup">1、服务器运行下面命令，创建.ssh文件夹$ su git$ mkdir ~/.ssh2、创建.ssh/authorized_keys文件，打开authorized_keys文件并将id_rsa.pub的内容复制拷贝其中并保存$ vim ~/.ssh/authorized_keys3、修改权限$ chmod 755 ~$ chmod 700 ~/.ssh$ chmod 600 ~/.ssh/authorized_keys4、测试本地连接服务器（git bash here）,连接成功表示本地和服务器连接时ok的$ ssh -v git@42.194.221.71</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220707214208446.png" alt="image-20220707214208446"></p><h3 id="1-6-创建git仓库"><a href="#1-6-创建git仓库" class="headerlink" title="1.6 创建git仓库"></a>1.6 创建git仓库</h3><pre class="language-markup" data-language="markup"><code class="language-markup">1、切换到root用户，创建一个目录用于存储网站的根目录$ su root2、创建网站的根目录$ mkdir /home/superzqbo/git/hexo$ cd /home/superzqbo/git3、修改用户所有权和用户权限（将当前目录下，所有文件的拥有者修改为git，用户组改为 git）$ chown -R  git:git  hexo$ chown -R 755 hexo$ cd hexo4、创建一个git项目（这里有一个细节，就是.git目录必须要有可读写权限，因为当我们在push的时候，是使用git用户推送到服务器上面去，会有一个写入的过程，如果不赋予可写权限，push就会失败。git目录，用于存储记录版本信息）$ git init --bare hexo.git5、新建git 钩子 post-receive，方便博客推送自动部署(相当于拷贝一份到Ngnix的html当中)$ vim hexo.git/hooks/post-receive# 输入下面的数据#!/bin/shgit --work-tree=/home/superzqbo/hexo --git-dir=/home/superzqbo/git/hexo/hexo.git checkout -f6、赋予这个文件可执行权限chmod +x /home/superzqbo/git/hexo/hexo.git/hooks/post-receive</code></pre><p><strong>钩子函数解析</strong></p><pre class="language-java" data-language="java"><code class="language-java">git --work-tree&#x3D;&#x2F;home&#x2F;superzqbo&#x2F;hexo --git-dir&#x3D;&#x2F;home&#x2F;superzqbo&#x2F;git&#x2F;hexo&#x2F;hexo.git checkout -f# --work-tree&#x3D;&#x2F;home&#x2F;superzqbo&#x2F;hexo 指定hexo文件的位置(ngnix的根目录)    # --git-dir&#x3D;&#x2F;home&#x2F;superzqbo&#x2F;git&#x2F;hexo&#x2F;hexo.git git仓库的地址</code></pre><p>此时，使用客户端上传代码后，除了在仓库下还会在<code>/home/superzqbo/hexo</code>目录下生成上传的代码，Nginx当中指定地址是这个即可。</p><h2 id="二、客户端配置"><a href="#二、客户端配置" class="headerlink" title="二、客户端配置"></a>二、客户端配置</h2><h3 id="2-1-配置"><a href="#2-1-配置" class="headerlink" title="2.1 配置"></a>2.1 配置</h3><p>博客根目录_config下增加</p><pre class="language-java" data-language="java"><code class="language-java">root: &#x2F;deploy:  type: git     # 用户@服务器地址:git仓库地址  repository: git@42.194.221.71:&#x2F;home&#x2F;superzqbo&#x2F;git&#x2F;hexo&#x2F;hexo.git  branch: master</code></pre><h3 id="2-2-部署"><a href="#2-2-部署" class="headerlink" title="2.2 部署"></a>2.2 部署</h3><pre class="language-text" data-language="text"><code class="language-text">hexo cleanhexo ghexo d</code></pre><h3 id="2-3-Nginx配置"><a href="#2-3-Nginx配置" class="headerlink" title="2.3 Nginx配置"></a>2.3 Nginx配置</h3><p>参考地址：<a href="https://www.yyyzyyyz.cn/posts/45dafe31d273/">https://www.yyyzyyyz.cn/posts/45dafe31d273/</a></p><pre class="language-java" data-language="java"><code class="language-java"># 安装$ yum install -y nginx# 查看Nginx配置文件的位置$ whereis nginx  # 设置开机自启$ systemctl enable nginx.service  # 检查配置文件$ nginx -t</code></pre><p><strong>配置nginx为服务(Systemd服务)</strong></p><pre class="language-java" data-language="java"><code class="language-java">vim &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service--------------------------------------------------------  [Unit]Description&#x3D;nginxAfter&#x3D;network.target  [Service]Type&#x3D;forkingExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginxExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reloadExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s quitPrivateTmp&#x3D; true  [Install]WantedBy&#x3D;multi-user.target  --------------------------------------------------------  [Unit]:服务的说明Description:描述服务After:描述服务类别[Service]服务运行参数的设置Type&#x3D;forking是后台运行的形式ExecStart为服务的具体运行命令ExecReload为重启命令ExecStop为停止命令PrivateTmp&#x3D;True表示给服务分配独立的临时空间注意：[Service]的启动、重启、停止命令全部要求使用绝对路径[Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3</code></pre><p><strong>配置如下</strong></p><pre class="language-markup" data-language="markup"><code class="language-markup">server &#123;  listen       80 default_server;  listen       [::]:80 default_server;  server_name  42.194.221.71;  root         /home/superzqbo/hexo;// 代码地址  charset koi8-r;  # access_log  /var/log/nginx/host.access.log  main;  location / &#123;  &#125;  error_page  404              /404.html;  location = /40x.html &#123;  &#125;  # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;  location = /50x.html &#123;    root   html;  &#125;  # proxy the PHP scripts to Apache listening on 127.0.0.1:80    #    #location ~ \.php$ &#123;    #    proxy_pass   http://127.0.0.1;    #&#125;  # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    #    #location ~ \.php$ &#123;    #    root           html;    #    fastcgi_pass   127.0.0.1:9000;    #    fastcgi_index  index.php;    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;    #    include        fastcgi_params;    #&#125;  # deny access to .htaccess files, if Apache's document root    # concurs with nginx's one    #    #location ~ /\.ht &#123;    #    deny  all;    #&#125;&#125;</code></pre><h2 id="三、Https配置"><a href="#三、Https配置" class="headerlink" title="三、Https配置"></a>三、Https配置</h2><p>参考地址： <a href="https://www.freesion.com/article/16501347598/">https://www.freesion.com/article/16501347598/</a></p><p>步奏如下</p><pre class="language-java" data-language="java"><code class="language-java">1、首先我们要拥有一个域名。本文使用的是腾讯云注册的域名。接着申请免费的SSL域名证书。  2、腾讯云首页登录后搜索SSL（其他网站类似），申请SSL证书，一般申请过程会在4小时以内给出结果  3、SSL证书申请成功之后，将其文件点击下载到本地上。这里我们使用的是Nginx证书  4、在服务器Nginx配置文件同级目录创建一个conf目录，将Nginx证书上传到该目录下  5、修改Nginx配置文件</code></pre><pre class="language-markup" data-language="markup"><code class="language-markup"># HTTPS server#server &#123;    #SSL 访问端口号为 443    listen       443 ssl;    #填写绑定证书的域名    server_name  www.superbo.cloud;    #证书文件名称    ssl_certificate      /usr/local/nginx/conf/conf/superbo.cloud_bundle.pem;    #私钥文件名称    ssl_certificate_key  /usr/local/nginx/conf/conf/superbo.cloud.key;    ssl_session_cache    shared:SSL:1m;    ssl_session_timeout  5m;    #请按照以下协议配置    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;    ssl_prefer_server_ciphers  on;    root         /home/superzqbo/hexo;    location / &#123;    &#125;&#125;server &#123;    listen 80;    #填写绑定证书的域名    server_name www.superbo.cloud;    #把http的域名请求转成https    return 301 https://$host$request_uri;&#125;</code></pre><p>注意，如果网站想要正常访问，还需要进行备案！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket通信</title>
      <link href="/2022/07/06/socket-tong-xin/"/>
      <url>/2022/07/06/socket-tong-xin/</url>
      
        <content type="html"><![CDATA[<h3 id="一、数据通信过程"><a href="#一、数据通信过程" class="headerlink" title="一、数据通信过程"></a>一、数据通信过程</h3><p><strong>一个数据包经由应用程序产生，进入到协议栈中进行各种报文头的包装，然后操作系统调用网卡驱动程序指挥硬件，把数据发送到对端主机</strong>。整个过程的大体的图示如下。</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220706142933670.png" alt="image-20220706142933670"></p><p>协议栈其实是位于操作系统中的一些协议的堆叠，这些协议包括 TCP、UDP、ARP、ICMP、IP等。</p><pre class="language-java" data-language="java"><code class="language-java">通常某个协议的设计都是为了解决某些问题，比如TCP 的设计就负责安全可靠的传输数据，UDP 设计就是报文小，传输效率高，ARP 的设计是能够通过 IP 地址查询物理（Mac）地址，ICMP 的设计目的是返回错误报文给主机，IP 设计的目的是为了实现大规模主机的互联互通。    </code></pre><p><strong>一般处于协议上层的是TCP、UDP协议，IP协议处于下层，这个从TCP&#x2F;IP四层协议当也可以看得到，IP协议是不可靠的，需要为上层的TCP协议提供通信支持，TCP协议是可靠的，因为有三次握手四次挥手。</strong></p><p>应用程序比如浏览器、电子邮件、文件传输服务器等产生的数据，会通过传输层协议进行传输，而应用程序是不会和传输层直接建立联系的，而是有一个能够连接应用层和传输层之间的套件，这个套件就是 <code>Socket</code>。</p><p>应用程序的下面就是操作系统内部，操作系统内部包括协议栈，协议栈是一系列协议的堆叠。操作系统下面就是网卡驱动程序，网卡驱动程序负责控制网卡硬件，驱动程序驱动网卡硬件完成收发工作.</p><h3 id="二、通过netstat-命令来展示套接字"><a href="#二、通过netstat-命令来展示套接字" class="headerlink" title="二、通过netstat 命令来展示套接字"></a>二、通过netstat 命令来展示套接字</h3><pre class="language-java" data-language="java"><code class="language-java">netstat -ano # netstat 用于显示套接字内容 , -ano 是可选选项# a 不仅显示正在通信的套接字，还显示包括尚未开始通信等状态的所有套接字# n 显示 IP 地址和端口号# o 显示套接字的程序 PID</code></pre><p><img src="https://pic3.zhimg.com/v2-a5b445147b1f4a683500901d35704662_r.jpg" alt="preview"></p><p>图中的每一行都相当于一个套接字，每一列也被称为一个元组，所以一个套接字就是五元组（协议、本地地址、外部地址、状态、PID）。有的时候也被叫做四元组，四元组不包括协议。</p><p>比如图中的第一行，它的协议就是 TCP，本地地址和远程地址都是 0.0.0.0，这表示通信还没有开始，IP 地址暂时还未确定，而本地端口已知是 135，但是远程端口还未知，此时的状态是 <code>LISTENING</code>，LISTENING 表示应用程序已经打开，正在等待与远程主机建立连接最后一个元组是 PID，即进程标识符，PID 就像我们的身份证号码，能够精确定位唯一的进程。</p><h3 id="三、OSI七层协议模型-open-system-interconnection"><a href="#三、OSI七层协议模型-open-system-interconnection" class="headerlink" title="三、OSI七层协议模型 (open system interconnection)"></a>三、OSI七层协议模型 (open system interconnection)</h3><pre class="language-java" data-language="java"><code class="language-java">应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等表示层：处理数据格式，数据加密等会话层：建立、维护和管理会话传输层：TCP，UDP网络层：IP，ICMP，OSPF，EIGRP，IGMP数据链路层：SLIP，CSLIP，PPP，MTU物理层：比特流传输</code></pre><p>每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220706135944058.png" alt="image-20220706135944058"></p><p>通过上面的图形，由于底一层的需要向高一层的提供服务，我们大致的理解<strong>应用程序需要传输层的tcp和网络层的ip协议提供服务</strong>，可以说，TPC&#x2F;IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。</p><h3 id="四、Socket"><a href="#四、Socket" class="headerlink" title="四、Socket"></a>四、Socket</h3><p><strong>Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口，Socket是对TCP&#x2F;IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP&#x2F;IP协议。</strong></p><h4 id="3-1-Socket创建"><a href="#3-1-Socket创建" class="headerlink" title="3.1 Socket创建"></a>3.1 Socket创建</h4><p>Socket 是和应用程序一起创建的。</p><pre class="language-java" data-language="java"><code class="language-java">1、应用程序中有一个 socket 组件，在应用程序启动时，会调用 socket 申请创建套接字，协议栈会根据应用程序的申请创建套接字：2、首先分配一个套接字所需的内存空间，这一步相当于是为控制信息准备一个容器，但只有容器并没有实际作用，所以你还需要向容器中放入控制信息；3、如果你不申请创建套接字所需要的内存空间，你创建的控制信息也没有地方存放，所以分配内存空间，放入控制信息缺一不可。至此套接字的创建就已经完成了。4、套接字创建完成后，会返回一个套接字描述符给应用程序，这个描述符相当于是区分不同套接字的号码牌。根据这个描述符，应用程序在委托协议栈收发数据时就需要提供这个描述符。</code></pre><h4 id="3-2-套接字连接"><a href="#3-2-套接字连接" class="headerlink" title="3.2 套接字连接"></a>3.2 套接字连接</h4><p>套接字创建完成后，最终还是为数据收发服务的，在数据收发之前，还需要进行一步 <code>connect</code>，也就是建立连接的过程。应用程序通过 TCP&#x2F;IP 协议标准从一个主机通过网络介质传输到另一个主机的过程。</p><pre class="language-java" data-language="java"><code class="language-java">1、套接字刚刚创建完成后，还没有数据，也不知道通信对象。在这种状态下，即使你让客户端应用程序委托协议栈发送数据，它也不知道发送到哪里。    2、所以浏览器需要根据网址来查询服务器的 IP 地址，做这项工作的协议是 DNS，查询到目标主机后，再把目标主机的 IP 告诉协议栈，至此，客户端这边就准备好了    3、在服务器上，与客户端一样也需要创建套接字，但是同样的它也不知道通信对象是谁，所以我们需要让客户端向服务器告知客户端的必要信息：IP 地址和端口号。    4、通信双方收到数据之后，还需要一块位置来存放，这个位置就是缓冲区，它是内存的一部分，有了缓冲区，就能够进行数据的收发操作了。</code></pre><p>具体实现</p><p>客户端应用程序需要调用 <code>Socket</code> 库中的 connect 方法，提供 socket 描述符和服务器 IP 地址、端口号。</p><p>这些信息会传递给协议栈中的 TCP 模块，TCP 模块会对请求报文进行封装，再传递给 IP 模块，进行 IP 报文头的封装，然后传递给物理层，进行帧头封装，之后通过网络介质传递给服务器，服务器上会对帧头、IP 模块、TCP 模块的报文头进行解析，从而找到对应的套接字，套接字收到请求后，会写入相应的信息，并且把状态改为正在连接。请求过程完成后，服务器的 TCP 模块会返回响应，这个过程和客户端是一样的。</p><h3 id="四、TCP-x2F-IP、Socket、Http的区别"><a href="#四、TCP-x2F-IP、Socket、Http的区别" class="headerlink" title="四、TCP&#x2F;IP、Socket、Http的区别"></a>四、TCP&#x2F;IP、Socket、Http的区别</h3><p>http是要基于TCP连接基础上的，简单的说，TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。客户端和应用服务器建立TCP连接之后，就需要用http协议来传送数据了，HTTP协议简单来说，还是请求，确认，连接。 总体就是C发送一个HTTP请求给S，S收到了这个http请求，然后返回给Chttp响应，然后C的中间件或者说浏览器把这些数据渲染成为了网页，展示在用户面前。</p><pre class="language-java" data-language="java"><code class="language-java">1.socket是通信的基石，是TCP&#x2F;IP的基本操作单元（最小单位），可以理解为TCP&#x2F;IP的封装，调用接口,(所有的程序都是默认调用吗？)    2.应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务(所有应用层都一样？)    3.HTTP等应用层协议，格式的统一（像串口协议一样，格式和速度）    4.Http是基于TCP协议的，tcp计算机通信传数据，但是无法解析数据，解析需要http协议</code></pre><p>http是网络上层协议。底层还是socket短连接是发送数据时进行联接。发送完关闭(http基于短连接的tcp协议)；可以认为不论应用层协议使用的是什么，都是通过调用Socket(对传输层的封装)去进行数据传输的。</p><p>具体应用层使用什么协议，需要按照实际需求去进行操作，比如短连接则可以通过http请求实现；长链接可以使用调用Socket去实现。</p><pre class="language-java" data-language="java"><code class="language-java">长连接：通信双方长期的保持一个连接状态不断开，一旦建立连接后，就不断开，除非发生异常，比较消耗IO资源。短连接：通信双方不是保持一个长期的连接状态，比如Http协议，当客户端发起http请求，服务器处理http请求，当服务器处理完成后，返回客户端数据后就断开链接。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="/2022/07/03/docker-xue-xi-bi-ji/"/>
      <url>/2022/07/03/docker-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>Docker是基于go开发的</p><h3 id="一、为什么使用docker"><a href="#一、为什么使用docker" class="headerlink" title="一、为什么使用docker"></a>一、为什么使用docker</h3><p>带着环境安装到Docker上，解决环境问题；解决了集群问题</p><p>镜像：将代码，Redis、、、等环境打包成一个镜像，在其他地方可以直接运行，无需在重新安装软件、代码；将正确的环境打包成镜像，直接运行，理念是一次打包处处运行，”一次封装，处处运行”</p><p>只需要一次配置好环境，换到其他的机子上就可以一键运行，大大简化了操作</p><p>四个集装箱（部署四个软件），各自独立，放到一个镜像当中，运行镜像即可</p><h3 id="二、Docker三要素：仓库、镜像、容器"><a href="#二、Docker三要素：仓库、镜像、容器" class="headerlink" title="二、Docker三要素：仓库、镜像、容器"></a>二、Docker三要素：仓库、镜像、容器</h3><p>容器：集装箱就是一个容器，每一个容器当中安装我们要需要的软件，Docker就是鲸鱼，背上有几个集装箱就有几个容器</p><p>虚拟机：模拟的是整套操作系统（模拟的操作系统、软硬件—虚拟硬件，然后在硬件上虚拟软件操作系统），但是启动时间时分钟级别的，Docker启动时秒级别的；</p><p>Docker模拟的是操作系统，直接运行在宿主机上的（没有进行硬件虚拟），没有虚拟自己的内核，用的是宿主机的，所以启动快；容器之间是相互隔离的，每个容器由自己的文件系统，容器之间进程不会相互影响，能区分计算资源</p><p>运行环境的打包封装，这饿环境的一个整体就是镜像，DockerHub上就是存镜像的，</p><p>从仓库拉一个应用到本地就是镜像（Image）,某一个镜像的实例就是一个集装箱容器，各自独立的容器就是一个一个的环境(Redis、Ngnix)</p><h4 id="1、镜像"><a href="#1、镜像" class="headerlink" title="1、镜像"></a>1、镜像</h4><p>镜像(Image)：Docker镜像就是一个只读的模版，镜像可以用来创建Docker容器，一个镜像可以创建很多容器—类</p><h4 id="2、容器"><a href="#2、容器" class="headerlink" title="2、容器"></a>2、容器</h4><p>容器(Container)：镜像的实例—对象，Docker利用容器运行一个或一组应用，容器是用镜像创建的运行实例，可以对容器进行启动、开始、停止、删除；每个容器都是相互隔离的、保证安全的平台</p><p>可以吧容器看成是一个简易版本的Linux环境(包括root用户权限、进程空间、用户空间、网络空间等)和运行在其中的程序</p><p>容器的定义和镜像几乎一摸一样，也是一堆层的统一视角，唯一的区别是，容器的最上面那一层是可读可写的</p><p>容器是一个运行时环境，可以看成是鲸鱼上一个个的集装箱。</p><h4 id="3、仓库"><a href="#3、仓库" class="headerlink" title="3、仓库"></a>3、仓库</h4><p>仓库(Repository)：仓库是存放镜像文件的场所,仓库和仓库注册服务器是有区别的，仓库注册服务器上面存放着多个仓库，每个仓库又包含多个镜像，每个镜像又不同的标签(tag)</p><p>仓库分为公共仓库(public)和私有仓库(private)2种，最大的公共仓库是Docker Hub(<a href="https://hub.docker.com)---在国外,特别慢,存放了数量庞大的镜像供用户下载,国内的公共开源镜像又阿里云、网易云等/">https://hub.docker.com)---在国外，特别慢，存放了数量庞大的镜像供用户下载，国内的公共开源镜像又阿里云、网易云等</a></p><p>Docker本身是一个容器运行载体，或者称之为管理引擎，我们把应用程序和配置文件打包成包，形成一个可交付的运行环境，这个打包好的运行环境就似乎是一个镜像，只有通过镜像才可以生成Docker容器</p><p>镜像可以看成是容器的模版，Docker根据Image文件生成容器的实例，同一个镜像文件，可以生成多个同时运行的容器实例。</p><p>镜像文件生成的容器实例，本身也是一个文件，称为镜像文件</p><p>一个容器运行一种服务，当我们需要的时候，就可以通过Docker客户端创建一个对应的运行实例，也就是我们的容器</p><p>至于仓库，也就是存放镜像的地方，我们可以吧镜像发布到仓库中，需要的时候从仓库中拉下来救可以啦</p><p>平台架构图如下所示：</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220618162307428.png" alt="image-20220618162307428"></p><h3 id="三、指令"><a href="#三、指令" class="headerlink" title="三、指令"></a>三、指令</h3><p>1、docker相关–帮助启动类命令</p><pre class="language-java" data-language="java"><code class="language-java"># 启动$ systemctl start docker  # 停止$ systemctl stop docker  # 重启$ systemctl restart docker  # 查看状态$ systemctl status docker  # 开机自启$ systemctl enable docker  # docker信息$ docker info  # 帮助$ docker --help  # 具体帮助$ docker  具体指令 --help</code></pre><p>2、镜像</p><pre class="language-jav" data-language="jav"><code class="language-jav"># 查看所有镜像$ docker images# 查看远程镜像$ docker search 镜像名# 下载镜像$ docker pull 镜像名# 查看 镜像&#x2F;容器&#x2F;数据卷所占用的内存空间$ docker system df# 删除镜像$ docker rmi 镜像名# 强制删除镜像$ docker rmi -f 镜像名</code></pre><p>虚悬镜像：仓库名和tag都是空的镜像，一般是由于构建镜像的时候出问题导致的，这种镜像删除就好了</p><p>3、容器</p><pre class="language-java" data-language="java"><code class="language-java"># 运行ubunto:latest镜像，并开启交互式模式启动一个容器，在容器内部执行&#x2F;bin&#x2F;sh指令，推出使用exec；$ docker run -it ubunto &#x2F;bin&#x2F;sh# 给容器起名字$ docker run -it --name&#x3D;&quot;myubunto&quot; ubunto &#x2F;bin&#x2F;sh# 后台方式启动容器$ docker run -d --name&#x3D;&quot;myubunto&quot; ubunto # 列出所有正在运行的容器$ docker ps# 列出所有正在运行&#x2F;历史运行的容器包括挂了的容器）$ docker ps -a# 列出最近创建的容器（包括挂了的容器）$ docker ps -l# 列出最近创建的3个容器（包括挂了的容器）$ docker ps -n 3    # 退出容器--容器关闭$ exec# 退出容器--容器不关闭$ ctrl+p+q  # 启动已经停止运行的容器$ docker start 容器ID&#x2F;名字  # 重启容器$ docker restart 容器ID&#x2F;名字    # 关闭容器$ docker stop 容器ID&#x2F;名字   # 强制停止容器$ docker kill 容器ID&#x2F;名字     # 删除已停止的容器$ docker rm 容器ID&#x2F;名字       # 查看容器运行日志$ docker logs 容器ID  # 查看容器内部运行的进程$ docker top 容器ID  # 查看容器内部情况$ docker inspect 容器ID  </code></pre><p>exec和attach的区别</p><pre class="language-java" data-language="java"><code class="language-java"># 使用exit退出不会关闭容器(一般进入容器当中查看信息)docker exec -it 容器ID  &#x2F;bin&#x2F;sh # 使用exit退出会关闭容器docker attach 容器ID </code></pre><p>从镜像的角度看，可以把容器看成是简易版本的Linux环境，</p><pre class="language-java" data-language="java"><code class="language-java"># 将容器内的内容拷贝到宿主机上$ docker cp 容器ID：容器内路径  宿主机路径# 将容器拷贝到宿主机上,归档成一个tar包$ docker export 容器ID  &gt;  文件名.tareg: docker export efewtwe1231  &gt;  ubunto.tar# 根据tar包的内容创建一个新的系统并导入成镜像(即新建一个镜像)$ cat  文件名.tar | docker import - 镜像用户&#x2F;镜像名：版本号eg: cat  ubunto.tar | docker import - techen&#x2F;ubanto：3.7</code></pre><h3 id="四、Docker仓库"><a href="#四、Docker仓库" class="headerlink" title="四、Docker仓库"></a>四、Docker仓库</h3><p>镜像是只读的，容器是可写的，一般在容器当中新增功能，然后使用commit指令生成新的镜像</p><pre class="language-java" data-language="java"><code class="language-java"># 提交镜像:提交之后成为了一个新的镜像$ docker commit  # 提交镜像:提交之后成为了一个新的镜像$ docker commit -m&#x3D;&quot;提交的描述信息&quot; -a&#x3D;&quot;作者&quot; 容器ID  要创建的目标镜像名：版本eg：docker commit -m&#x3D;&quot;add vim &quot; -a&#x3D;&quot;techen&quot; efrfsfd12  techen&#x2F;myubunto:3.23  </code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619145133791.png" alt="image-20220619145133791"></p><p>1、将本地镜像提交到阿里云镜像当中</p><p>登陆阿里云—&gt; 管理控制台—〉 容器镜像服务 —&gt;实例列表 —&gt; 个人实例 —&gt; 命名空间建命名、镜像仓库建立仓库</p><pre class="language-java" data-language="java"><code class="language-java">1. 登录阿里云Docker Registry$ docker login --username&#x3D;乾程吴彦祖 registry.cn-hangzhou.aliyuncs.com用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。（bzq18107155240）您可以在访问凭证页面修改凭证密码。2. 从Registry中拉取镜像$ docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;techen&#x2F;superzqbo:[镜像版本号]3. 将镜像推送到Registry$ docker login --username&#x3D;乾程吴彦祖 registry.cn-hangzhou.aliyuncs.com$ docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com&#x2F;techen&#x2F;superzqbo:[镜像版本号]$ docker push registry.cn-hangzhou.aliyuncs.com&#x2F;techen&#x2F;superzqbo:[镜像版本号]请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。4. 选择合适的镜像仓库地址从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-hangzhou.aliyuncs.com 作为Registry的域名登录。5. 示例使用&quot;docker tag&quot;命令重命名镜像，并将它通过专有网络地址推送至Registry。$ docker imagesREPOSITORY                                                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZEregistry.aliyuncs.com&#x2F;acs&#x2F;agent                                    0.7-dfb6816         37bb9c63c8b2        7 days ago          37.89 MB$ docker tag 37bb9c63c8b2 registry-vpc.cn-hangzhou.aliyuncs.com&#x2F;acs&#x2F;agent:0.7-dfb6816使用 &quot;docker push&quot; 命令将该镜像推送至远程。$ docker push registry-vpc.cn-hangzhou.aliyuncs.com&#x2F;acs&#x2F;agent:0.7-dfb6816</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619152906932.png" alt="image-20220619152906932"></p><p>2、将本地镜像推送到私服</p><p>在本地新建一个私有仓库供内部使用，Docker Registry是官方提供的工具，用于构建本地私有镜像仓库</p><pre class="language-java" data-language="java"><code class="language-java"># 拉取Docker Registry工具$ docker pull registry  # 查看拉取Docker Registry工具是否成功$ docker images  # 运行私有库Registry，相当于本地有一个Docker Hub;默认情况下会被容器会被创建在&#x2F;var&#x2F;lib&#x2F;registry下$ docker run -d -p 5000:5000 -v &#x2F;home&#x2F;techen&#x2F;docker_registry&#x2F;:tmp&#x2F;registry --privileged&#x3D;true registry    # 验证私服库上有什么镜像（相当于发送了一个Get请求）$ curl -XGET http:&#x2F;&#x2F;ip:port&#x2F;v2&#x2F;_catalog# 将新镜像改造成符合私服镜像的tag$ docker tag 镜像：Tag  IP：port&#x2F;Repository:Tag  # 推送$ docker push ip:port&#x2F;镜像:版本  # 拉取$ docker pull ip:port&#x2F;镜像:版本</code></pre><p>Docker默认不支持http方式推送镜像，要做如下处理</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619160634368.png" alt="image-20220619160634368"></p><h3 id="五、数据卷"><a href="#五、数据卷" class="headerlink" title="五、数据卷"></a>五、数据卷</h3><p>Docker挂载主机目录访问出现：cannot open directory.:Permission denied</p><p>解决办法；在挂载后面加上 –privileged &#x3D; true 参数即可</p><p>原理：Linux内部默认关掉了容器目录挂载的权限</p><p>数据卷主要的作用是映射(数据互相访问)，完成容器内数据的持久化</p><pre class="language-java" data-language="java"><code class="language-java"># 运行一个带有数据卷的容器（如果目录不存在，会自动创建）$ docker run -it --priviledged&#x3D;true -v 宿主机目录:&#x2F;容器目录  --name&#x3D;容器起名  镜像名    # 运行一个带有数据卷的容器（如果目录不存在，会自动创建）,容器可读可写(默认)$ docker run -it --priviledged&#x3D;true -v 宿主机目录:&#x2F;容器目录:rv  --name&#x3D;容器起名  镜像名  # 运行一个带有数据卷的容器（如果目录不存在，会自动创建）,容器可读不可写(容器内不能创建目录、编写文件)$ docker run -it --priviledged&#x3D;true -v 宿主机目录:&#x2F;容器目录:ro  --name&#x3D;容器起名  镜像名</code></pre><pre class="language-java" data-language="java"><code class="language-java"># 查看挂载信息(Mounts里面会有挂载信息)$ docker inspect 容器id</code></pre><p>数据卷的继承和共享</p><pre class="language-java" data-language="java"><code class="language-java"># 实现容器u1和u2之间的数据共享$ docker run -it --priviledged&#x3D;true --volumes-from 父类(容器名-u1)   --name&#x3D;u2  镜像名</code></pre><h3 id="六、DockerFile"><a href="#六、DockerFile" class="headerlink" title="六、DockerFile"></a>六、DockerFile</h3><p>1、DockerFile概念</p><p>DockerFile是用来构建<strong>Docker镜像</strong>的文本文件，是由一条条构建镜像所需的指令和参数构成的<strong>脚本</strong></p><p>DockerFile相当于是一个镜像文件，是可以正常打包运行的</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619170534907.png" alt="image-20220619170534907"></p><p>2、DockerFile构建过程</p><p>DockerFile内容基础知识</p><pre class="language-java" data-language="java"><code class="language-java">1、每条保留字指令都必须为大写字母且后面要跟随至少一个参数2、指令按照从上到下的顺序执行3、#表示注解4、每条指令都会创建一个新的镜像层，并对镜像层进行镜像提交</code></pre><p>3、Docker执行DockerFile的大致流程</p><pre class="language-java" data-language="java"><code class="language-java">1、Docker从基础镜像运行一个容器2、执行一条指令并对容器做出修改3、执行类似docker commit的操作提交一个新的镜像层4、docker基于刚刚提交的镜像运行一个新的容器5、执行DockerFile当中的下一条指令，直到所有的指令都执行完毕</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619172050676.png" alt="image-20220619172050676"></p><p>4、DockerFile保留字介绍</p><pre class="language-java" data-language="java"><code class="language-java">FROM:基础镜像，当前的新镜像是基于哪个镜像MAINTAINER：镜像维护者的姓名和邮箱RUN：容器构建是需要执行的指令，即build时就会执行DockerFile当中run里面的指令，一般有2种格式shell、exec格式(docker build时执行)EXPOSE：当前容器对外暴漏的端口WORKDIR：指定在创建容器后，终端默认登陆进来的目录，一个落脚点USER：指令该镜像已什么样的用户去执行，默认rootENV：设置环境变量，设置后后面可以使用     eg: ENV MY_PATH &#x2F;usr&#x2F;mytest         WORKDIR $MY_PATHADD:将宿主机目录下的文件拷贝进镜像，且会自动处理URL和解压tar压缩包(copy+解压)COPY：类似ADD，将文件拷贝到镜像VOLUME：数据卷CMD：指定容器启动后要做的操作，DockerFile当中可以有多个CMD指令，但是只有最后一个会生效，CMD会被docker run之后的参数替换掉     CMD是在docker run的时候运行     RUN是在docker build的时候运行ENTRYPOINT:也是用来指定一个**容器启动时要执行的指令**，类似于CMD，但是ENTRYPOINT不会被docker run之后的参数替换掉，而且这些命令行参数会被当中参数传递给ENTRYPOINT指定的程序     ENTRYPOINT[&quot;exec&quot;,&quot;parm1&quot;,&quot;parm2&quot;]     ENTRYPOINT、CMD可以一起使用，一般变参会使用CMD，这里的CMD相当于给ENTRYPOINT传递参数     eg:FROM nginx          ENTRYPOINT [&quot;nginx&quot;,&quot;-c&quot;] # 定参          CMD [&quot;&#x2F;etc&#x2F;ngnix&#x2F;nginx.conf&quot;]   #变参     ------》 nginx -c &#x2F;etc&#x2F;ngnix&#x2F;nginx.conf  </code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619175320535.png" alt="image-20220619175320535"></p><p>5、构建DockerFile文件</p><p>1、编写</p><pre class="language-java" data-language="java"><code class="language-java">FROM java:8   # java8作为基础镜像ENV PROJECT_HOME &#x2F;home&#x2F;project  #设置环境变量，设置后后面可以使用ENV FILE_NAME placeholderENV EXPOSE_PORT 8080ENV ACTIVE_ENV devENV JAVA_OPTS &quot;&quot;RUN ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtimeRUN echo &#39;Asia&#x2F;Shanghai&#39; &gt;&#x2F;etc&#x2F;timezoneRUN apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf &#x2F;var&#x2F;cache&#x2F;apk&#x2F;*RUN set -x &amp;&amp; \    mkdir -p &#x2F;root&#x2F;logs&#x2F;$FILE_NAME &amp;&amp; \    mkdir -p $PROJECT_HOMEWORKDIR $PROJECT_HOMEENTRYPOINT [ &quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom -jar $PROJECT_HOME&#x2F;$FILE_NAME.jar --spring.profiles.active&#x3D;$ACTIVE_ENV&quot; ]EXPOSE $EXPOSE_PORT</code></pre><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619181857597.png" alt="image-20220619181857597"></p><p>2、构建</p><pre class="language-java" data-language="java"><code class="language-java"># 在dockerfile文件下执行下面的指令（注意tag后面有个空格和点）$ docker build -t 新镜像的名字：TAG .</code></pre><p>3、运行</p><pre class="language-java" data-language="java"><code class="language-java">docker run 镜像名  # 测试服务接口是否可用  $ curl  127.0.0.1:6001&#x2F;order&#x2F;test</code></pre><h3 id="七、Docker网络"><a href="#七、Docker网络" class="headerlink" title="七、Docker网络"></a>七、Docker网络</h3><p>docker安装之后会默认创建三个网络</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621003150868.png" alt="image-20220621003150868"></p><pre class="language-java" data-language="java"><code class="language-java"># 创建网络$ docker network create net1  # 删除网络$ docker network rm net1  # 查看网络源数据$ docker network inspect net1</code></pre><p>1、容器之间的互联通信以及端口映射</p><p>2、容器Ip发生变化时，可以通过服务名直接调用</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621003304909.png" alt="image-20220621003304909"></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220619205257295.png" alt="image-20220619205257295"></p><p>Docker容器内部的IP时有可能变化的，所以一般相互通信的服务要设置在同一个网段下面，新建一个网络，它的驱动模式是bridge。</p><h3 id="八、Docker-compose"><a href="#八、Docker-compose" class="headerlink" title="八、Docker-compose"></a>八、Docker-compose</h3><p>用来做容器管理的，相当于一次启动所有容器</p><pre class="language-java" data-language="java"><code class="language-java">Docker-compose使用的流程1、编写DockerFile文件，定义各个微服务并构建成镜像2、使用Docker-componse定义完整的业务单元3、使用docker-compose up启动</code></pre><p>常用指令</p><pre class="language-java" data-language="java"><code class="language-java"># 查看帮助$ docker-compose -h   # 启动服务$ docker-compose up   # 后台启动服务$ docker-compose up -d  # 停止并删除所有容器、网络、卷、镜像$ docker-compose down  # 进入容器内部$ docker-compose exec yml里面服务的ID &#x2F;bin&#x2F;bash  # 展示所有当前docker-compose编排过且运行的容器$ docker-compose ps # 展示所有当前docker-compose编排过的容器的进程$ docker-compose top  # 查看容器的输出日志$ docker-compose logs yml里面服务的ID # 检查配置(检查语法)$ docker-compose config # 检查配置，有问题才输出$ docker-compose config -q  # 重启$ docker-compose restart  # 关闭$ docker-compose stop  # 开启$ docker-compose start</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark使用手册</title>
      <link href="/2022/05/11/wireshark-shi-yong-shou-ce/"/>
      <url>/2022/05/11/wireshark-shi-yong-shou-ce/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Wireshark-介绍"><a href="#一、Wireshark-介绍" class="headerlink" title="一、Wireshark 介绍"></a>一、Wireshark 介绍</h2><p>Wireshark是网络包分析工具，可以捕获多种网络接口类型的包，甚至包括无线局域网接口网络。包分析工具的主要作用是尝试分析捕获到的数据包，并尝试显示数据包尽可能详细的信息。</p><p>Wireshark是开源软件项目，用GPL（General Public License）协议发行。可以免费在任意数量的机器上使用，不用担心授权和付费问题，所有的源代码在GPL框架下都可以免费使用。因为以上原因，人们可以很容易在Wireshark上添加新的协议，或者将其作为插件整合到自己的程序里，这种应用十分广泛。</p><h2 id="二、Wireshark下载、安装"><a href="#二、Wireshark下载、安装" class="headerlink" title="二、Wireshark下载、安装"></a>二、Wireshark下载、安装</h2><p>官网下载,一路next即可：<a href="https://www.wireshark.org/">https://www.wireshark.org</a></p><h2 id="三、界面介绍"><a href="#三、界面介绍" class="headerlink" title="三、界面介绍"></a>三、界面介绍</h2><h3 id="3-1-打开Wireshark-2-6-5，主界面如下："><a href="#3-1-打开Wireshark-2-6-5，主界面如下：" class="headerlink" title="3.1 打开Wireshark 2.6.5，主界面如下："></a>3.1 打开Wireshark 2.6.5，主界面如下：</h3><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621192240599.png" alt="image-20220621192240599"></p><h3 id="3-2-选择要捕获的连接，双击打开"><a href="#3-2-选择要捕获的连接，双击打开" class="headerlink" title="3.2 选择要捕获的连接，双击打开"></a>3.2 选择要捕获的连接，双击打开</h3><p>此时会显示所有，需要进行筛选</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621192325257.png" alt="image-20220621192325257"></p><h3 id="3-3-按照条件刷选包"><a href="#3-3-按照条件刷选包" class="headerlink" title="3.3 按照条件刷选包"></a>3.3 按照条件刷选包</h3><p><a href="https://blog.csdn.net/qq_44275213/article/details/118873256">https://blog.csdn.net/qq_44275213/article/details/118873256</a></p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621192356639.png" alt="image-20220621192356639"></p><h4 id="3-3-1-列表介绍"><a href="#3-3-1-列表介绍" class="headerlink" title="3.3.1 列表介绍"></a>3.3.1 列表介绍</h4><p>数据包列表窗格，显示捕获的数据包，每个数据包包含编号，时间戳，源地址，目标地址，协议，长度和数据包信息。不同的协议数据包使用不同的颜色区分</p><p>时间格式化：视图—&gt;显示时间格式化—&gt;格式化时间</p><p><img src="https://superzqbo.oss-cn-hangzhou.aliyuncs.com/image-20220621192419204.png" alt="image-20220621192419204"></p><h2 id="四、重点分析："><a href="#四、重点分析：" class="headerlink" title="四、重点分析："></a>四、重点分析：</h2><p><a href="https://blog.csdn.net/itcodexy/article/details/122593288">https://blog.csdn.net/itcodexy/article/details/122593288</a></p><p>对于我们日常的分析有用的就是前面的五个字段。它们的含义是：SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有DATA数据传输，RST表示连接重置。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> WireShark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/05/hello-world/"/>
      <url>/2022/05/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
